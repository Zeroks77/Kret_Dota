<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1">
<title>Kret's EU Dota League – Dynamic Viewer</title>
<link href='https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap' rel='stylesheet'>
<style>
:root{--bg:#0b1020;--panel:#121832;--muted:#9aa3b2;--text:#eef1f7;--accent:#9ec7ff;--chip:#1a2142;--border:rgba(255,255,255,.08)}
*{box-sizing:border-box}
body{margin:0;background:radial-gradient(1200px 600px at 10% -10%, #172045, transparent 60%), var(--bg);color:var(--text);font-family:Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif}
a{color:var(--accent)}
.wrapper{max-width:1180px;margin:0 auto;padding:16px}
.header{display:flex;align-items:center;gap:12px;margin-bottom:12px}
.card{background:linear-gradient(180deg,rgba(255,255,255,.04),rgba(255,255,255,.02));border:1px solid var(--border);border-radius:14px;padding:12px;overflow:visible}
.controls{display:flex;flex-wrap:wrap;gap:8px;align-items:end}
.controls .field{display:flex;flex-direction:column;gap:6px}
input,button{padding:8px 10px;border-radius:10px;border:1px solid var(--border);background:rgba(255,255,255,.06);color:var(--text)}
/* Picklists: always white with black text */
select{padding:8px 10px;border-radius:10px;border:1px solid rgba(0,0,0,.25);background:#ffffff;color:#000000}
select option{background:#ffffff;color:#000000}
select:disabled{background:#f2f2f2;color:#666;opacity:1}
/* legacy explicit quick preset styling kept for specificity (redundant but harmless) */
#quick{background:#ffffff;color:#000000;border-color:rgba(0,0,0,.25)}
button{cursor:pointer}
.grid{display:grid;grid-template-columns:2fr 1fr;gap:12px}
.table{width:100%;border-collapse:collapse}
.table th,.table td{padding:8px;border-bottom:1px solid rgba(255,255,255,.06);font-size:14px}
.table th{text-align:left;color:var(--muted);font-weight:600}
.badge{display:inline-block;padding:4px 8px;border-radius:999px;background:var(--chip);color:var(--text);font-size:12px}
.win{color:#7be495} .loss{color:#ff8b8b}
.logo{width:18px;height:18px;border-radius:50%;object-fit:cover;border:1px solid rgba(255,255,255,.1);margin-right:6px}
.heroes{display:flex;gap:8px;flex-wrap:wrap}
.hero{display:inline-flex;flex-direction:column;align-items:center;gap:4px;font-size:11px;width:64px}
.hero img{width:64px;height:36px;object-fit:cover;border-radius:8px;border:1px solid rgba(255,255,255,.08)}
/* Highlights UI */
.grid3{display:grid;grid-template-columns:repeat(3,1fr);gap:12px}
.grid2{display:grid;grid-template-columns:repeat(2,1fr);gap:12px}
ul.simple{list-style:none;margin:0;padding:0}
ul.simple li{display:flex;align-items:center;justify-content:space-between;gap:8px;padding:6px 0;border-bottom:1px solid rgba(255,255,255,.06)}
.sub{color:var(--muted);font-size:12px}
.title{font-weight:600;margin-bottom:6px}
.has-hover{position:relative}
.has-hover .hovercard{display:none;position:absolute;left:0;top:100%;margin-top:6px;z-index:10000;background:rgba(10,16,34,.96);border:1px solid var(--border);border-radius:10px;padding:8px;min-width:220px;box-shadow:0 8px 20px rgba(0,0,0,.4);pointer-events:auto}
.has-hover:hover .hovercard{display:block}
.has-hover.open .hovercard{display:block}
.ramp-badge{background:#23305f}
/* Ward map */
.wardgrid{display:grid;grid-template-columns:1.2fr .8fr;gap:12px;align-items:start}
@media (max-width: 980px){.wardgrid{grid-template-columns:1fr}}
.wardmap{margin:8px 0 0;position:relative;width:100%;aspect-ratio:1/1;background:url('https://www.opendota.com/assets/images/dota2map/dota2map_full.jpg') center/cover no-repeat;border:1px solid var(--border);border-radius:12px}
.wardmap svg .spot{ transition: opacity .15s ease, fill .15s ease, stroke .15s ease }
.wardmap svg .spot.hl:not(.longest){ fill: rgba(52,211,153,.14) !important; stroke:#34d399 !important; filter: drop-shadow(0 0 10px rgba(52,211,153,.7)); stroke-width:2.2 !important; opacity:1 !important }
.wardmap svg .spot.longest.hl{ fill: rgba(255,107,107,.12) !important; stroke:#ff6b6b !important; filter: drop-shadow(0 0 10px rgba(255,107,107,.75)); stroke-width:2.2 !important; opacity:1 !important }
.wardmap.highlighting svg .spot:not(.hl){ opacity:.25 !important }
.tabs{display:flex;gap:6px;margin:6px 0 8px}
.tab{padding:6px 10px;border:1px solid var(--border);background:linear-gradient(180deg,rgba(255,255,255,.07),rgba(255,255,255,.03));border-radius:10px;color:var(--text);cursor:pointer;font-size:12px}
.tab.active{outline:2px solid rgba(109,166,255,.5);background:linear-gradient(180deg,rgba(109,166,255,.2),rgba(109,166,255,.08));border-color:rgba(109,166,255,.45)}
.tabpane{margin-top:6px}
/* Summary cards */
.summary-grid{display:grid;grid-template-columns:repeat(3,1fr);gap:12px}
.summary-card{background:linear-gradient(180deg,rgba(255,255,255,.03),rgba(255,255,255,.02));border:1px solid var(--border);border-radius:12px;padding:10px}
.summary-card h3{margin:0 0 6px;font-size:15px;color:var(--muted)}
.summary-card ul{list-style:none;margin:0;padding:0}
.summary-card li{display:flex;align-items:center;gap:8px;justify-content:space-between;padding:6px 0;border-bottom:1px solid rgba(255,255,255,.06)}
.summary-card li:last-child{border-bottom:0}
.summary-card img{width:22px;height:22px;border-radius:6px;border:1px solid rgba(255,255,255,.1)}
/* Performance cards */
.perf-grid{display:grid;grid-template-columns:repeat(2,1fr);gap:10px}
@media (max-width: 720px){.perf-grid{grid-template-columns:1fr}}
.perf-card{display:flex;align-items:center;justify-content:space-between;padding:10px;border:1px solid var(--border);border-radius:12px;background:linear-gradient(180deg,rgba(255,255,255,.05),rgba(255,255,255,.025))}
.perf-left{display:flex;align-items:center;gap:10px}
.perf-icon{width:36px;height:36px;border-radius:10px;display:flex;align-items:center;justify-content:center;background:radial-gradient(22px 22px at 30% 30%, rgba(158,199,255,.45), rgba(158,199,255,.12));border:1px solid rgba(158,199,255,.25);font-size:16px}
.perf-meta{display:flex;flex-direction:column;line-height:1.15}
.perf-label{font-size:12px;color:var(--muted)}
.perf-player a{color:var(--text)}
.perf-value{font-weight:700;font-size:18px}
.perf-actions{display:flex;gap:6px;align-items:center}
/* Awards layout */
.aw-toolbar{display:flex;justify-content:flex-end;align-items:center;gap:10px;margin:-4px 0 8px}
.aw-tile{background:linear-gradient(180deg,rgba(255,255,255,.03),rgba(255,255,255,.02));border:1px solid var(--border);border-radius:12px;padding:10px;display:flex;flex-direction:column;height:100%}
.aw-tile h3{margin:0 0 6px;font-size:15px;color:var(--muted)}
.aw-tile ul.simple{flex:1}
/* Stacked badge lines */
.stack .row{display:block;margin-top:4px}
.stack .row .badge{margin-right:6px}
/* Calendar */
.cal{margin-top:8px}
.cal .toolbar{display:flex;align-items:center;justify-content:space-between;margin-bottom:8px}
.cal .grid7{display:grid;grid-template-columns:repeat(7,1fr);gap:6px}
.cal .dow div{color:var(--muted);font-size:12px;text-align:center}
.cal .day{min-height:90px;border:1px solid rgba(255,255,255,.08);border-radius:10px;padding:8px;background:linear-gradient(180deg,rgba(255,255,255,.03),rgba(255,255,255,.015))}
.cal .date{font-weight:600;color:var(--muted);font-size:12px;margin-bottom:4px}
.cal .matches{display:flex;flex-wrap:wrap;gap:4px}
.cal .matches a{display:inline-block;background:var(--chip);color:var(--text);border-radius:999px;font-size:11px;padding:2px 6px}
</style>
<script defer src="js/ward_viewer.js"></script>
</head>
<body>
<div class="wrapper">
  <div class="header">
    <h1 id="leagueTitle" style="margin:0;font-size:22px">Dynamic viewer</h1>
    <div class="badge">Client-side</div>
  </div>
  <div class="sub" id="headerSub" style="margin:-8px 0 8px 2px"></div>

  <section id="summarySection" class="card" style="display:none">
    <div class="summary-grid" id="summaryGrid">
      <!-- Filled by JS -->
    </div>
  </section>
  <div class="card controls">
    <div class="field">
      <label for="from">From (local)</label>
      <input type="datetime-local" id="from">
    </div>
    <div class="field">
      <label for="to">To (local)</label>
      <input type="datetime-local" id="to">
    </div>
    <div class="field">
      <label for="quick">Quick range</label>
      <select id="quick">
        <option value="">-- pick --</option>
        <option value="30">Last 30 days</option>
        <option value="60">Last 60 days</option>
        <option value="120">Last 120 days</option>
        <option value="patch">Last patch</option>
        <option value="all">All time</option>
      </select>
    </div>
    <div class="field">
      <label for="playerFilter">Player filter</label>
      <select id="playerFilter"><option value="">All players</option></select>
    </div>
    
    <div class="field">
      <label>&nbsp;</label>
      <div style="display:flex;gap:6px;flex-wrap:wrap">
  <button id="apply">Apply</button>
  <button id="genUserReport" title="Generate a temporary user report under docs/User-Reports">Generate user report</button>
  <span id="rangeMatchBadge" class="badge" title="Matches in selected period" style="align-self:center;display:none"></span>
      </div>
    </div>
  </div>

  <!-- Main tabs like in All-time report -->
  <div class="tabs" id="mainTabs" style="margin-top:12px">
    <button class="tab active" data-tab="highlights">Highlights</button>
  <button class="tab" data-tab="wards">Wards</button>
    <button class="tab" data-tab="players">Players</button>
    <button class="tab" data-tab="heroes">Heroes</button>
    <button class="tab" data-tab="teams">Teams</button>
  <button class="tab" data-tab="calendar">Calendar</button>
  <button class="tab" data-tab="awards">Awards</button>
  </div>

  <div id="pane-highlights" class="tabpane active">
    <div id="highlightsCard" class="card" style="margin-top:12px;display:none">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px">
        <h2 style="margin:0 0 0;font-size:18px">Highlights</h2>
  <div class="sub">Auto-switches with quick range (30/60/120 days, Patch, All)</div>
      </div>
      <div id="highlightsBody">
      </div>
    </div>
  </div>

  <div id="pane-wards" class="tabpane" style="display:none">
    <section class="card" style="margin-top:12px">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px">
        <h2 style="margin:0 0 0;font-size:18px">Wards</h2>
        <div class="sub">Best/Worst by time window and team filter</div>
      </div>
      <div id="dvWardMount"></div>
    </section>
  </div>

  <div id="pane-players" class="tabpane" style="display:none">
    <section class="card">
  <h2 style="margin:0 0 8px;font-size:18px">Players <span id="playerFocus" class="sub" style="margin-left:8px;display:none"></span></h2>
      <table class="table sortable" id="playersTable"><thead><tr>
        <th data-type="text">Name</th><th data-type="num">Games</th><th data-type="num">W-L</th><th data-type="num">WR</th><th data-type="num">Hero pool</th>
      </tr></thead><tbody></tbody></table>
    </section>
  </div>

  <div id="pane-heroes" class="tabpane" style="display:none">
    <section class="card">
      <h2 style="margin:0 0 8px;font-size:18px">Heroes</h2>
      <table class="table sortable" id="heroesTable"><thead><tr>
        <th data-type="text">Hero</th><th data-type="num">Picks</th><th data-type="num">Bans</th><th data-type="num">Wins</th><th data-type="num">WR</th><th data-type="text">Best player</th>
      </tr></thead><tbody></tbody></table>
    </section>
  </div>

  <div id="pane-teams" class="tabpane" style="display:none">
    <section class="card">
      <h2 style="margin:0 0 8px;font-size:18px">Teams</h2>
      <table class="table sortable" id="teamsTable"><thead><tr>
        <th data-type="text">Team</th><th data-type="num">Games</th><th data-type="num">W-L</th><th data-type="num">WR</th>
      </tr></thead><tbody></tbody></table>
    </section>
  </div>

  <div id="pane-awards" class="tabpane" style="display:none">
    <section class="card">
      <h2 style="margin:0 0 8px;font-size:18px">🏆 Awards</h2>
      <div class="aw-toolbar">
        <label class="sub" style="display:flex;align-items:center;gap:6px"><input type="checkbox" id="awHideEmpty"> Hide empty awards</label>
      </div>
      <div id="awardsBody" class="sub">Select a range and Apply to compute awards.</div>
    </section>
  </div>

  <div id="pane-calendar" class="tabpane" style="display:none">
    <section class="card">
      <div class="cal">
        <div class="toolbar">
          <button class="tab" id="calPrev">← Prev</button>
          <div class="title" id="calTitle">-</div>
          <button class="tab" id="calNext">Next →</button>
        </div>
  <div class="date" id="calMeta"></div>
        <div class="dow grid7">
          <div>Mon</div><div>Tue</div><div>Wed</div><div>Thu</div><div>Fri</div><div>Sat</div><div>Sun</div>
        </div>
        <div id="calGrid" class="grid7" style="margin-top:6px"></div>
      </div>
    </section>
  </div>
</div>

<script>
const OD_PLAYER_URL = id => `https://www.opendota.com/players/${id}`;
const OD_MATCH_URL = id => `https://www.opendota.com/matches/${id}`;
function fmtPct(x){ return (x*100).toFixed(1)+'%'; }
async function loadJson(url){
  try{
    const r = await fetch(url,{cache:'no-store'});
    if(!r.ok) return null;
    return await r.json();
  }catch(_e){
    return null;
  }
}
async function loadJsonWithFallback(rel, raw){
  const isFile = (typeof location !== 'undefined' && location.protocol === 'file:');
  if(isFile){
    // When opened via file://, browsers block fetch() to file paths. Prefer HTTP raw first.
    const a = await loadJson(raw); if(a!=null) return a;
    const b = await loadJson(rel); if(b!=null) return b;
    throw new Error('Failed to load resource via file:// fallbacks');
  } else {
    const a = await loadJson(rel); if(a!=null) return a;
    const b = await loadJson(raw); if(b!=null) return b;
    throw new Error('Failed to load resource via HTTP fallbacks');
  }
}
function unix(dt){ return Math.floor(dt.getTime()/1000); }
function toLocalInput(unixSec){ if(!unixSec) return ''; const d=new Date(unixSec*1000); const pad=n=>String(n).padStart(2,'0'); return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}T${pad(d.getHours())}:${pad(d.getMinutes())}`; }
function parseLocalInput(val){ if(!val) return NaN; const ms = Date.parse(val); return isNaN(ms)? NaN : Math.floor(ms/1000); }

// Sorting helpers
function val(td){
  const ds = td.dataset && td.dataset.sort !== undefined ? td.dataset.sort : null;
  if(ds!==null){ const n=parseFloat(String(ds).replace('%','').replace(',','.')); return isNaN(n)?String(ds).toLowerCase():n; }
  const t = td.textContent.trim().replace('%','').replace(',','.');
  const n = parseFloat(t);
  return isNaN(n) ? t.toLowerCase() : n;
}
function sortTable(table, col, type, asc){
  const tbody = table.tBodies[0]; if(!tbody) return;
  const rows = Array.from(tbody.rows);
  rows.sort((a,b)=>{
    let va=val(a.cells[col]), vb=val(b.cells[col]);
    if(type==='text'){ return asc ? String(va).localeCompare(String(vb)) : String(vb).localeCompare(String(va)); }
    va = parseFloat(va)||0; vb = parseFloat(vb)||0; return asc ? va - vb : vb - va;
  });
  rows.forEach(r=>tbody.appendChild(r));
  table.querySelectorAll('th').forEach(th=>th.classList.remove('sorted-asc','sorted-desc'));
  const th=table.querySelectorAll('th')[col]; if(th) th.classList.add(asc?'sorted-asc':'sorted-desc');
}
function enableSorting(){
  document.querySelectorAll('table.sortable').forEach(table=>{
    table.querySelectorAll('th').forEach((th,i)=>{
      th.style.cursor='pointer';
      th.addEventListener('click', ()=>{
        const type = th.dataset.type || 'text';
        const asc = !th.classList.contains('sorted-asc');
        sortTable(table,i,type,asc);
      });
    });
  });
}

function aggregate(matches, playerNames, teamNames){
  const teams=new Map(), players=new Map(), teamPlayers=new Map(), heroStats=new Map(), heroPlayerAgg=new Map();
  for(const m of matches){
    const radWin=!!m.radiant_win, radTeamId=m.radiant_team_id|0, dirTeamId=m.dire_team_id|0;
    const radName = teamNames[String(radTeamId)] || m.radiant_name || 'Radiant';
    const dirName = teamNames[String(dirTeamId)] || m.dire_name    || 'Dire';
    function ensureTeam(id,name){ if(!id) return; if(!teams.has(id)) teams.set(id,{team_id:id,name,games:0,wins:0,losses:0}); }
    ensureTeam(radTeamId,radName); ensureTeam(dirTeamId,dirName);
    if(radTeamId){ const t=teams.get(radTeamId); t.games++; if(radWin) t.wins++; else t.losses++; if(radName && radName!=='Radiant') t.name=radName; }
    if(dirTeamId){ const t=teams.get(dirTeamId); t.games++; if(radWin) t.losses++; else t.wins++; if(dirName && dirName!=='Dire') t.name=dirName; }

    if(Array.isArray(m.picks_bans)){
      for(const pb of m.picks_bans){ const hid=pb.hero_id|0; let hs=heroStats.get(hid); if(!hs){ hs={picks:0,wins:0,bans:0}; heroStats.set(hid,hs);} if(!pb.is_pick) hs.bans++; }
    }

    for(const p of m.players||[]){
      const id=Number(p.account_id||0); if(!(id>0)) continue;
      if(!players.has(id)){
        const nm = p.personaname || playerNames[String(id)] || `Player ${id}`;
        players.set(id,{account_id:id,name:nm,games:0,wins:0,roles:{},heroes:{},heroWins:{},profile:OD_PLAYER_URL(id)});
      }
      const ps=players.get(id); ps.games++;
      const won = p.is_radiant ? radWin : !radWin; if(won) ps.wins++;
      ps.roles['Unknown'] = (ps.roles['Unknown']||0)+1;
      const hid = p.hero_id|0; if(hid>0){
        const key = String(hid);
        ps.heroes[key] = (ps.heroes[key]||0)+1;
        ps.heroWins[key] = (ps.heroWins[key]||0) + (won?1:0);
        let hs=heroStats.get(hid); if(!hs){ hs={picks:0,wins:0,bans:0}; heroStats.set(hid,hs);} hs.picks++; if(won) hs.wins++;
        if(!heroPlayerAgg.has(hid)) heroPlayerAgg.set(hid,new Map());
        if(!heroPlayerAgg.get(hid).has(id)) heroPlayerAgg.get(hid).set(id,{account_id:id,name:ps.name,games:0,wins:0,profile:ps.profile});
        const hp=heroPlayerAgg.get(hid).get(id); hp.games++; if(won) hp.wins++;
      }
      const teamId = p.is_radiant ? radTeamId : dirTeamId; if(teamId){
        if(!teamPlayers.has(teamId)) teamPlayers.set(teamId,new Map());
        if(!teamPlayers.get(teamId).has(id)) teamPlayers.get(teamId).set(id,{account_id:id,name:ps.name,games:0,wins:0,profile:ps.profile});
        const tp=teamPlayers.get(teamId).get(id); tp.games++; if(won) tp.wins++;
      }
    }
  }
  return {teams,players,teamPlayers,heroStats,heroPlayerAgg};
}

let __focusAid = 0; // optional focus account_id from URL (?aid=123)
let __userOnlyAid = 0; // when >0, restrict everything to only this user's stats
function render({teams,players,teamPlayers,heroStats,heroPlayerAgg}, heroMap){
  // Players
  let plist = Array.from(players.values());
  if(__userOnlyAid>0){ plist = plist.filter(p=> Number(p.account_id)===__userOnlyAid); }
  // If focusing a player, move them to front
  if(__focusAid>0){
    const idx = plist.findIndex(p=> Number(p.account_id)===__focusAid);
    if(idx>0){ const [it] = plist.splice(idx,1); plist.unshift(it); }
  }
  const playerRows = plist.map(p=>{
    const wr = p.games>0 ? p.wins/p.games : 0;
    // Build hero breakdown list
    const poolSize = Object.keys(p.heroes||{}).length;
    const listId = `hp-${p.account_id}`;
    const heroData = Object.entries(p.heroes||{}).map(([hid,cnt])=>{
      const wins = Number(p.heroWins && p.heroWins[hid] || 0);
      const wrH = cnt>0 ? (wins/cnt) : 0;
      const meta = heroMap[String(hid)] || {name:`Hero ${hid}`,img:''};
      return {hid, cnt:Number(cnt), wins, wrH, meta};
    }).sort((a,b)=> b.cnt - a.cnt || b.wrH - a.wrH || a.meta.name.localeCompare(b.meta.name));
    const heroList = heroData.map(h=> `<div style='display:flex;align-items:center;gap:8px;justify-content:space-between;padding:3px 0;border-bottom:1px solid rgba(255,255,255,.06)'><span style='display:flex;align-items:center;gap:8px'><img src='${h.meta.img}' class='logo' alt='${h.meta.name}'><span>${h.meta.name}</span></span><span><span class='badge'>x${h.cnt}</span><span class='badge'>WR ${fmtPct(h.wrH)}</span></span></div>`).join('');
    const heroes = `<div class='has-hover' data-pop='${listId}' style='display:inline-block'>
      <button class='badge' data-action='toggle-pop' data-target='${listId}' title='Show per-hero breakdown'>Hero pool: <strong>${poolSize}</strong></button>
      <div id='${listId}' class='hovercard' style='min-width:320px'>
        <div class='title'>Per-hero breakdown</div>
        ${heroList || `<div class='sub'>no heroes</div>`}
      </div>
    </div>`;
  const hl = (__focusAid>0 && Number(p.account_id)===__focusAid) ? " style='outline:2px solid rgba(109,166,255,.6)'" : '';
  return `<tr${hl}>
      <td data-sort="${p.name.toLowerCase()}"><a href='${p.profile}' target='_blank' rel='noopener'>${p.name}</a></td>
      <td data-sort="${p.games}">${p.games}</td>
      <td data-sort="${p.wins/(p.games||1)}"><span class='win'>${p.wins}</span>-<span class='loss'>${p.games-p.wins}</span></td>
      <td data-sort="${wr}">${fmtPct(wr)}</td>
      <td data-sort="${poolSize}">${`<div class='heroes'>${heroes}</div>`}</td>
    </tr>`;
  }).join('');
  document.querySelector('#playersTable tbody').innerHTML = playerRows;
  // Wire up click-to-toggle for hero pool popovers
  try{
    document.querySelectorAll('[data-action="toggle-pop"]').forEach(btn=>{
      btn.addEventListener('click', (e)=>{
        e.preventDefault(); e.stopPropagation();
        const id = btn.getAttribute('data-target');
        const wrapper = btn.closest('.has-hover');
        if(!id||!wrapper) return;
        // Close others
        document.querySelectorAll('.has-hover.open').forEach(n=>{ if(n!==wrapper) n.classList.remove('open'); });
        wrapper.classList.toggle('open');
      });
    });
    // Close when clicking elsewhere
    document.addEventListener('click', (e)=>{
      document.querySelectorAll('.has-hover.open').forEach(n=>{
        if(!n.contains(e.target)) n.classList.remove('open');
      });
    });
  }catch(_e){}

  // Teams
  const teamRows = Array.from(teams.values()).map(t=>{
    const wr = t.games>0 ? t.wins/t.games : 0;
    const nm = t.name || `Team ${t.team_id}`;
    return `<tr>
      <td data-sort="${nm.toLowerCase()}">${nm}</td>
      <td data-sort="${t.games}">${t.games}</td>
      <td data-sort="${t.wins/(t.games||1)}"><span class='win'>${t.wins}</span>-<span class='loss'>${t.losses}</span></td>
      <td data-sort="${wr}">${fmtPct(wr)}</td>
    </tr>`;
  }).join('');
  document.querySelector('#teamsTable tbody').innerHTML = teamRows;

  // Heroes
  const heroRows = (function(){
    if(__userOnlyAid>0){
      const p = Array.from(players.values()).find(x=> Number(x.account_id)===__userOnlyAid);
      if(!p){ return ''; }
      const rows = Object.keys(p.heroes||{}).map(hid=>{
        const cnt = Number(p.heroes[hid]||0);
        const wins = Number(p.heroWins && p.heroWins[hid] || 0);
        const meta = heroMap[String(hid)] || {name:`Hero ${hid}`,img:''};
        const wr = cnt>0 ? (wins/cnt) : 0;
        const bestLabel = `<a href='${p.profile}' target='_blank'>${p.name}</a> - ${fmtPct(wr)} (${wins}/${cnt})`;
        return `<tr>
          <td data-sort="${meta.name.toLowerCase()}"><div style='display:flex;align-items:center;gap:8px'><img src='${meta.img}' alt='${meta.name}' style='width:28px;height:28px;border-radius:6px;border:1px solid rgba(255,255,255,.1)'><span>${meta.name}</span></div></td>
          <td data-sort="${cnt}">${cnt}</td>
          <td data-sort="0">0</td>
          <td data-sort="${wins}">${wins}</td>
          <td data-sort="${wr}">${fmtPct(wr)}</td>
          <td data-sort="${wr}">${bestLabel}</td>
        </tr>`;
      }).sort().join('');
      return rows;
    }
    return Array.from(heroStats.keys()).map(hid=>{
      const hs=heroStats.get(hid), picks=hs.picks|0, wins=hs.wins|0, bans=hs.bans|0, wr = picks>0 ? wins/picks : 0;
      const meta = heroMap[String(hid)] || {name:`Hero ${hid}`,img:''};
      // best player
      let bestLabel='<span class="badge">no data</span>', bestWr=0; const hpa=heroPlayerAgg.get(hid);
      if(hpa){ const arr=Array.from(hpa.values()).filter(x=>x.games>0).map(x=>({...x,wr:x.wins/x.games})).sort((a,b)=> b.wr - a.wr || b.games - a.games || b.wins - a.wins );
        if(arr.length){ const b=arr[0]; bestLabel = `<a href='${b.profile}' target='_blank'>${b.name}</a> - ${fmtPct(b.wr)} (${b.wins}/${b.games})`; bestWr=b.wr; }
      }
      return `<tr>
  <td data-sort="${meta.name.toLowerCase()}"><div style='display:flex;align-items:center;gap:8px'><img src='${meta.img}' alt='${meta.name}' style='width:28px;height:28px;border-radius:6px;border:1px solid rgba(255,255,255,.1)'><span>${meta.name}</span></div></td>
        <td data-sort="${picks}">${picks}</td>
        <td data-sort="${bans}">${bans}</td>
        <td data-sort="${wins}">${wins}</td>
        <td data-sort="${wr}">${fmtPct(wr)}</td>
        <td data-sort="${bestWr}">${bestLabel}</td>
      </tr>`;
    }).join('');
  })();
  document.querySelector('#heroesTable tbody').innerHTML = heroRows;

  // Initial default sorts (desc): Players by WR, Teams by WR, Heroes by Picks
  if(!window.__dvSortedOnce){
    const pt = document.getElementById('playersTable');
    const tt = document.getElementById('teamsTable');
    const ht = document.getElementById('heroesTable');
  // When focusing a player, don’t auto-sort players (keep focused first)
  if(!(__focusAid>0)) sortTable(pt, 3, 'num', false);
    sortTable(tt, 3, 'num', false);
    sortTable(ht, 1, 'num', false);
    window.__dvSortedOnce = true;
  }
}

function renderSummary(subsetAgg, heroMap){
  const sec = document.getElementById('summarySection');
  const grid = document.getElementById('summaryGrid');
  if(!subsetAgg){ sec.style.display='none'; grid.innerHTML=''; return; }
  // Build structures
  const playersArr = Array.from(subsetAgg.players.values());
  const heroesArr = Array.from(subsetAgg.heroStats.entries()).map(([hid,hs])=>({hid, ...hs}));
  // thresholds
  const minGamesTopPlayer = 5;
  // Top 3 most picked heroes
  const topPicked = heroesArr.filter(h=>h.picks>0).sort((a,b)=> b.picks - a.picks).slice(0,3).map(h=>{
    const meta = heroMap[String(h.hid)]||{}; return {name:meta.name||`#${h.hid}`, img:meta.img||'', picks:h.picks, winrate: h.picks? (h.wins/h.picks):0};
  });
  // Top 3 most banned heroes
  const topBanned = heroesArr.filter(h=>h.bans>0).sort((a,b)=> b.bans - a.bans).slice(0,3).map(h=>{
    const meta = heroMap[String(h.hid)]||{}; return {name:meta.name||`#${h.hid}`, img:meta.img||'', bans:h.bans, picks:h.picks||0};
  });
  // Top 3 players by WR with threshold
  const topPlayers = playersArr.map(p=>({name:p.name, profile:p.profile, games:p.games, wins:p.wins, wr: p.games? (p.wins/p.games):0}))
    .filter(p=>p.games>=minGamesTopPlayer).sort((a,b)=> b.wr - a.wr || b.games - a.games).slice(0,3);
  // Top 3 most played inhouses (most games)
  const topPlayed = playersArr.slice().sort((a,b)=> b.games - a.games || (b.wins/b.games) - (a.wins/a.games)).slice(0,3).map(p=>({name:p.name, profile:p.profile, games:p.games, wr: p.games? (p.wins/p.games):0}));
  // Highest/Lowest WR hero (min 5 games like All-time)
  const minHeroGames = 5;
  const heroPool = heroesArr.filter(h=>h.picks>=minHeroGames).map(h=>({
    hid:h.hid, picks:h.picks, wins:h.wins, wr: h.picks? (h.wins/h.picks):0,
    meta: heroMap[String(h.hid)]||{}
  }));
  const bestHero = heroPool.slice().sort((a,b)=> b.wr - a.wr || b.picks - a.picks)[0] || null;
  const worstHero = heroPool.slice().sort((a,b)=> a.wr - b.wr || b.picks - a.picks)[0] || null;

  function liPicked(h){ return `<li><span style='display:flex;align-items:center;gap:8px'><img src='${h.img}' alt='${h.name}'><span class='name'>${h.name}</span></span><span><span class='badge'>Picks: ${h.picks}</span><span class='badge'>WR: <strong>${fmtPct(h.winrate)}</strong></span></span></li>`; }
  function liBanned(h){ return `<li><span style='display:flex;align-items:center;gap:8px'><img src='${h.img}' alt='${h.name}'><span class='name'>${h.name}</span></span><span><span class='badge'>Bans: ${h.bans}</span><span class='badge'>Picks: ${h.picks}</span></span></li>`; }
  function liTopPlayer(p){ return `<li><span class='name'><a href='${p.profile}' target='_blank'>${p.name}</a></span><span><span class='badge'>${p.games} games</span><span class='badge'>WR: <strong>${fmtPct(p.wr)}</strong></span></span></li>`; }
  function liMostPlayed(p){ return `<li><span class='name'><a href='${p.profile}' target='_blank'>${p.name}</a></span><span><span class='badge'>${p.games} games</span><span class='badge'>WR: <strong>${fmtPct(p.wr)}</strong></span></span></li>`; }
  function heroRow(h){ return h? `<li><span style='display:flex;align-items:center;gap:8px'><img src='${h.meta.img||''}' alt='${h.meta.name||('#'+h.hid)}'><span class='name'>${h.meta.name||('#'+h.hid)}</span></span><span><span class='badge'>Picks: ${h.picks}</span><span class='badge'>WR: <strong>${fmtPct(h.wr)}</strong></span></span></li>` : `<li><span class='sub'>no data</span></li>`; }

  grid.innerHTML = `
    <div class='summary-card' id='sum-top-picked'>
      <h3>Top 3 most picked heroes</h3>
      <ul id='ul-top-picked'>${topPicked.map(liPicked).join('') || `<li><span class='sub'>no data</span></li>`}</ul>
    </div>
    <div class='summary-card' id='sum-top-banned'>
      <h3>Top 3 most banned heroes</h3>
      <ul id='ul-top-banned'>${topBanned.map(liBanned).join('') || `<li><span class='sub'>no data</span></li>`}</ul>
    </div>
    <div class='summary-card'>
      <h3>Top 3 players (WR, > ${minGamesTopPlayer} games)</h3>
      <ul>${topPlayers.map(liTopPlayer).join('') || `<li><span class='sub'>no data</span></li>`}</ul>
    </div>
    <div class='summary-card'>
      <h3>Top 3 most played inhouses</h3>
      <ul>${topPlayed.map(liMostPlayed).join('') || `<li><span class='sub'>no data</span></li>`}</ul>
    </div>
    <div class='summary-card'>
      <h3>Highest win rate hero (min ${minHeroGames} games)</h3>
      <ul>${heroRow(bestHero)}</ul>
    </div>
    <div class='summary-card'>
      <h3>Lowest win rate hero (min ${minHeroGames} games)</h3>
      <ul>${heroRow(worstHero)}</ul>
    </div>
  `;
  sec.style.display='';
}

function renderHighlights(high, heroMap, mapConf, label){
  const card = document.getElementById('highlightsCard');
  const body = document.getElementById('highlightsBody');
  if(!high || typeof high !== 'object'){ card.style.display='none'; body.innerHTML=''; return; }
  function esc(s){ return String(s||'').replace(/[&<>"']/g, c=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"}[c])); }
  function linkPlayer(obj){
    if(!obj) return '<span class="sub">Unknown</span>';
    // Allow passing a numeric account_id directly
    if(typeof obj === 'number'){
      const id = Number(obj)||0;
      const name = id ? `Player ${id}` : 'Unknown';
      const profile = id ? OD_PLAYER_URL(id) : '#';
      return `<a href='${esc(profile)}' target='_blank' rel='noopener'>${esc(name)}</a>`;
    }
    const id = obj.account_id || obj.id || obj.accountId || 0;
    const name = esc(obj.name || obj.personaname || (id?`Player ${id}`:'Unknown'));
    const profile = esc(obj.profile || (id? OD_PLAYER_URL(id) : '#'));
    return `<a href='${profile}' target='_blank' rel='noopener'>${name}</a>`;
  }
  // Rampages grouped by side, with clickable count to toggle matches
  function rampListHtml(arr){
    if(!Array.isArray(arr) || !arr.length) return '<li><span class="sub">no games</span></li>';
    return arr.map((r,idx)=>{
      const name = esc(r.name||'Player'); const profile = esc(r.profile||'#');
      const cnt = Number(r.count||0);
      const rid = `rp-${Math.random().toString(36).slice(2)}-${idx}`;
      const matches = Array.isArray(r.matches) && r.matches.length ? r.matches.map(m=>{
        const mid = String(m.match_id||m.matchId||''); const c = Number(m.count||1);
        const label = c>1 ? `x${c}` : 'match';
        return `<a class='badge' target='_blank' href='${OD_MATCH_URL(mid)}'>M${mid}</a><span class='badge'>${label}</span>`;
      }).join(' ') : '<div class="sub">no links</div>';
      return `<li><span><a href='${profile}' target='_blank'>${name}</a></span><button class='badge ramp-badge' data-toggle='${rid}' title='Show matches'>x${cnt}</button><div id='${rid}' class='stack' style='display:none;margin-top:6px'>${matches}</div></li>`;
    }).join('');
  }
  function rampSection(){
    const rs = high.rampagesBySide || {Radiant:[], Dire:[]};
    const rHtml = rampListHtml(rs.Radiant);
    const dHtml = rampListHtml(rs.Dire);
    return `<div class='grid2'>
      <div><h4>Radiant</h4><ul class='simple'>${rHtml}</ul></div>
      <div><h4>Dire</h4><ul class='simple'>${dHtml}</ul></div>
    </div>`;
  }
  // New blocks: teammates, courier kills, camps stacked
  function teammatesList(arr){
    if(!Array.isArray(arr) || !arr.length) return `<li><span class="sub">no data</span></li>`;
    return arr.map(it=>{
      // Try to normalize pair structure (supports name1/profile1 & name2/profile2 from server)
  const a = (Array.isArray(it.pair)? it.pair[0] : null) ||
  (it.p1_id? {account_id: it.p1_id, name: it.p1_name, profile: it.p1_profile} : null) ||
  (it.name1 || it.profile1 ? {name: it.name1, profile: it.profile1} : null);
  const b = (it.b!=null) ? { account_id: Number(it.b)||0, name: it.name2, profile: it.profile2 } :
        (Array.isArray(it.pair)? it.pair[1] : null) ||
        (it.p2_id? {account_id: it.p2_id, name: it.p2_name, profile: it.p2_profile} : null) ||
        (it.name2 || it.profile2 ? {name: it.name2, profile: it.profile2} : null);
      const cnt = Number(it.count ?? it.games ?? it.value ?? 0);
      return `<li><span>${linkPlayer(a)} + ${linkPlayer(b)}</span><span class='badge'>x${cnt}</span></li>`;
    }).join('');
  }
  function simpleCountList(arr, unit){
    if(!Array.isArray(arr) || !arr.length) return `<li><span class="sub">no data</span></li>`;
    return arr.map(it=>{
      const cnt = Number(it.count ?? it.total ?? it.value ?? it.kills ?? it.stacks ?? 0);
      const player = it.player || it;
      return `<li><span>${linkPlayer(player)}</span><span class='badge'>x${cnt} ${unit}</span></li>`;
    }).join('');
  }
  // Roshan
  const rosR = high.roshan && typeof high.roshan.Radiant==='number' ? high.roshan.Radiant : 0;
  const rosD = high.roshan && typeof high.roshan.Dire==='number' ? high.roshan.Dire : 0;
  const objWarn = high.objectivesSeen===false ? `<div class='sub'>no objective data in parsed matches</div>` : '';
  const objNone = (rosR+rosD)===0 ? `<div class='sub'>no Roshan events in this period</div>` : '';
  function rosTop(side){
    const arr = high.roshanTop && Array.isArray(high.roshanTop[side]) ? high.roshanTop[side] : [];
    if(!arr.length) return '';
    const rows = arr.map(x=>{
      const mid = String(x.match_id||''); const c = Number(x.count||1);
      return `<div class='row'><a class='badge' target='_blank' href='${OD_MATCH_URL(mid)}'>M${mid}</a><span class='badge'>x${c}</span></div>`;
    }).join('');
    return `<div class='stack'>${rows}</div>`;
  }
  // Aegis snatch and Tormentor
  function objectiveList(arr, label){
    if(!Array.isArray(arr) || !arr.length) return '';
    const heading = label ? `<div class='sub' style='margin-top:6px'>${label}</div>` : '';
  const singular = label ? (label.endsWith('es') ? label.slice(0,-2) : label.endsWith('s') ? label.slice(0,-1) : label) : null;
    return heading + `<ul class='simple'>` + arr.map(ev=>{
      const hasTime = ev.time!==undefined && ev.time!==null && isFinite(Number(ev.time));
      const sec = hasTime ? Number(ev.time) : NaN; const mm = hasTime ? Math.floor(sec/60) : null; const ss = hasTime ? (sec%60) : null;
      const mid = String(ev.match_id||'');
      const team = esc(ev.team||'');
      const p = ev.player || null;
      const name = p ? esc(p.name||'Unknown') : 'Unknown';
      const profile = p && p.profile ? esc(p.profile) : null;
      const hero = p && p.hero ? ` (${esc(p.hero)})` : '';
      const person = profile ? `<a href='${profile}' target='_blank'>${name}</a>` : name;
      const cnt = Number(ev.count||0);
      const countBadge = cnt>1 ? `<span class='badge'>x${cnt}</span>` : '';
      const timeBadge = hasTime ? `<a class='badge' target='_blank' href='${OD_MATCH_URL(mid)}'>${mm}m ${ss}s</a>` : `<a class='badge' target='_blank' href='${OD_MATCH_URL(mid)}'>n/a</a>`;
      const prefix = singular ? `<span>${singular}:</span>` : '';
      return `<li>${prefix}<span class='badge'>${team}</span><span>${person}${hero}</span>${countBadge}${timeBadge}</li>`;
    }).join('') + '</ul>';
  }
  // Roshan kills grouped by side
  function roshKillsBySide(events){
    const arr = Array.isArray(events)? events:[];
    if(!arr.length) return '';
    const rad = arr.filter(ev=> String(ev.team||'')==='Radiant');
    const dire = arr.filter(ev=> String(ev.team||'')==='Dire');
    function listSide(sideArr){
      if(!sideArr.length) return `<ul class='simple'><li><span class='sub'>no kills</span></li></ul>`;
      const items = sideArr.map(ev=>{
        const sec = Number(ev.time||0); const mm=Math.floor(sec/60), ss=sec%60;
        const mid = String(ev.match_id||'');
        const p = ev.player || null;
        const name = p ? esc(p.name||'Unknown') : 'Unknown';
        const profile = p && p.profile ? esc(p.profile) : null;
        const hero = p && p.hero ? ` (${esc(p.hero)})` : '';
        const person = profile ? `<a href='${profile}' target='_blank'>${name}</a>` : name;
        return `<li><span>Roshan</span><span>${person}${hero}</span><a class='badge' target='_blank' href='${OD_MATCH_URL(mid)}'>${mm}m ${ss}s</a></li>`;
      }).join('');
      return `<ul class='simple'>${items}</ul>`;
    }
    return `<div class='sub' style='margin-top:6px'>Roshan kills</div>
      <div class='grid2'>
        <div><h4>Radiant</h4>${listSide(rad)}</div>
        <div><h4>Dire</h4>${listSide(dire)}</div>
      </div>`;
  }
  // Top single-match performances
  const ts = high.topSingle||{};
  const topPerfHtml = (()=>{
    const order = ['gpm','kills','assists','networth'];
    const icon = (k)=> k==='gpm'?'💰':k==='kills'?'⚔️':k==='assists'?'🤝':'💎';
    const label = (k)=> k==='gpm'?'Highest GPM':k==='kills'?'Highest Kills':k==='assists'?'Highest Assists':'Highest Net Worth';
    const cards = order.map(k=>{
      const p = ts[k]; if(!p) return '';
      const name=esc(p.name||'Player'); const profile=esc(p.profile||'#'); const val = esc(p.value); const mid = esc(p.match_id||'');
      return `<div class='perf-card'>
        <div class='perf-left'>
          <div class='perf-icon'>${icon(k)}</div>
          <div class='perf-meta'>
            <div class='perf-label'>${label(k)}</div>
            <div class='perf-player'><a href='${profile}' target='_blank' rel='noopener'>${name}</a></div>
          </div>
        </div>
        <div class='perf-actions'>
          <div class='perf-value'>${val}</div>
          <a class='badge' target='_blank' rel='noopener' href='${OD_MATCH_URL(mid)}'>Match</a>
        </div>
      </div>`;
    }).filter(Boolean);
    if(!cards.length) return `<div class='sub'>no games</div>`;
    return `<div class='perf-grid'>${cards.join('')}</div>`;
  })();
  // Durations
  function durList(arr){
    if(!Array.isArray(arr) || !arr.length) return `<li><span class='sub'>no games</span></li>`;
    return arr.map(x=>{
      const sec = Number(x.duration||0); const mm=Math.floor(sec/60), ss=sec%60;
      const vs = esc(`${x.radiant||'Radiant'} vs ${x.dire||'Dire'}`);
      const win = x.radiant_win ? 'Radiant' : 'Dire';
      const mid = esc(x.match_id||'');
      return `<li><span><a target='_blank' href='${OD_MATCH_URL(mid)}'>${vs}</a></span><span class='badge'>${mm}m ${ss}s</span><span class='badge'>Winner: ${win}</span></li>`;
    }).join('');
  }
  // Duos
  function duoList(arr){
    if(!Array.isArray(arr) || !arr.length) return `<li><span class='sub'>no games</span></li>`;
    return arr.map(d=>{
      const a = heroMap[String(d.a)] || {}; const b = heroMap[String(d.b)] || {};
      const aN = esc(a.name||(`#${d.a}`)); const bN = esc(b.name||(`#${d.b}`));
      const wr = Number(d.winrate||0);
      return `<li><span>${aN} + ${bN}</span><span class='badge'>WR: <strong>${fmtPct(wr)}</strong></span><span class='badge'>G: ${d.games||0}</span></li>`;
    }).join('');
  }
  // Ward map rendering handled by shared WardViewer module
  const roshByMatchHtml = (function(){
    const list = (high.roshanByMatch||[]).slice(0,5);
    if(!list.length) return '';
    const items = list.map(function(x){
      const mid=String(x.match_id||'');
      return `<li><a class='badge' target='_blank' href='${OD_MATCH_URL(mid)}'>M${mid}</a><span class='badge'>Radiant x${x.Radiant||0}</span><span class='badge'>Dire x${x.Dire||0}</span><span class='badge'>Total: ${x.total||0}</span></li>`;
    }).join('');
    return `<div class='sub' style='margin-top:6px'>Roshan kills by match</div><ul class='simple'>${items}</ul>`;
  })();
  const torByMatchHtml = (function(){
    const list = (high.tormentorByMatch||[]).slice(0,5);
    if(!list.length) return '';
    const items = list.map(function(x){
      const mid=String(x.match_id||'');
      return `<li><a class='badge' target='_blank' href='${OD_MATCH_URL(mid)}'>M${mid}</a><span class='badge'>Radiant x${x.Radiant||0}</span><span class='badge'>Dire x${x.Dire||0}</span><span class='badge'>Total: ${x.total||0}</span></li>`;
    }).join('');
    return `<div class='sub' style='margin-top:6px'>Tormentor kills by match</div><ul class='simple'>${items}</ul>`;
  })();
  const html = `
    <div class="grid2">
      <div>
        <h3>Rampages</h3>
        ${rampSection()}
      </div>
      <div>
        <h3>Top single-match performances</h3>
        ${topPerfHtml}
      </div>
    </div>
    <div class="grid3" style="margin-top:8px">
      <div>
        <h3>Roshan taken</h3>
        ${roshByMatchHtml}
      </div>
      <div>
        <h3>Tormentor</h3>
        ${torByMatchHtml}
      </div>
      <div>
        <h3>Aegis snatches</h3>
        ${objectiveList(high.aegisSnatch||[], '')}
      </div>
    </div>
    <div class="grid3" style="margin-top:8px">
      <div>
        <h3>Most common teammates</h3>
        <ul class="simple">${teammatesList(high.teammates)}</ul>
      </div>
      <div>
        <h3>Most courier kills</h3>
        <ul class="simple">${simpleCountList(high.courierTop, 'couriers')}</ul>
      </div>
      <div>
        <h3>Most camps stacked</h3>
        <ul class="simple">${simpleCountList(high.stackTop, 'stacks')}</ul>
      </div>
    </div>
    <div class="grid3" style="margin-top:8px">
      <div>
        <h3>Rapiers bought</h3>
        <ul class="simple">${simpleCountList(high.rapierTop, 'rapiers')}</ul>
      </div>
      <div>
        <h3>Gems bought</h3>
        <ul class="simple">${simpleCountList(high.gemTop, 'gems')}</ul>
      </div>
      <div></div>
    </div>
    <div class="grid2" style="margin-top:8px">
      <div>
        <h3>Best Safe Lane Duos</h3>
        <ul class="simple">${duoList(high.safeDuos||[])}</ul>
      </div>
      <div>
        <h3>Best Off Lane Duos</h3>
        <ul class="simple">${duoList(high.offDuos||[])}</ul>
      </div>
    </div>
    <div class="grid2" style="margin-top:8px">
      <div>
        <h3>3 longest matches</h3>
        <ul class="simple">${durList(high.durationLongest)}</ul>
      </div>
      <div>
        <h3>3 shortest matches</h3>
        <ul class="simple">${durList(high.durationShortest)}</ul>
      </div>
  </div>
  `;
  body.innerHTML = html; card.style.display='';
  // Attach rampage click-to-toggle handlers
  try{
    body.querySelectorAll('button[data-toggle]').forEach(btn=>{
      btn.addEventListener('click', ()=>{
        const id = btn.getAttribute('data-toggle');
        const tgt = id && body.querySelector(`#${CSS.escape(id)}`);
        if(tgt){ tgt.style.display = (tgt.style.display==='none' || !tgt.style.display) ? 'block' : 'none'; }
      });
    });
  }catch(_e){}
  // Ward interactivity handled by WardViewer
}

// Old attachWardUI removed; WardViewer handles interactivity

async function main(){
  // Top-level tabs wiring
  (function(){
    const tabsRoot = document.getElementById('mainTabs');
    if (!tabsRoot) return;
    const tabs = Array.from(tabsRoot.querySelectorAll('.tab'));
    function showTab(name){
  ['highlights','wards','players','heroes','teams','awards','calendar'].forEach(id=>{
        const pane = document.getElementById('pane-'+id);
        if (pane) pane.style.display = (id===name)? '' : 'none';
      });
      tabs.forEach(b=> b.classList.toggle('active', b.getAttribute('data-tab')===name));
      // Reflect selected tab in URL and localStorage
      try{
        const sp = new URLSearchParams(location.search);
        if(name && name !== 'highlights') sp.set('tab', name); else sp.delete('tab');
        const url = location.pathname + (sp.toString()? ('?'+sp.toString()):'') + location.hash;
        history.replaceState(null, '', url);
      }catch(_e){}
      try{ localStorage.setItem('dv_tab', name||'highlights'); }catch(_e){}
    }
    tabs.forEach(b=> b.addEventListener('click', ()=> showTab(b.getAttribute('data-tab'))));
    // Expose for initial selection via URL
    window.__dvShowTab = showTab;
  })();
  // Load from root-level data/ via relative path (local) or raw.githubusercontent.com (GitHub Pages)
  const REPO='Zeroks77/Kret_Dota'; const BRANCH='main';
  const relBase='../data'; const rawBase=`https://raw.githubusercontent.com/${REPO}/${BRANCH}/data`;
  const [manifest, heroesRaw, info, mapConf] = await Promise.all([
    loadJsonWithFallback(`${relBase}/manifest.json`, `${rawBase}/manifest.json`),
    loadJsonWithFallback(`${relBase}/heroes.json`, `${rawBase}/heroes.json`),
    loadJsonWithFallback(`${relBase}/info.json`, `${rawBase}/info.json`).catch(()=>({})),
    loadJsonWithFallback(`${relBase}/maps.json`, `${rawBase}/maps.json`).catch(()=>null)
  ]);
  // Preload OpenDota item constants for cost filtering (used by Fast First Purchase >1k)
  try{
    const items = await fetch('https://api.opendota.com/api/constants/items', { cache: 'force-cache' }).then(r=>r.json());
    if(items && typeof items==='object') window.__opendotaItems = items;
  }catch(_e){ /* proceed without; cost-based awards will skip if unavailable */ }
  // Allow wrapper to override map patch via URL (?map=7.39 or ?patch=7.39 or ?mpatch=7_39)
  try{
    const sp = new URLSearchParams(location.search);
    const pMap = sp.get('map') || sp.get('patch') || sp.get('mpatch');
    if(mapConf && pMap){
      // Normalize: accept 7.39 or 7_39
      const key = String(pMap).replace('_','.');
      if(mapConf.major && mapConf.major[key]){ mapConf.current = key; }
    }
  }catch(_e){}
  // Fetch all month shards listed in manifest
  const months = (manifest && Array.isArray(manifest.months)) ? manifest.months : [];
  const files = months.map(m => ({rel: `${relBase}/${m.file}`, raw: `${rawBase}/${m.file}`}));
  const shards = await Promise.all(files.map(p => loadJsonWithFallback(p.rel, p.raw).catch(()=>[])));
  let allMatches = shards.flat();
  // Build hero map with absolute images and friendly names
  const heroes = (function buildHeroMap(src){
    const out = {};
    if(src && typeof src === 'object'){
      const cdn = 'https://cdn.cloudflare.steamstatic.com';
      for(const k in src){
        const h = src[k]||{};
        const id = String(h.id||k);
        const tag = String(h.name||'').replace(/^npc_dota_hero_/,'');
        const loc = h.localized_name || tag || ('#'+id);
        let img = String(h.img||'');
        if(img && img.startsWith('/')) img = cdn + img;
        const icon = h.icon ? (h.icon.startsWith('/')? (cdn + h.icon) : h.icon) : img;
        out[id] = { id:Number(id), name:loc, img, icon, tag };
      }
    }
    return out;
  })(heroesRaw);
  // Names aren’t shipped separately in shards; derive names from matches where available
  const playerNames = {}; const teamNames = {};
  for(const m of allMatches){
    if(Array.isArray(m.players)){
      for(const p of m.players){ if(p && p.account_id>0 && p.personaname){ playerNames[String(p.account_id)] = p.personaname; } }
    }
    if(m.radiant_team_id && m.radiant_name) teamNames[String(m.radiant_team_id)] = m.radiant_name;
    if(m.dire_team_id && m.dire_name)       teamNames[String(m.dire_team_id)]    = m.dire_name;
  }
  // Populate player filter dropdown
  try{
    const sel = document.getElementById('playerFilter');
    if(sel){
      const list = Object.entries(playerNames).map(([id,name])=>({id:Number(id), name: String(name||(`Player ${id}`))})).filter(x=>x.id>0);
      list.sort((a,b)=> a.name.localeCompare(b.name));
      const opts = ["<option value=''>All players</option>"];
      for(const it of list){ opts.push(`<option value='${it.id}'>${it.name}</option>`); }
      sel.innerHTML = opts.join('');
    }
  }catch(_e){}

  // chatwheel/voiceline features removed

  const from = document.getElementById('from'), to = document.getElementById('to'), quick = document.getElementById('quick');
  // Keep last subset for calendar/nav
  let __subsetCache = [];
  let __rangeUnix = {from:0,to:0};
  let __calCursor = null; // {y,m}
  let __partialCount = 0; // number of matches loaded via partial/skeleton
  // ---- Helpers to compute highlights client-side for any range ----
  function mapHeroTag(heroMap){ const out={}; try{ for(const k in heroMap){ const v=heroMap[k]; if(v && v.tag){ out[String(v.tag)] = Number(v.id||k); } } }catch(_e){} return out; }
  function getTeamByObjective(ev, md){
    // Prefer explicit team on event; fallback to player_slot if present
  try{
      if(ev.team!==undefined && ev.team!==null){ const t=Number(ev.team); return (t===2||t===0)?'Radiant':'Dire'; }
  }catch(_e){}
  try{
      const slot = Number(ev.player_slot);
      if(!isNaN(slot)){ return (slot<128)?'Radiant':'Dire'; }
  }catch(_e){}
    // Fallback unknown
    return '';
  }
  async function fetchMatchDetail(id){
    const rel = `${relBase}/cache/OpenDota/matches/${id}.json`;
    const raw = `${rawBase}/cache/OpenDota/matches/${id}.json`;
    const isFile = (typeof location !== 'undefined' && location.protocol === 'file:');
    const tryLoad = async (url)=>{ const v = await loadJson(url); return v||null; };
    let md = null;
    // Try cached paths first (skip rel on file://)
    if(!isFile){ md = await tryLoad(rel); }
    if(!md){ md = await tryLoad(raw); }
    // Assess completeness to decide whether to attempt API enrichment (not rejection)
    const isPartial = (obj)=>{
      if(!obj) return true;
      const hasPlayers = Array.isArray(obj.players) && obj.players.length>0;
      const hasObjectives = Array.isArray(obj.objectives);
      let hasSomeLogs = false; // kills_log/deaths_log present for at least one player
      let hasLifeState = false; // life_state present for at least one player
      if(hasPlayers){
        for(const p of obj.players){
          if(!hasSomeLogs && p && (Array.isArray(p.kills_log) || Array.isArray(p.deaths_log))) { hasSomeLogs = true; }
          if(!hasLifeState && p && p.life_state && (p.life_state['1']!==undefined || p.life_state['2']!==undefined)) { hasLifeState = true; }
          if(hasSomeLogs && hasLifeState) break;
        }
      }
      // Treat as partial if core arrays are missing OR if life_state is missing across players (needed for some awards)
      return !(hasPlayers) || (!hasObjectives && !hasSomeLogs) || !hasLifeState;
    };
    // Helper: pick the more complete array between two
    const pickArray = (a, b)=>{
      const la = Array.isArray(a)? a.length:0; const lb = Array.isArray(b)? b.length:0; return lb>la ? (Array.isArray(b)? b:null) : (Array.isArray(a)? a:null);
    };
    // Helper: merge two match detail objects, preferring fields that are present/non-empty
    const mergeDetails = (base, extra)=>{
      if(!base) return extra||null; if(!extra) return base||null; const out = {...base, ...extra};
      out.players     = pickArray(base.players, extra.players) || base.players || extra.players || [];
      out.objectives  = pickArray(base.objectives, extra.objectives) || base.objectives || extra.objectives || [];
      out.chat        = pickArray(base.chat, extra.chat) || base.chat || extra.chat || [];
      out.picks_bans  = pickArray(base.picks_bans, extra.picks_bans) || base.picks_bans || extra.picks_bans || [];
      out.radiant_gold_adv = Array.isArray(extra?.radiant_gold_adv) && extra.radiant_gold_adv.length ? extra.radiant_gold_adv
                             : (Array.isArray(base?.radiant_gold_adv)? base.radiant_gold_adv : undefined);
      return out;
    };
    // If partial or missing, try to enrich with live API
    if(isPartial(md)){
      __partialCount++;
      const api = await loadJson(`https://api.opendota.com/api/matches/${id}`);
      if(api){ md = mergeDetails(md, api); } else {
        // No API; keep whatever we have (even if partial) to salvage any usable stats
      }
    }
    // If still nothing, build a minimal skeleton from monthly shards entry
    if(!md){
      try{
        const src = (Array.isArray(allMatches)? allMatches: []).find(m => Number(m.match_id||m.matchId) === Number(id));
        if(src){
          const rPlayers = []; const dPlayers = [];
          const players = Array.isArray(src.players)? src.players: [];
          // Assign synthetic player_slot by side based on is_radiant
          for(const p of players){
            const aid = Number(p.account_id||0);
            const hid = Number(p.hero_id||0);
            const name = String(p.personaname||'');
            const isRad = !!p.is_radiant;
            const obj = { account_id: aid, hero_id: hid, personaname: name, isRadiant: isRad };
            if(isRad){ rPlayers.push(obj); } else { dPlayers.push(obj); }
          }
          // Assign conventional slots 0-4 for Radiant, 128-132 for Dire
          rPlayers.forEach((p,i)=> p.player_slot = i);
          dPlayers.forEach((p,i)=> p.player_slot = 128+i);
          md = {
            match_id: Number(src.match_id)||Number(id)||0,
            start_time: Number(src.start_time)||undefined,
            radiant_win: !!src.radiant_win,
            radiant_team_id: src.radiant_team_id,
            dire_team_id: src.dire_team_id,
            radiant_name: src.radiant_name,
            dire_name: src.dire_name,
            players: [...rPlayers, ...dPlayers],
            objectives: [],
          };
        }
      }catch(_e){}
    }
    // Final guard: if still missing, return a benign stub so downstream logic can skip gracefully
    if(!md) return { match_id:Number(id)||0, players:[], objectives:[] };
    return md;
  }
  async function pMap(items, limit, worker){
    const ret=new Array(items.length); let i=0; let active=0; let rej; const errors=[];
    return await new Promise((resolve, reject)=>{ rej=reject; function next(){ if(i>=items.length && active===0){ resolve(ret); return; } while(active<limit && i<items.length){ const idx=i++; active++; Promise.resolve(worker(items[idx], idx)).then(v=>{ ret[idx]=v; active--; next(); }).catch(e=>{ errors.push(e); ret[idx]=null; active--; next(); }); } } next(); });
  }
  function computeHighlightsFromDetails(details, heroMap){
    // Structures similar to server-side script
    const tag2id = mapHeroTag(heroMap);
  const rampages = new Map();        // aid -> count (all)
  const rampGames = new Map();       // aid -> Map<match_id,count> (all)
  const rampagesSide = {Radiant:new Map(), Dire:new Map()}; // side -> aid -> count
  const rampGamesSide = {Radiant:new Map(), Dire:new Map()}; // side -> aid -> Map<match_id,count>
    const wardSpots = new Map();       // "x,y" -> count
    const wardEvents = [];             // {x,y,type}
    const wardLifeMax = new Map();     // spot -> maxSeconds
    const obsPlacedBy = new Map();     // aid -> count
    const dewardsBy = new Map();       // aid -> count
    const lifeBy = new Map();          // aid -> number[]
    const pairCounts = new Map();      // "aid1-aid2" -> games
    const courierKillsBy = new Map();  // aid -> total
    const campsStackedBy = new Map();  // aid -> total
  const rapierBy = new Map();        // aid -> total rapiers bought
    const gemBy = new Map();           // aid -> total gems bought
  const banCounts = new Map();       // hid -> bans
  const roshanTeam = {Radiant:0, Dire:0};
    const roshPerMatch = {Radiant:new Map(), Dire:new Map()};
  const roshanEvents = [];
  const aegisSnatch = []; const tormentor = [];
  const tormentorExplicitMids = new Set();
    let bestGPM=null, bestKills=null, bestAssists=null, bestNet=null;
    const durList=[]; let objectivesSeen=false;

    function addMapCount(map, key, inc=1){ const k=String(key); map.set(k, (map.get(k)||0)+inc); }
    function addNestedCount(obj, side, matchId){ const m=obj[side]; const k=String(matchId); m.set(k, (m.get(k)||0)+1); }
    function playerName(aid, md){
  aid=Number(aid)||0; if(!aid) return `Player ${aid}`; const p=players.find(pp=>(pp.account_id|0)===aid); return p&&p.personaname ? p.personaname : `Player ${aid}`;
    }

    for(const md of details){ if(!md) continue; const mid = Number(md.match_id||md.matchId||0); if(!(mid>0)) continue;
      try{
        // Per-match helpers for ward life pairing
        const placed=[], left=[]; const heroToAccount=new Map();
        // Ensure player_slot exists; if missing, synthesize by isRadiant order
        let players = Array.isArray(md.players)? md.players: [];
        const hasSlots = players.some(p=>p && p.player_slot!==undefined);
        if(!hasSlots){
          const r=[]; const d=[]; for(const p of players){ if(p && (p.isRadiant===true || p.is_radiant===true)) r.push(p); else d.push(p); }
          r.forEach((p,i)=> p.player_slot = i);
          d.forEach((p,i)=> p.player_slot = 128+i);
          players = [...r, ...d];
        }
        for(const p of players){
          const aid = Number(p.account_id||0); const prof = aid? OD_PLAYER_URL(aid): '#';
          // Multi-kills -> rampages
          const mk = p.multi_kills || {};
          const r = Number(mk['5']||0);
          if(aid>0 && r>0){
            // overall
            addMapCount(rampages, aid, r);
            if(!rampGames.has(aid)) rampGames.set(aid, new Map());
            addMapCount(rampGames.get(aid), mid, r);
            // by side
            const side = (Number(p.player_slot)<128)? 'Radiant' : 'Dire';
            addMapCount(rampagesSide[side], aid, r);
            if(!rampGamesSide[side].has(aid)) rampGamesSide[side].set(aid, new Map());
            addMapCount(rampGamesSide[side].get(aid), mid, r);
          }
          // Single-match tops
          const nm = p.personaname || playerName(aid, md);
          const setBest = (cur, val, label)=>{ if(val>0 && (!cur || (cur.value||0)<val)) return {account_id:aid,name:nm,profile:prof,value:val,match_id:mid}; return cur; };
          bestGPM     = setBest(bestGPM, Number(p.gold_per_min||0), 'gpm');
          bestKills   = setBest(bestKills, Number(p.kills||0), 'kills');
          bestAssists = setBest(bestAssists, Number(p.assists||0), 'assists');
          let net = Number(p.net_worth||0); if(!net){ net = Number(p.total_gold||0) || (Array.isArray(p.gold_t)&&p.gold_t.length? Number(p.gold_t[p.gold_t.length-1]||0):0); }
          bestNet     = setBest(bestNet, net, 'networth');
          // Courier / Stacks
          if(aid>0 && Number(p.courier_kills||0)>0) addMapCount(courierKillsBy, aid, Number(p.courier_kills));
          if(aid>0 && Number(p.camps_stacked||0)>0) addMapCount(campsStackedBy, aid, Number(p.camps_stacked));
          // Purchases: Rapier / Gem
          const plog = Array.isArray(p.purchase_log) ? p.purchase_log : [];
          for(const it of plog){
            const key = String(it.key||it.item||'').toLowerCase();
            if(!aid) continue;
            if(key.includes('rapier')) addMapCount(rapierBy, aid, 1);
            if(key==='gem' || key.includes('gem_of_true_sight') || key.includes('gem')) addMapCount(gemBy, aid, 1);
          }
          // Ward stats
          const obsLog = Array.isArray(p.obs_log)? p.obs_log : [];
          const leftLog = Array.isArray(p.obs_left_log)? p.obs_left_log : [];
          if(aid>0 && obsLog.length){ addMapCount(obsPlacedBy, aid, obsLog.length); }
          for(const o of obsLog){ const x=Number(o.x), y=Number(o.y), t=Number(o.time||0); const k=`${x},${y}`; addMapCount(wardSpots, k, 1); wardEvents.push({x,y,type:'obs'}); placed.push({x,y,time:t}); }
          for(const o of leftLog){ left.push({x:Number(o.x), y:Number(o.y), time:Number(o.time||0), attackername: String(o.attackername||'')}); }
          // Dewards (observers only)
          let dk = Number(p.obs_kills||p.obs_killed||0);
          if(aid>0 && dk>0) addMapCount(dewardsBy, aid, dk);
          // Hero->Account for deward fallback
          if((p.hero_id|0)>0 && aid>0) heroToAccount.set(Number(p.hero_id), aid);
        }
        // Additional dewards derivation via attackername in obs_left_log
        for(const o of left){ const an = String(o.attackername||''); if(an.startsWith('npc_dota_hero_')){ const tag = an.replace(/^npc_dota_hero_/,''); const hid = tag2id[tag]; const killer = heroToAccount.get(hid); if(killer){ addMapCount(dewardsBy, killer, 1); } } }
        // Pair placements with first removals per cell to compute longest lifetime per spot
        const pBy=new Map(), lBy=new Map();
        for(const e of placed){ const k=`${e.x},${e.y}`; if(!pBy.has(k)) pBy.set(k,[]); pBy.get(k).push(Number(e.time||0)); }
        for(const e of left){ const k=`${e.x},${e.y}`; if(!lBy.has(k)) lBy.set(k,[]); lBy.get(k).push(Number(e.time||0)); }
  for(const [k,pt] of pBy){ pt.sort((a,b)=>a-b); const lt=(lBy.get(k)||[]).sort((a,b)=>a-b); let j=0; for(let i=0;i<pt.length;i++){ const tP=pt[i]; while(j<lt.length && lt[j]<tP) j++; let life=360; if(j<lt.length){ life = Math.max(0, Number(lt[j]-tP)); j++; } life = Math.min(360, life); const cur=wardLifeMax.get(k)||0; if(life>cur) wardLifeMax.set(k, life); } }
        // Lifetimes per player (avg)
  for(const p of players){
          const aid=Number(p.account_id||0); if(!(aid>0)) continue; const obsLog=Array.isArray(p.obs_log)? p.obs_log:[]; const leftLog=Array.isArray(p.obs_left_log)? p.obs_left_log:[];
          const times=[]; const P=obsLog.map(o=>Number(o.time||0)).sort((a,b)=>a-b); const L=leftLog.map(o=>Number(o.time||0)).sort((a,b)=>a-b); let jj=0; for(let i=0;i<P.length;i++){ const tP=P[i]; while(jj<L.length && L[jj]<tP) jj++; let life=360; if(jj<L.length){ life = Math.max(0, L[jj]-tP); jj++; } times.push(Math.min(360, life)); }
          if(times.length){ const arr=lifeBy.get(aid)||[]; lifeBy.set(aid, arr.concat(times)); }
        }
        // Teammates per match, courier etc already counted per player; now pair counts
  const rad=[], dire=[]; for(const p of players){ const aid=Number(p.account_id||0); if(!(aid>0)) continue; ((p.isRadiant===true || p.is_radiant===true || Number(p.player_slot)<128)?rad:dire).push(aid); }
        const sides=[rad,dire]; for(const arr of sides){ for(let i=0;i<arr.length;i++){ for(let j=i+1;j<arr.length;j++){ const a=arr[i], b=arr[j]; const lo=Math.min(a,b), hi=Math.max(a,b); const key=`${lo}-${hi}`; addMapCount(pairCounts, key, 1); } } }
        // Lane duos (Safe=1, Off=3), use lane_role and lane_efficiency_pct
  const bySide={Radiant:players.filter(p=> (p.isRadiant===true || p.is_radiant===true || Number(p.player_slot)<128)), Dire:players.filter(p=> !(p.isRadiant===true || p.is_radiant===true || Number(p.player_slot)<128))};
        const duos={Safe:new Map(), Off:new Map()};
        for(const laneName of ['Safe','Off']){
          const code = laneName==='Safe'?1:3;
          const rL = bySide.Radiant.filter(p=>(p.lane_role|0)===code);
          const dL = bySide.Dire.filter(p=>(p.lane_role|0)===code);
          if(rL.length===2 && dL.length===2){
            const rAvg = (rL.map(p=>Number(p.lane_efficiency_pct||0)).reduce((a,b)=>a+b,0))/2;
            const dAvg = (dL.map(p=>Number(p.lane_efficiency_pct||0)).reduce((a,b)=>a+b,0))/2;
            const rPair=[Number(rL[0].hero_id), Number(rL[1].hero_id)].sort((a,b)=>a-b);
            const dPair=[Number(dL[0].hero_id), Number(dL[1].hero_id)].sort((a,b)=>a-b);
            const rk=`${rPair[0]}-${rPair[1]}`, dk=`${dPair[0]}-${dPair[1]}`;
            const R=duos.Safe, O=duos.Off; const M = laneName==='Safe'?R:O;
            if(!M.has(rk)) M.set(rk,{games:0,wins:0}); if(!M.has(dk)) M.set(dk,{games:0,wins:0});
            M.get(rk).games++; M.get(dk).games++; if((rAvg-dAvg)>=0) M.get(rk).wins++; else M.get(dk).wins++;
          }
        }
        // Picks/Bans aggregation
        try{
          const pbs = Array.isArray(md.picks_bans)? md.picks_bans : [];
          for(const pb of pbs){ if(pb && pb.is_pick===false){ const hid = Number(pb.hero_id||0); if(hid>0) banCounts.set(hid, (banCounts.get(hid)||0)+1); } }
        }catch(_e){}
        // Objectives: Roshan, Aegis snatch, Tormentor
  if(Array.isArray(md.objectives) && md.objectives.length){ objectivesSeen=true; for(const ev of md.objectives){ const t=String(ev.type||'');
            if(/roshan_kill|CHAT_MESSAGE_ROSHAN_KILL/i.test(t)){
              const team = getTeamByObjective(ev, md);
              if(team){ roshanTeam[team]++; addNestedCount(roshPerMatch, team, mid); }
              const sec = Number(ev.time||0);
              const slot = ev.player_slot;
              let player=null;
              if(slot!==undefined){ const pp=players.find(p=>p.player_slot===slot); if(pp){ player={account_id:pp.account_id, name:pp.personaname||playerName(pp.account_id, md), profile: OD_PLAYER_URL(pp.account_id), hero: (heroMap[String(pp.hero_id)]||{}).name||''}; } }
              roshanEvents.push({match_id:mid,time:sec,team,player});
            }
            if(/CHAT_MESSAGE_AEGIS_STOLEN/i.test(t)){ const team = getTeamByObjective(ev, md); const sec=Number(ev.time||0); const slot = ev.player_slot; let player=null; if(slot!==undefined){ const pp=players.find(p=>p.player_slot===slot); if(pp){ player={account_id:pp.account_id, name:pp.personaname||playerName(pp.account_id, md), profile: OD_PLAYER_URL(pp.account_id), hero: (heroMap[String(pp.hero_id)]||{}).name||''}; } }
              aegisSnatch.push({match_id:mid,time:sec,team,player}); }
            if(/tormentor|miniboss|CHAT_MESSAGE_TORMENTOR_KILL|CHAT_MESSAGE_MINIBOSS/i.test(t) || /tormentor|miniboss/i.test(String(ev.key||'')) || /tormentor|miniboss/i.test(String(ev.unit||'')) || /tormentor|miniboss/i.test(String(ev.msg||''))){
              const team = getTeamByObjective(ev, md); const sec=Number(ev.time||0); const slot = ev.player_slot; let player=null; if(slot!==undefined){ const pp=players.find(p=>p.player_slot===slot); if(pp){ player={account_id:pp.account_id, name:pp.personaname||playerName(pp.account_id, md), profile: OD_PLAYER_URL(pp.account_id), hero: (heroMap[String(pp.hero_id)]||{}).name||''}; } }
              tormentor.push({match_id:mid,time:sec,team,player,confidence:'explicit'}); tormentorExplicitMids.add(mid); }
          } }
        // Fallback: derive Tormentor kills from per-player killed logs when explicit objective not present
        try{
          if(!tormentorExplicitMids.has(mid)){
            for(const p of players){
              const killed = p && p.killed ? p.killed : null;
              if(!killed) continue;
              // sum keys that look like miniboss/tormentor
              let ct = 0; try{ for(const k in killed){ if(/miniboss|tormentor/i.test(String(k||''))){ ct += Number(killed[k]||0); } } }catch(_e){}
              if(ct>0){
                const slot = p.player_slot; let player=null; if(slot!==undefined){ const pp=p; player={account_id:pp.account_id, name:pp.personaname||playerName(pp.account_id, md), profile: OD_PLAYER_URL(pp.account_id), hero: (heroMap[String(pp.hero_id)]||{}).name||''}; }
                const team = (Number(p.player_slot)<128)?'Radiant':'Dire';
                tormentor.push({match_id:mid,time:null,team,player,confidence:'derived',count:ct});
              }
            }
          }
        }catch(_e){}
        // Duration
        const rname = md.radiant_name || 'Radiant'; const dname = md.dire_name || 'Dire'; const dur = Number(md.duration||0); durList.push({match_id:mid,duration:dur,radiant:rname,dire:dname,radiant_win: !!md.radiant_win});
      }catch(e){ console.warn('agg err', mid, e); }
    }
    // Build outputs
    function dedupeByProximity(items, take, radius){
      const r2 = radius*radius; const out=[];
      outer: for(const it of items){
        for(const s of out){ const dx=it.x-s.x, dy=it.y-s.y; if((dx*dx + dy*dy) <= r2){ continue outer; } }
        out.push(it); if(out.length>=take) break;
      }
      return out;
    }
    const wardSpotItems = Array.from(wardSpots.entries()).map(([spot,count])=>{ const [x,y]=String(spot).split(',').map(Number); return {spot:String(spot), x, y, count:Number(count)||0}; }).sort((a,b)=> b.count - a.count);
    const wardTopItems = dedupeByProximity(wardSpotItems, 10, 3);
  const wardTop = wardTopItems.map((w,i)=>({spot:`${w.x},${w.y}`, count:w.count, spotId:`spot${i}`}));
    const wardPoints = Array.from(wardSpots.entries()).map(([k,c])=>{ const [x,y]=k.split(',').map(n=>Number(n)); return {x,y,count:c}; });
    const rawLongest = Array.from(wardLifeMax.entries()).map(([spot,maxSeconds])=>{ const count = wardSpots.get(spot)||0; if(count<3) return null; const [x,y]=String(spot).split(',').map(Number); const id = (wardTop.find(w=>w.spot===spot)||{}).spotId || ('spot_'+spot.replace(/[^0-9]/g,'_')); return {spot:String(spot), x, y, maxSeconds:Number(maxSeconds)||0, count:Number(count)||0, spotId:id}; }).filter(Boolean).sort((a,b)=> b.maxSeconds-a.maxSeconds);
    const wardLongestItems = dedupeByProximity(rawLongest, 10, 3);
    const wardLongest = wardLongestItems.map((o,i)=>({spot:o.spot, maxSeconds:o.maxSeconds, count:o.count, spotId:o.spotId || `long${i}`}));

  function topNByCount(mp, n){ return Array.from(mp.entries()).map(([aid,c])=>({account_id:Number(aid), name: `Player ${aid}`, profile: OD_PLAYER_URL(aid), count:c})).sort((a,b)=> b.count-a.count).slice(0,n); }
    function namedTop(mp, n){ return topNByCount(mp, n).map(x=>{ x.name = x.name; return x; }); }
    // Resolve names for players we saw
  const nameCache=new Map(); for(const md of details){ if(!md) continue; const players=(Array.isArray(md.players)? md.players:[]); for(const p of players){ const aid=Number(p.account_id||0); if(aid>0 && p.personaname) nameCache.set(aid, p.personaname); } }
    function withNames(arr){ return (arr||[]).map(o=> ({...o, name: nameCache.get(Number(o.account_id)) || o.name})); }
    const mostPlaced = withNames(topNByCount(obsPlacedBy, 5));
    const mostDewards = withNames(topNByCount(dewardsBy, 5));
    const longestAvg = withNames(Array.from(lifeBy.entries()).map(([aid,arr])=>({account_id:Number(aid), name:`Player ${aid}`, profile: OD_PLAYER_URL(aid), avgSeconds: arr.length? Math.round(arr.reduce((a,b)=>a+b,0)/arr.length):0, samples: arr.length})).sort((a,b)=> b.avgSeconds-a.avgSeconds).slice(0,5));
    // Teammates pairs top
    const teammates = Array.from(pairCounts.entries()).map(([k,games])=>{ const [a,b]=k.split('-').map(Number); return {a,b, name1: nameCache.get(a)||`Player ${a}`, name2: nameCache.get(b)||`Player ${b}`, profile1: OD_PLAYER_URL(a), profile2: OD_PLAYER_URL(b), games: Number(games)}; }).sort((a,b)=> b.games-a.games || String(a.name1).localeCompare(String(b.name1))).slice(0,3);
    // Courier/Stacks
    const courierTop = withNames(topNByCount(courierKillsBy,3));
    const stackTop = withNames(topNByCount(campsStackedBy,3));
  const rapierTop = withNames(topNByCount(rapierBy,3));
  const gemTop = withNames(topNByCount(gemBy,3));
  // Duos build arrays with WR
  function duosFromMap(mp){ return Array.from(mp.entries()).map(([key,v])=>{ const [a,b]=key.split('-').map(Number); const wr = v.games? v.wins/v.games : 0; return {a,b,games:v.games,wins:v.wins,winrate:wr}; }).sort((a,b)=> (b.winrate-a.winrate) || (b.games-a.games)).slice(0,5); }
    // We actually stored duos within scope above; recompute here by re-deriving from details for simplicity
    const duoAgg = {Safe:new Map(), Off:new Map()};
  for(const md of details){ if(!md) continue; const players=(Array.isArray(md.players)? md.players:[]); const bySide={Radiant:players.filter(p=>p.isRadiant), Dire:players.filter(p=>!p.isRadiant)};
      for(const laneName of ['Safe','Off']){ const code=laneName==='Safe'?1:3; const rL=bySide.Radiant.filter(p=>(p.lane_role|0)===code); const dL=bySide.Dire.filter(p=>(p.lane_role|0)===code); if(rL.length===2 && dL.length===2){ const rAvg=(Number(rL[0].lane_efficiency_pct||0)+Number(rL[1].lane_efficiency_pct||0))/2; const dAvg=(Number(dL[0].lane_efficiency_pct||0)+Number(dL[1].lane_efficiency_pct||0))/2; const rPair=[Number(rL[0].hero_id),Number(rL[1].hero_id)].sort((a,b)=>a-b); const dPair=[Number(dL[0].hero_id),Number(dL[1].hero_id)].sort((a,b)=>a-b);
        const rk=`${rPair[0]}-${rPair[1]}`, dk=`${dPair[0]}-${dPair[1]}`;
        const R=duoAgg.Safe, O=duoAgg.Off; const M = laneName==='Safe'?R:O;
        if(!M.has(rk)) M.set(rk,{games:0,wins:0}); if(!M.has(dk)) M.set(dk,{games:0,wins:0});
        M.get(rk).games++; M.get(dk).games++; if((rAvg-dAvg)>=0) M.get(rk).wins++; else M.get(dk).wins++;
      }
  }
  // Close outer loop over details
  }
  const safeDuosArr = duosFromMap(duoAgg.Safe); const offDuosArr = duosFromMap(duoAgg.Off);
    // Roshan top matches arrays
    function roshTopArr(map){ const arr = Array.from(map.entries()).map(([mid,c])=>({match_id:Number(mid), count:Number(c)})).sort((a,b)=> b.count-a.count || b.match_id-a.match_id); if(!arr.length) return []; const max=arr[0].count; return arr.filter(x=>x.count===max).slice(0,3); }
    const roshanTop = { Radiant: roshTopArr(roshPerMatch.Radiant), Dire: roshTopArr(roshPerMatch.Dire) };
    // Roshan kills by match (both sides summarized)
    const roshanByMatch = (()=>{
      const ids = new Set([...roshPerMatch.Radiant.keys(), ...roshPerMatch.Dire.keys()]);
      const arr = Array.from(ids).map(mid=>{
        const r = Number(roshPerMatch.Radiant.get(mid)||0);
        const d = Number(roshPerMatch.Dire.get(mid)||0);
        return { match_id: Number(mid), Radiant: r, Dire: d, total: r+d };
      }).sort((a,b)=> (b.total - a.total) || (b.match_id - a.match_id));
      return arr;
    })();
    // Tormentor kills by match (both sides summarized)
    const tormentorByMatch = (()=>{
      const mp = new Map();
      for(const ev of (tormentor||[])){
        const mid = Number(ev.match_id||0); if(!mid) continue;
        const team = String(ev.team||'');
        const add = Number(ev.count||1) || 1;
        const cur = mp.get(mid) || {Radiant:0, Dire:0, total:0};
        if(team==='Radiant'){ cur.Radiant += add; }
        else if(team==='Dire'){ cur.Dire += add; }
        cur.total = cur.Radiant + cur.Dire; mp.set(mid, cur);
      }
      const arr = Array.from(mp.entries()).map(([mid,o])=>({ match_id:Number(mid), Radiant:o.Radiant, Dire:o.Dire, total:o.total }));
      return arr.sort((a,b)=> (b.total - a.total) || (b.match_id - a.match_id));
    })();
    // Rampages list (top 10)
  const buildRampList = (map, gmap)=> Array.from(map.entries()).map(([aid,c])=>({ account_id:Number(aid), name: nameCache.get(Number(aid)) || `Player ${aid}`, profile: OD_PLAYER_URL(aid), count:Number(c), matches: Array.from((gmap.get(aid)||new Map()).entries()).map(([mid,v])=>({match_id:Number(mid), count:Number(v)})).sort((a,b)=> b.count-a.count || b.match_id-a.match_id) })).sort((a,b)=> b.count-a.count).slice(0,10);
  const rampList = buildRampList(rampages, rampGames);
  const rampListRadiant = buildRampList(rampagesSide.Radiant, rampGamesSide.Radiant);
  const rampListDire = buildRampList(rampagesSide.Dire, rampGamesSide.Dire);
    // Top single
    const topSingle={}; if(bestGPM) topSingle.gpm=bestGPM; if(bestKills) topSingle.kills=bestKills; if(bestAssists) topSingle.assists=bestAssists; if(bestNet) topSingle.networth=bestNet;
    // Duration lists
    const durationLongest = durList.slice().sort((a,b)=> b.duration-a.duration).slice(0,3);
    const durationShortest = durList.slice().sort((a,b)=> a.duration-b.duration).slice(0,3);
  return {
  rampages: rampList,
  rampagesBySide: { Radiant: rampListRadiant, Dire: rampListDire },
      wardSpots: wardTop,
      wardPoints,
      wardEvents,
      wardLongest,
      wardPlayers: { mostPlaced, mostDewards, longestAvg },
      teammates,
      courierTop,
      stackTop,
  rapierTop,
  gemTop,
      safeDuos: safeDuosArr,
      offDuos: offDuosArr,
  roshan: { Radiant: roshanTeam.Radiant, Dire: roshanTeam.Dire },
  roshanEvents,
  roshanTop,
  roshanByMatch,
  tormentorByMatch,
      topSingle,
      aegisSnatch,
      tormentor,
      objectivesSeen,
      durationLongest,
  durationShortest,
  banCounts
    };
  }

  async function computeHighlightsForSubset(subset, heroMap, mapConf, label){
    const body = document.getElementById('highlightsBody'); const card = document.getElementById('highlightsCard');
    card.style.display=''; body.innerHTML = `<div class='sub'>Computing highlights for selected range… This may take a few seconds.</div>`;
    // Limit concurrency; fetch details for all matches in range
    const ids = subset.map(m=>m.match_id).filter(Boolean);
    // Guard against extremely large ranges
    if(ids.length>600){ body.innerHTML = `<div class='sub'>Range has ${ids.length} matches. Computing highlights on-the-fly would take too long. Narrow the range or use prebuilt All-time page.</div>`; return; }
  const details = (await pMap(ids, 4, id=> fetchMatchDetail(id))).filter(Boolean);
  // If none of the details have player data, inform the user about possible CORS/offline issues
  const okDetails = details.filter(d => Array.isArray(d.players) && d.players.length>0);
  const warnNoDetails = okDetails.length===0;
  const high = computeHighlightsFromDetails(details, heroMap);
  renderHighlights(high, heroMap, mapConf, label);
  // Mount WardViewer into dedicated Wards tab
  try{
    const container = document.getElementById('dvWardMount');
    if(container && window.WardViewer){
      // Build teams from details (names best-effort)
      const teamMap = new Map();
      const playerMap = new Map();
      for(const md of details){ if(!md) continue; const rId=Number(md.radiant_team_id||0), dId=Number(md.dire_team_id||0);
        if(rId>0) teamMap.set(rId,{id:rId, name: md.radiant_name||(`Team ${rId}`)});
        if(dId>0) teamMap.set(dId,{id:dId, name: md.dire_name||(`Team ${dId}`)});
        // collect players for filtering
        const pls = Array.isArray(md.players)? md.players:[];
        for(const p of pls){ const aid=Number(p.account_id||0); if(aid>0){ const name = p.personaname || `Player ${aid}`; if(!playerMap.has(aid)) playerMap.set(aid,{id:aid, name}); } }
      }
      // Fallback: if details had no players (offline/partial), derive from subset and global playerNames
      if(playerMap.size===0){
        try{
          const seen = new Set();
          for(const m of subset||[]){
            const pls = Array.isArray(m.players)? m.players: [];
            for(const p of pls){
              const aid = Number(p.account_id||0); if(!(aid>0)) continue;
              if(seen.has(aid)) continue; seen.add(aid);
              const nm = p.personaname || playerNames[String(aid)] || `Player ${aid}`;
              playerMap.set(aid, { id: aid, name: nm });
            }
          }
          // As a last resort, populate from global playerNames map
          if(playerMap.size===0){
            for(const [idStr,nm] of Object.entries(playerNames||{})){
              const aid = Number(idStr)||0; if(!(aid>0)) continue;
              playerMap.set(aid, { id: aid, name: String(nm||`Player ${aid}`) });
            }
          }
        }catch(_e){}
      }
      // Build spot aggregates with samples for time slicing
      const countBy = new Map(); const totalBy = new Map(); const bySide = new Map(); const byTeam = new Map(); const samplesBy = new Map();
      for(const md of details){ if(!md) continue; const players = Array.isArray(md.players)? md.players: []; const rId=Number(md.radiant_team_id||0), dId=Number(md.dire_team_id||0);
        for(const p of players){ const side = (Number(p.player_slot)<128)? 'Radiant' : 'Dire'; const teamId = side==='Radiant'? rId : dId; const aid = Number(p.account_id||0); const P = Array.isArray(p.obs_log)? p.obs_log: []; const L = Array.isArray(p.obs_left_log)? p.obs_left_log: [];
          const pt = P.map(o=>({x:Number(o.x),y:Number(o.y),t:Number(o.time||0)})).sort((a,b)=>a.t-b.t);
          const lt = L.map(o=>({x:Number(o.x),y:Number(o.y),t:Number(o.time||0)})).sort((a,b)=>a.t-b.t);
          const mapL = new Map(); for(const e of lt){ const k=`${e.x},${e.y}`; if(!mapL.has(k)) mapL.set(k,[]); mapL.get(k).push(e.t); }
          for(const e of pt){ const k=`${e.x},${e.y}`; const arr = mapL.get(k)||[]; let life=360; if(arr.length){ const idx = arr.findIndex(T=> T>=e.t); if(idx!==-1){ life=Math.max(0, arr[idx]-e.t); arr.splice(idx,1); } mapL.set(k,arr); }
            life = Math.min(360, life);
            countBy.set(k,(countBy.get(k)||0)+1); totalBy.set(k,(totalBy.get(k)||0)+life);
            const sb = bySide.get(k)||{Radiant:{count:0,total:0}, Dire:{count:0,total:0}}; sb[side].count++; sb[side].total += life; bySide.set(k,sb);
            if(teamId>0){ const tb=byTeam.get(k)||{}; const to=tb[teamId]||{count:0,total:0}; to.count++; to.total+=life; tb[teamId]=to; byTeam.set(k,tb); }
            const sm = samplesBy.get(k)||[]; sm.push({t:e.t, life, side, teamId, aid}); samplesBy.set(k,sm);
          }
        }
      }
      const spots = Array.from(countBy.keys()).map(k=>{ const [x,y]=k.split(',').map(Number); return { spot:k, x, y, count:countBy.get(k)||0, total:totalBy.get(k)||0, bySide:bySide.get(k)||{Radiant:{count:0,total:0}, Dire:{count:0,total:0}}, byTeam:byTeam.get(k)||{}, samples:samplesBy.get(k)||[] }; });
  window.WardViewer.mount(container, { mapConf, data:{ spots, teams:Array.from(teamMap.values()), players:Array.from(playerMap.values()) }, options:{ modeDefault:'best', showExtras:true, showLongest:false, ignorePersistedPlayer:true, extras:{ wardPlayers: high.wardPlayers||{}, wardLongest: [] } } });
    }
  }catch(err){ console.warn('WardViewer mount failed', err); }
  if(warnNoDetails){
    const note = `<div class='sub' style='margin-bottom:8px'>Detailed match data could not be loaded (file:// CORS or offline). The map renders with available data, but some highlights may be missing. For full data, serve docs/ over a local server.</div>`;
    try{ body.innerHTML = note + body.innerHTML; }catch(_e){}
  }
  // Update Top Banned summary from detailed banCounts
  try{
    const ul = document.getElementById('ul-top-banned');
    if(ul && high && high.banCounts){
      const arr = Array.from(high.banCounts.entries()).map(([hid,cnt])=>({hid:Number(hid), bans:Number(cnt)})).sort((a,b)=> b.bans-a.bans).slice(0,3);
  const html = arr.map(h=>{ const meta = heroMap[String(h.hid)]||{}; return `<li><span style='display:flex;align-items:center;gap:8px'><img src='${meta.img||''}' alt='${meta.name||('#'+h.hid)}'><span class='name'>${meta.name||('#'+h.hid)}</span></span><span><span class='badge'>Bans: ${h.bans}</span></span></li>`; }).join('');
      ul.innerHTML = html || `<li><span class='sub'>no data</span></li>`;
    }
  }catch(_e){}
  // Compute awards in parallel with same details
  const awards = computeAwardsFromDetails(details, heroMap);
  const hideEmpty = !!(document.getElementById('awHideEmpty') && document.getElementById('awHideEmpty').checked);
  renderAwards(awards, heroMap, { hideEmpty, filterAid: __userOnlyAid>0 ? __userOnlyAid : 0 });
  }

  function apply(){
    let f = parseLocalInput(from.value); if(!isFinite(f)) f=0;
    let t = parseLocalInput(to.value);   if(!isFinite(t)) t=Number.MAX_SAFE_INTEGER;
    if(f>t){ const tmp=f; f=t; t=tmp; }
    // Header title/sub
    try{
      const league = (info && (info.league_name||info.league||'')) || "League";
      document.getElementById('leagueTitle').textContent = `${league} – Dynamic viewer`;
      const fmt=(s)=>{ if(!s) return ''; const d=new Date(s*1000); return d.toISOString().replace('T',' ').slice(0,16)+'Z'; };
  let sub=`${fmt(f)} to ${fmt(t)} (UTC)`;
  if(__userOnlyAid>0){ sub += ' · user-only'; }
      document.getElementById('headerSub').textContent=sub;
      // Show focused player chip if requested
      const el = document.getElementById('playerFocus');
      if(el){
        if(__focusAid>0){
          // Try to resolve player name from current subset cache
          let nm = '';
          const any = __subsetCache && __subsetCache.length ? __subsetCache : [];
          for(const m of any){ if(Array.isArray(m.players)){ const p=m.players.find(x=> Number(x.account_id||0)===__focusAid); if(p && p.personaname){ nm=p.personaname; break; } } }
          el.style.display='inline'; el.textContent = nm ? `(focused: ${nm})` : `(focused AID ${__focusAid})`;
        } else {
          el.style.display='none'; el.textContent='';
        }
      }
  }catch(_e){}
  // Build base subset by time; derive stats vs view subsets
  const baseSubset = allMatches.filter(m=> (m.start_time>=f) && (m.start_time<=t) );
  const hasAid = (m, aid)=> Array.isArray(m.players) && m.players.some(p=> Number(p.account_id||0)===aid);
  let statsSubset = baseSubset;
  if(__userOnlyAid>0){ statsSubset = baseSubset.filter(m => hasAid(m, __userOnlyAid)); }
  __subsetCache = statsSubset; __rangeUnix = {from:f,to:t};
  // Update header with match count to make empty selections obvious
  try{
    const hs=document.getElementById('headerSub'); if(hs){ hs.textContent = (hs.textContent||'') + ` · ${statsSubset.length} matches`; }
    const badge = document.getElementById('rangeMatchBadge');
    if(badge){ badge.textContent = `${statsSubset.length} matches`; badge.style.display='inline-block'; }
  }catch(_e){}
  // Init calendar cursor to month of 'to'
  const dTo = new Date(t*1000); __calCursor = {y:dTo.getUTCFullYear(), m:dTo.getUTCMonth()};
  const agg = aggregate(statsSubset, playerNames, teamNames);
  renderSummary(agg, heroes);
    render(agg, heroes);
  // Compute highlights live for this arbitrary range
  const label = `Period: ${new Date(f*1000).toISOString().slice(0,10)} to ${new Date(t*1000).toISOString().slice(0,10)} (UTC)`;
  // Use statsSubset for highlights to reflect overall stats when games-only is active
  computeHighlightsForSubset(statsSubset, heroes, mapConf, label);
  // Render calendar for current cursor
  renderCalendarMonth(__subsetCache, __rangeUnix, __calCursor);
  }
  // Wire hide-empty persistence and change handler
  try{
    const cb = document.getElementById('awHideEmpty');
    const key = 'dv_aw_hide_empty';
    const saved = localStorage.getItem(key);
    if(cb){ cb.checked = saved===null ? true : (saved==='1'); cb.addEventListener('change', ()=>{ localStorage.setItem(key, cb.checked?'1':'0'); if(typeof __lastAwards==='object'){ renderAwards(__lastAwards, heroes, { hideEmpty: cb.checked }); } }); }
  }catch(_e){}
  document.getElementById('apply').addEventListener('click', apply);
  // Player filter: selecting a player enforces user-only view
  try{
    const sel = document.getElementById('playerFilter');
    const genBtn = document.getElementById('genUserReport');
    if(sel){ sel.addEventListener('change', ()=>{ const v=Number(sel.value||0)||0; __focusAid=v; __userOnlyAid = v>0 ? v : 0; apply(); }); }
    if(genBtn){ genBtn.addEventListener('click', ()=>{
      const aid = Number((sel&&sel.value)||0)||0; if(!(aid>0)) { alert('Select a player first.'); return; }
      const name = (function(){ try{ const opt=sel.options[sel.selectedIndex]; return (opt&&opt.text)||`Player ${aid}`; }catch(_e){ return `Player ${aid}`; } })();
      const f = parseLocalInput(document.getElementById('from').value);
      const t = parseLocalInput(document.getElementById('to').value);
      let rangeDays = 30; if(f && t && t>f){ rangeDays = Math.max(1, Math.round((t - f)/86400)); }
      // Open a prefilled GitHub issue in a new tab
      const repo = 'Zeroks77/Kret_Dota';
      const title = encodeURIComponent(`Generate user report: ${name} (${aid})`);
      const body = encodeURIComponent(`Please generate a user report.\n\nName: ${name}\nAccountId: ${aid}\nRangeDays: ${rangeDays}\n`);
      const labels = encodeURIComponent('user-report');
      const url = `https://github.com/${repo}/issues/new?title=${title}&labels=${labels}&body=${body}`;
      window.open(url, '_blank', 'noopener');
    }); }
  }catch(_e){}
  quick.addEventListener('change', async ()=>{
    const v=quick.value;
    const now = Math.floor(Date.now()/1000);
    let fromUnix=0;
    if(v==='30') fromUnix = now - 30*86400; else if(v==='60') fromUnix = now - 60*86400; else if(v==='120') fromUnix = now - 120*86400; else if(v==='patch'){
      try{ const patch=await fetch('https://api.opendota.com/api/constants/patch',{cache:'force-cache'}).then(r=>r.json());
        let latest=0; for(const k in patch){ const it=patch[k]; const d = typeof it.date==='number' ? it.date : Date.parse(it.date)/1000; if(!isNaN(d) && d>latest) latest=d; }
        fromUnix = latest||0;
  }catch(_e){ fromUnix=0; }
    } else if(v==='all'){ fromUnix = 0; }
    from.value = toLocalInput(fromUnix); to.value = toLocalInput(now);
    // Auto-apply when quick changes for instant feedback
    apply();
  });

  // Initialize inputs to last 30 days
  const now = Math.floor(Date.now()/1000);
  // URL params support: ?range=30|60|120|patch|all or ?from=...&to=... (epoch or YYYY-MM-DD)
  (function initFromUrl(){
    const sp = new URLSearchParams(location.search);
    const pr = sp.get('range');
    const pf = sp.get('from');
    const pt = sp.get('to');
    const ptab = sp.get('tab');
  const plock = sp.get('lock') || sp.get('readonly') || sp.get('ui');
  const paid = sp.get('aid') || sp.get('account') || sp.get('player');
  __focusAid = paid ? Number(paid) : 0;
  const uonly = sp.get('uonly') || sp.get('useronly') || sp.get('only');
  __userOnlyAid = (__focusAid>0 && uonly && String(uonly).toLowerCase()!=='0' && String(uonly).toLowerCase()!=='false') ? __focusAid : 0;
    function parseDateish(s){ if(!s) return NaN; if(/^\d{10}$/.test(s)) return Number(s); const ms = Date.parse(s); return isNaN(ms)? NaN : Math.floor(ms/1000); }
    let fux = NaN, tux = NaN;
    if(pf||pt){ fux = parseDateish(pf); tux = parseDateish(pt); }
    if(isFinite(fux) || isFinite(tux)){
      const f2 = isFinite(fux)? fux : 0; const t2 = isFinite(tux)? tux : now;
      from.value = toLocalInput(f2); to.value = toLocalInput(t2);
      quick.value = '';
    } else if(pr){
      quick.value = pr;
      const event = new Event('change'); quick.dispatchEvent(event);
    } else {
      from.value = toLocalInput(now - 30*86400);
      to.value   = toLocalInput(now);
      quick.value='30';
    }
  // Optional: open requested tab. If focusing a player, default to Players tab.
  if(__focusAid>0 && window.__dvShowTab){ window.__dvShowTab('players'); }
  else if(ptab && window.__dvShowTab){ window.__dvShowTab(ptab); }
  else {
    try{ const last = localStorage.getItem('dv_tab'); if(last && window.__dvShowTab){ window.__dvShowTab(last); } }catch(_e){}
  }
  // Preselect UI controls if provided
  try{ const sel=document.getElementById('playerFilter'); if(sel && __focusAid>0){ sel.value=String(__focusAid); } }catch(_e){}
    // Optional: hide controls for read-only/locked monthly wrappers
    if(plock && String(plock).toLowerCase() !== '0' && String(plock).toLowerCase() !== 'false'){
      try{ const controls = document.querySelector('.card.controls'); if(controls) controls.style.display='none'; }catch(_e){}
    }
  })();
  // If quick change handler didn’t apply yet, do it now
  if(!__subsetCache.length) apply();
}
enableSorting();
// ------- Awards logic (compute + render) -------
function computeAwardsFromDetails(details, heroMap){
  const res = {
    spaceCreator: [],
    objectiveGamer: [],
    earlyFarmer: [],
  clutchKing: [],
    courierAssassin: [],
    visionMvp: [],
    stackMaster: [],
    runeController: [],
  aegisSnatcher: [],
  // Extended awards
  disablerSupreme: [],
  throwMaster: [],
  ancientFarmer: [],
  medic: [],
  killLeader: [],
  assistArchitect: [],
  gpmKing: [],
  xpmKing: [],
  lastHitLord: [],
  denyDemon: [],
  damageDealer: [],
  buildingBreaker: [],
  laneDominator: [],
  runeMagnet: [],
  wardArchitect: [],
  visionDenier: [],
  stackMasterPlus: [],
  dustDetective: [],
  saviorPlays: [],
  spellSlinger: [],
  buybackBaron: [],
  smokeSupplier: [],
  sentryCfo: [],
  observerCeo: [],
  shardHunter: [],
  neutralHoarder: [],
  ancientAnnihilator: [],
  towerTerminator: [],
  firstBloodHunter: [],
  rampageCollector: [],
  spreeLegend: [],
  spellDamageSpecialist: [],
  rightClickRoyalty: [],
  bottleService: [],
  urnSpiritMvp: [],
  lotusLawyer: [],
  glimmerGuardian: [],
  forceMaster: [],
  blinkJunkie: [],
  // Fun extras
  feedingFrenzy: [],
  oneHitWonder: [],
  assistMachine: [],
  captainObvious: [],
  shopaholic: [],
  noTpClub: [],
  invisibleMan: [],
  bountyHunterIRL: [],
  dieHard: [],
  afkFarmer: [],
  // removed: tipSpammer (award dropped)
  roshanTourist: [],
  fountainDiver: [],
  bottleHoarder: [],
  jungleEnthusiast: [],
  };
  const nameCache = new Map();
  function sideOf(slot){ return (Number(slot)<128)? 'Radiant' : 'Dire'; }
  // Aggregates
  // Heuristic ability name sets (lowercase) for ultimates and wave-clear spells
  const ULT_SET = new Set([
    'abaddon_borrowed_time','alchemist_chemical_rage','ancient_apparition_ice_blast','antimage_mana_void','axe_culling_blade','bane_fiends_grip','batrider_flaming_lasso','beastmaster_primal_roar','bloodseeker_rupture','brewmaster_primal_split','bristleback_warpath','broodmother_insatiable_hunger','centaur_hoof_stomp'? '': '',
    'centaur_stampede','chaos_knight_phantasm','chen_hand_of_god','clinkz_burning_army','clockwerk_overclocking','crystal_maiden_freezing_field','dark_seer_wall_of_replica','dark_willow_bedlam','dawnbreaker_solar_guardian','dazzle_bad_juju','death_prophet_exorcism','disruptor_static_storm','doom_bringer_doom','dragon_knight_elder_dragon_form','drow_ranger_marksmanship','earthshaker_echo_slam','elder_titan_earth_splitter','ember_spirit_fire_remnant','enchantress_natures_attendants','enigma_black_hole','faceless_void_chronosphere','furion_wrath_of_nature','grimstroke_soulbind','gyrocopter_call_down','hoodwink_sharpshooter','huskar_life_break','invoker_cataclysm','jakiro_macropyre','juggernaut_omni_slash','keeper_of_the_light_will_o_wisp','kunkka_ghostship','legion_commander_duel','leshrac_pulse_nova','lich_chain_frost','life_stealer_infest','lina_laguna_blade','lion_finger_of_death','lone_druid_true_form','luna_eclipse','lycan_shapeshift','magnataur_reverse_polarity','mars_arena_of_blood','medusa_stone_gaze','meepo_divided_we_stand','monkey_king_wukongs_command','morphling_morph_replicate','muerta_pierce_the_veil','naga_siren_song_of_the_siren','necrolyte_reapers_scythe','nevermore_requiem','night_stalker_darkness','nyx_assassin_vendetta','ogre_magi_multicast','omniknight_guardian_angel','oracle_false_promise','obsidian_destroyer_sanity_eclipse','pangolier_rolling_thunder','phantom_assassin_phantom_strike'? '': '',
    'phantom_assassin_fan_of_knives','phantom_lancer_wall_doppelganger'? '': '', 'phoenix_supernova','primal_beast_pulverize','puck_dream_coil','pudge_dismember','pugna_life_drain','queenofpain_sonic_wave','rattletrap_overclocking','razor_eye_of_the_storm','riki_smoke_screen'? '': '', 'rubick_spell_steal','sandking_epicenter','shadow_demon_demonic_purge','shadow_shaman_mass_serpent_ward','silencer_global_silence','skeleton_king_reincarnation','skywrath_mage_mystic_flare','slardar_corrosive_haze'? '': '', 'slark_shadow_dance','sniper_assassinate','spectre_haunt','spirit_breaker_nether_strike','storm_spirit_ball_lightning','sven_gods_strength','techies_remote_mines','templar_assassin_psionic_projection'? '': '', 'terrorblade_metamorphosis','tidehunter_ravage','tinker_rearm','tiny_grow','treant_overgrowth','troll_warlord_battle_trance','tusk_walrus_punch','undying_flesh_golem','ursa_enrage','vengefulspirit_nether_swap','venomancer_poison_nova','viper_viper_strike','visage_summon_familiars','void_spirit_astral_step','warlock_rain_of_chaos','weaver_time_lapse','windrunner_focusfire','winter_wyvern_winters_curse','witch_doctor_death_ward','zuus_thundergods_wrath'
  ].filter(Boolean));
  const WAVE_SET = new Set([
    'nevermore_shadowraze1','nevermore_shadowraze2','nevermore_shadowraze3','lina_dragon_slave','crystal_maiden_crystal_nova','puck_illusory_orb','puck_waning_rift','queenofpain_scream_of_pain','keeper_of_the_light_illuminate','leshrac_split_earth','leshrac_pulse_nova','sandking_burrowstrike','sandking_sand_storm','tidehunter_anchor_smash','abyssal_underlord_firestorm','tinker_march_of_the_machines','jakiro_dual_breath','jakiro_macropyre','death_prophet_carrion_swarm','ember_spirit_sleight_of_fist','kunkka_torrent','gyrocopter_rocket_barrage','medusa_mystic_snake','bristleback_quill_spray','hoodwink_acorn_shot','storm_spirit_static_remnant','razor_plasma_field','magnataur_shockwave','pangolier_swashbuckle','underlord_firestorm','snapfire_scatterblast','zeus_arc_lightning'
  ]);
  const deathsWon = new Map();               // aid -> total deaths in wins
  const deathsWonGames = new Map();          // aid -> [{match_id, deaths}]
  const towerDmg = new Map();                // aid -> sum tower_damage
  const roshPart = new Map();                // aid -> roshan participations
  const runesCount = new Map();              // aid -> total runes
  const courierKills = new Map();            // aid -> courier_kills
  const stacks = new Map();                  // aid -> camps_stacked
  const wardScore = new Map();               // aid -> warding + dewarding score
  const earlyBest = new Map();               // aid -> best networth @10
  const aegisStolen = new Map();             // aid -> aegis snatches
  const dmgTaken = new Map();                // aid -> hero_damage_taken
  const ultCastSum = new Map();              // total ultimate casts across matches
  const zeroUltMatches = new Map();          // matches with 0 ult casts
  const waveClear = new Map();               // heuristic wave-clear damage via AoE spells
  // Clutch King accumulators
  const clutchKA = new Map();                // aid -> sum of (kills+assists) in last 10%
  const clutchTeamK = new Map();             // aid -> sum of team kills in same period (denominator)
  // Missing awards aggregates
  const bkbUses = new Map();                 // black_king_bar uses
  const clarityUses = new Map();             // clarity uses
  const creepVac = new Map();                // lane_kills + neutral_kills
  const csPerMinBest = new Map();            // best CS/min across matches
  const backpacker = new Map();              // total items in backpack slots at EoG
  const comebackKing = new Map();            // matches with >=10k comeback wins
  // Request: additional awards
  const firstPurchase = new Map();           // earliest purchase time
  const emptySlots = new Map();              // max empty slots at >=40m
  const gemPurch = new Map();                // gems purchased
  const highFive = new Map();                // high five uses
  const illusionCasts = new Map();           // illusions from manta/abilities
  const kdaBest = new Map();                 // best (K+A)/D per player
  const mangoUses = new Map();               // mango uses
  const midasUses = new Map();               // midas uses
  const megaTier = new Map();                // max multi-kill tier (2..5)
  // More requested awards
  const rapierPurch = new Map();             // divine rapier purchases (purchases + logs)
  const refresherUse = new Map();            // refresher and refresher shard uses
  const rootCasts = new Map();               // casts of root-inducing abilities
  const hasteRunes = new Map();              // haste rune pickups
  const salveUse = new Map();                // healing salve uses
  const soloNoAssistKills = new Map();       // kills in matches with 0 assists
  const splitPush = new Map();               // barracks + tower damage
  const swingBest = new Map();               // best (gold_delta + xp_delta) in any teamfight
  const tipRecv = new Map();                 // tips received
  const selfDestructDeaths = new Map();      // deaths to neutral creeps
  const silenceCasts = new Map();            // casts of silence abilities
  // Additional requested awards
  const throwCount = new Map();              // matches with >=10k lead but lost (per player)
  const healBlock = new Map();               // Spirit Vessel uses + AA Ice Blast casts
  const laneFreeze10 = new Map();            // best denies at 10:00 (dn_t[10])
  const laughMsgs = new Map();               // laugh-like chat messages
  const lateFirst = new Map();               // latest first purchase time
  const neutralActives = new Map();          // aid -> Set of distinct neutral items interacted with
  // removed: pauses (award dropped)
  // Extended aggregates for additional awards
  const stunsSum = new Map();                // total stun duration
  const ancientSum = new Map();              // ancient kills for tiebreak
  const neutralSum = new Map();              // neutral kills for tiebreaks
  const healHero = new Map();                // hero healing
  const killsSum = new Map();                // kills
  const assistsSum = new Map();              // assists
  const gpmBest = new Map();                 // best GPM per player
  const xpmBest = new Map();                 // best XPM per player
  const lastHits = new Map();                // last hits
  const denies = new Map();                  // denies
  const heroDmg = new Map();                 // hero damage
  const laneEffBest = new Map();             // best lane efficiency
  const runePickups = new Map();             // rune pickups
  const wardsPlaced = new Map();             // observers + sentries placed
  const wardsKilled = new Map();             // wards killed
  const dustDetect = new Map();              // dust purchases/uses
  const saviorUses = new Map();              // force/glimmer/lotus uses
  const abilityCasts = new Map();            // ability casts total
  const buybacks = new Map();                // buybacks total
  const tps = new Map();                     // tp scroll uses
  const smokePurch = new Map();              // smokes purchased
  const sentryPurch = new Map();             // sentries purchased
  const observerPurch = new Map();           // observers purchased
  const shardGot = new Map();                // shard received w/o purchase
  // Heuristic mapping of OpenDota permanent_buff ids that indicate owning Aghanim's Shard.
  // Observed ids in this dataset include 12 and 13 (and occasionally 16). This may vary by patch.
  const SHARD_BUFF_IDS = new Set([12, 13, 16]);
  const neutralKills = new Map();            // neutral kills
  const ancientKills = new Map();            // ancient kills
  const towerKillEvents = new Map();         // tower kills credited via objectives
  const firstBloods = new Map();             // first bloods via objectives
  const rampageCount = new Map();            // total rampages (5x multi-kills)
  const spreeMax = new Map();                // longest kill spree across matches
  // removed: streaksEnded (award dropped)
  const spellDamage = new Map();             // spell damage
  const rightClickDmg = new Map();           // right-click damage
  const outpostCaptures = new Map();         // capture events (outpost etc)
  const bottlePurch = new Map();             // bottle purchases
  const tomeCount = new Map();               // tomes used/purchased
  const urnSpiritUses = new Map();           // urn + spirit vessel uses
  const lotusUses = new Map();               // lotus orb uses
  const glimmerUses = new Map();             // glimmer cape uses
  const forceUses = new Map();               // force staff uses
  const blinkUses = new Map();               // blink uses
  // --- New aggregates for extra awards ---
  const maxDeathsSingle = new Map();         // highest deaths in a single match
  const oneKillWins = new Map();             // matches with exactly 1 kill and win
  const totAssists = new Map();              // total assists (for A/D ratio)
  const totDeaths = new Map();               // total deaths (for A/D ratio)
  const chatCount = new Map();               // chat messages per player
  const maxPurchases = new Map();            // max purchase_log length per player
  const noTpCount = new Map();               // matches >30m with 0 TP
  const invisCount = new Map();              // invis actions: glimmer + sb + invis rune
  const bountyRunes = new Map();             // bounty runes picked
  const maxDeathGap = new Map();             // longest single death duration approx (legacy)
  const deadTimeTotal = new Map();           // total time spent dead across matches (seconds)
  const deadTimeBest = new Map();            // longest time spent dead in a single match (seconds)
  const afkFarm = new Map();                 // matches with GPM>600 & hero_damage<10k
  // removed: tipCount (award dropped)
  // removed: voicelineCounts (chatwheel)
  const roshAllKillsKiller = new Map();      // matches where player killed all team roshes
  const fountainDeaths = new Map();          // deaths to enemy fountain
  const bottleUses = new Map();              // bottle item uses
  const jungleScore = new Map();             // neutral_kills + camps_stacked

  for(const md of details){ if(!md) continue; const isRadWin = !!md.radiant_win;
    // Normalize players and synthesize player_slot if missing
    let players = Array.isArray(md.players)? md.players: [];
    const hasSlotsA = players.some(p=>p && p.player_slot!==undefined);
    if(!hasSlotsA){
      const rA=[]; const dA=[];
      for(const p of players){ if(p && (p.isRadiant===true || p.is_radiant===true)) rA.push(p); else dA.push(p); }
      rA.forEach((p,i)=> p.player_slot = i);
      dA.forEach((p,i)=> p.player_slot = 128+i);
      players = [...rA, ...dA];
    }
    // Helpers per match
  const slotToAid = new Map();
  for(const p of players){ const aid=Number(p.account_id||0); if(aid>0) slotToAid.set(Number(p.player_slot), aid); }
    const matchDuration = Number(md.duration||0);
  for(const p of players){
      const aid = Number(p.account_id||0); if(!(aid>0)) continue;
      const side = sideOf(p.player_slot);
      // cache name
      const nm = p.personaname || ('Player '+aid); nameCache.set(aid, nm);
      // deaths in wins (with per-game breakdown)
      const won = (side==='Radiant') ? isRadWin : !isRadWin;
      if(won){ const d = Number(p.deaths||0); if(d){ deathsWon.set(aid, (deathsWon.get(aid)||0)+d); if(!deathsWonGames.has(aid)) deathsWonGames.set(aid, []); deathsWonGames.get(aid).push({match_id:Number(md.match_id||0), deaths:d}); } }
      // tower damage
      towerDmg.set(aid, (towerDmg.get(aid)||0) + Number(p.tower_damage||0));
      // warding score: place + deward (support multiple key variants and fallback to killed map)
      const placedWs = Number(p.obs_placed||0) + Number(p.sen_placed||0);
      let killedWs = 0;
      if(p.obs_killed!=null || p.sen_killed!=null || p.obs_kills!=null || p.sen_kills!=null){
        killedWs = Number(p.obs_killed||p.obs_kills||0) + Number(p.sen_killed||p.sen_kills||0);
      } else {
        try{
          const kmap = p.killed || {};
          killedWs = Number(kmap['npc_dota_observer_wards']||0) + Number(kmap['npc_dota_sentry_wards']||0);
        }catch(_e){ killedWs = 0; }
      }
      const ws = placedWs + killedWs;
      if(ws) wardScore.set(aid, (wardScore.get(aid)||0) + ws);
      // early farmer: networth @10:00 (gold_t index 10)
      const gt = Array.isArray(p.gold_t)? p.gold_t : [];
      const nw10 = Number(gt[10]||0);
      if(nw10>0){ const prev = earlyBest.get(aid)||0; if(nw10>prev) earlyBest.set(aid, nw10); }
  // purchase_log loaded below into plog2 for purchase-derived metrics
      const plog = Array.isArray(p.purchase_log)? p.purchase_log:[]; // retained for first/late purchase timings
  // earliest first purchase (for Fast First Purchase) and latest (for Late Comer)
  {
    // Helper: return item cost from OpenDota constants if available
    const itemCost = (key)=>{
      try{
        const items = window.__opendotaItems || (window.__opendotaConstants && window.__opendotaConstants.items);
        const k = String(key||'').toLowerCase();
        const rec = items && (items[k] || items[`item_${k}`]);
        const c = rec && (rec.cost!=null ? Number(rec.cost) : Number(rec.item_cost));
        return isFinite(c) ? c : null;
      }catch(_e){ return null; }
    };
    const COST_THRESHOLD = 1000;
    let tMin = Infinity;
    if(plog.length){
      for(const it of plog){
        const k = String(it && it.key || '').toLowerCase();
        if(!k) continue;
        const c = itemCost(k);
        if(c==null || c <= COST_THRESHOLD) continue;
        const t = Number((it && (it.time!=null ? it.time : it.time_sec)) || Infinity);
        if(isFinite(t) && t < tMin) tMin = t;
      }
    }
    // Fallback A: use first_purchase_time object (filter by item cost)
    if(!isFinite(tMin)){
      const fpt = (p && (p.first_purchase_time || p.first_purchase_time2)) || null;
      if(fpt && typeof fpt === 'object'){
        for(const [k,v] of Object.entries(fpt)){
          const c = itemCost(k);
          if(c==null || c <= COST_THRESHOLD) continue;
          const t = Number(v);
          if(isFinite(t) && t < tMin) tMin = t;
        }
      }
    }
    // Fallback B: use purchase_time map if present (filter by item cost)
    if(!isFinite(tMin)){
      const pt = (p && p.purchase_time) || null;
      if(pt && typeof pt === 'object'){
        for(const [k,v] of Object.entries(pt)){
          const c = itemCost(k);
          if(c==null || c <= COST_THRESHOLD) continue;
          const t = Number(v);
          if(isFinite(t) && t < tMin) tMin = t;
        }
      }
    }
    if(isFinite(tMin)){
      const prevMin = firstPurchase.get(aid);
      if(prevMin==null || tMin<prevMin) firstPurchase.set(aid, tMin);
      const prevMax = lateFirst.get(aid)||-Infinity;
      if(tMin>prevMax) lateFirst.set(aid, tMin);
    }
  }
  // BKB and Clarity uses
  { const iu = p.item_uses||{}; const bkb = Number(iu.black_king_bar||0); if(bkb) bkbUses.set(aid, (bkbUses.get(aid)||0)+bkb); const cl = Number(iu.clarity||0); if(cl) clarityUses.set(aid, (clarityUses.get(aid)||0)+cl); }
      // Mango & Midas uses
      { const iu = p.item_uses||{}; const mg = Number(iu.enchanted_mango||0); if(mg) mangoUses.set(aid, (mangoUses.get(aid)||0)+mg); const mi = Number(iu.hand_of_midas||0); if(mi) midasUses.set(aid, (midasUses.get(aid)||0)+mi); }
  // Heal Blocker proxy: Spirit Vessel uses + AA Ice Blast casts
  { const iu = p.item_uses||{}; const au = p.ability_uses||{}; let hb = Number(iu.spirit_vessel||0); hb += Number(au.ancient_apparition_ice_blast||0) + Number(au.ancient_apparition_ice_blast_release||0); if(hb){ healBlock.set(aid, (healBlock.get(aid)||0)+hb); } }
  // High five uses (prefer ability_uses.plus_high_five; also accept item_uses.high_five if present)
  { const iu = p.item_uses||{}; const au = p.ability_uses||{}; const hf = Number(au.plus_high_five||0) + Number(iu.high_five||0); if(hf) highFive.set(aid, (highFive.get(aid)||0)+hf); }
      // Gem purchases
      { const purch = p.purchase||{}; const base = Number(purch.gem_of_true_sight||0); const extra = plog.reduce((a,it)=> a + ((String(it.key||'').toLowerCase().includes('gem')||String(it.key||'').toLowerCase()==='gem_of_true_sight')?1:0), 0); const tot = base + extra; if(tot) gemPurch.set(aid, (gemPurch.get(aid)||0)+tot); }
      // Illusion commander: manta + abilities
      { const iu = p.item_uses||{}; const au = p.ability_uses||{}; let val = Number(iu.manta||0); for(const k in (au||{})){ const lk = String(k||'').toLowerCase(); if(lk.includes('phantasm')||lk.includes('mirror_image')||lk.includes('doppel')||lk.includes('conjure_image')){ val += Number(au[k]||0); } } if(val) illusionCasts.set(aid, (illusionCasts.get(aid)||0)+val); }
      // Rapier Gambler: Divine Rapier purchases
      { const purch = p.purchase||{}; const base = Number(purch.divine_rapier||0); const plog = Array.isArray(p.purchase_log)? p.purchase_log:[]; const extra = plog.reduce((a,it)=> a + (String(it.key||'').toLowerCase()==='divine_rapier'?1:0), 0); const tot=base+extra; if(tot){ rapierPurch.set(aid, (rapierPurch.get(aid)||0)+tot); } }
      // Refresher Fiend: refresher and refresher shard uses
      { const iu = p.item_uses||{}; const val = Number(iu.refresher||0) + Number(iu.refresher_shard||0); if(val){ refresherUse.set(aid, (refresherUse.get(aid)||0)+val); } }
      // Silence Master (ability casts that silence) and Root Lord (ability casts that root)
      { const au = p.ability_uses||{}; let s=0, r=0; for(const [k,v] of Object.entries(au||{})){ const key=String(k||'').toLowerCase(); const val=Number(v||0); if(!val) continue; if(/silence|global_silence|last_word|ancient_seal|crippling_fear|drow_silence|trickshot_silence|arcane_curse/.test(key)) s+=val; if(/root|overgrowth|entangle|searing_chains|frostbite|ensnare|spirit_bear_entangle|rod_of_atos/.test(key)) r+=val; }
        if(s) silenceCasts.set(aid,(silenceCasts.get(aid)||0)+s); if(r) rootCasts.set(aid,(rootCasts.get(aid)||0)+r); }
      // Salve Savior: healing salve uses (support both keys 'healing_salve' and 'flask'; fall back to ability_uses and purchases if needed)
      { const iu = p.item_uses||{}; const au = p.ability_uses||{};
        let val = Number(iu.healing_salve||0) + Number(iu.flask||0);
        if(!val){ val += Number(au.healing_salve||0) + Number(au.flask||0); }
        if(!val){ const pl = Array.isArray(p.purchase_log)? p.purchase_log:[]; val = pl.reduce((a,it)=> a + (String(it.key||'').toLowerCase()==='flask'?1:0), 0); }
        if(val){ salveUse.set(aid, (salveUse.get(aid)||0)+val); }
      }
      // KDA best per match
      { const k = Number(p.kills||0), a = Number(p.assists||0), d = Math.max(1, Number(p.deaths||0)); const kda = (k+a)/d; if(k>0 || a>0){ const prev = kdaBest.get(aid)||0; if(kda>prev) kdaBest.set(aid, Number(kda.toFixed(2))); } }
      // Mega Kill Maestro: highest tier seen
      { const mk = p.multi_kills||{}; let tmax = 0; for(const t of ['5','4','3','2']){ if(Number(mk[t]||0)>0){ tmax = Math.max(tmax, Number(t)); break; } } if(tmax>0){ const prev = megaTier.get(aid)||0; if(tmax>prev) megaTier.set(aid, tmax); } }
      // Lane Freezer: best denies @10:00 (dn_t[10] if available; fallback to total denies)
      { let v = 0; if(Array.isArray(p.dn_t)) v = Number(p.dn_t[10]||0); else v = Number(p.denies||0); if(v>0){ const prev = laneFreeze10.get(aid)||0; if(v>prev) laneFreeze10.set(aid, v); } }
      // Empty slots at >=40:00
      { const dur = Number(md.duration||0)||0; if(dur>=2400){ const slots = [p.item_0,p.item_1,p.item_2,p.item_3,p.item_4,p.item_5]; const filled = slots.reduce((acc,it)=> acc + ((Number(it||0)>0)?1:0), 0); const empty = 6 - filled; if(empty>0){ const prev = emptySlots.get(aid)||0; if(empty>prev) emptySlots.set(aid, empty); } } }
  // Split Pusher: tower + barracks damage
  { const val = Number(p.tower_damage||0) + Number(p.barracks_damage||0); if(val){ splitPush.set(aid, (splitPush.get(aid)||0)+val); } }
      // Neutral Item Juggler: count distinct neutral item interactions (active uses + final held)
      { const iu = p.item_uses||{}; let set = neutralActives.get(aid); if(!set){ set = new Set(); neutralActives.set(aid, set); }
        const activeNeutralKeys = ['trusty_shovel','pig_pole','flicker','ninja_gear','fallen_sky','mirror_shield','ex_machina','book_of_shadows','pirate_hat','seer_stone','ascetic_cap','trickster_cloak','stormcrafter','martyrs_plate','giants_ring','mind_breaker','telescope','repair_kit','woodland_striders','ballista','arcanist_armor','gladiator_helm','defiant_shell','dagger_of_ristul','force_boots','witless_shako','spell_prism','quicksilver_amulet','vampire_fangs','pupils_gift','philosophers_stone','misericorde','oracle_lens','eye_of_the_vizier','specialists_array','dandelion_amulet','nethershawl','penta_edged_sword','ogre_seal_totem'];
        for(const k of activeNeutralKeys){ if(Number(iu[k]||0)>0) set.add(k); }
        const nid = Number(p.item_neutral||0); if(nid>0) set.add('id:'+nid);
      }
      // runes taken
      const runes = p.runes||{}; const sumRunes = Object.values(runes).reduce((a,b)=>a+Number(b||0),0);
      if(sumRunes) runesCount.set(aid, (runesCount.get(aid)||0)+sumRunes);
      // courier kills
      const ck = Number(p.courier_kills||0); if(ck) courierKills.set(aid, (courierKills.get(aid)||0)+ck);
  // damage taken: prefer hero_damage_taken; fallback to sum of damage_taken from heroes
  {
    let hdt = Number(p.hero_damage_taken||0);
    if(!hdt){
      try{
        const dt = p.damage_taken || {};
        // Sum only damage from heroes (keys like npc_dota_hero_*)
        hdt = Object.entries(dt).reduce((acc, [k, v])=> acc + (/npc_dota_hero_/i.test(String(k)) ? Number(v)||0 : 0), 0);
      }catch(_e){ hdt = 0; }
    }
    if(hdt){ dmgTaken.set(aid, (dmgTaken.get(aid)||0) + hdt); }
  }
      // Heuristic ult casts this match and wave-clear damage
      { const au = p.ability_uses||{}; let u=0; for(const [k,v] of Object.entries(au||{})){ const key=String(k||'').toLowerCase(); if(ULT_SET.has(key)) u += Number(v||0); }
        if(u>0){ ultCastSum.set(aid, (ultCastSum.get(aid)||0)+u); } else { zeroUltMatches.set(aid, (zeroUltMatches.get(aid)||0)+1); }
        const di = p.damage_inflictor||{}; let w=0; for(const [k,v] of Object.entries(di||{})){ const key=String(k||'').toLowerCase(); if(WAVE_SET.has(key)) w += Number(v||0); } if(w>0){ waveClear.set(aid, (waveClear.get(aid)||0)+w); }
      }
      // stacks
      const st = Number(p.camps_stacked||0); if(st) stacks.set(aid, (stacks.get(aid)||0)+st);
  // creep vacuum: lane + neutral kills
  { const cv = Number(p.lane_kills||0) + Number(p.neutral_kills||0); if(cv) creepVac.set(aid, (creepVac.get(aid)||0)+cv); }
  // CS per minute: last hits / minutes (best per player)
  { const dur = Math.max(1, Number(md.duration||0)); const lhv = Number(p.last_hits||0); const rate = lhv / (dur/60); if(rate>0){ const prev = csPerMinBest.get(aid)||0; if(rate>prev) csPerMinBest.set(aid, rate); } }
  // Backpacker: count non-empty backpack slots at EoG
  { const b0 = p.backpack_0, b1=p.backpack_1, b2=p.backpack_2; const nonEmpty = [b0,b1,b2].reduce((acc,v)=> acc + ((v!==undefined && v!==null && Number(v)!==0)?1:0), 0); if(nonEmpty) backpacker.set(aid, (backpacker.get(aid)||0)+nonEmpty); }
  // ---- Extended aggregates ----
  // stuns
  const stunDur = Number(p.stuns||0); if(stunDur) stunsSum.set(aid, (stunsSum.get(aid)||0)+stunDur);
  // ancients / neutrals
  const anc = Number(p.ancient_kills||0); if(anc){ ancientSum.set(aid, (ancientSum.get(aid)||0)+anc); ancientKills.set(aid, (ancientKills.get(aid)||0)+anc); }
  const neu = Number(p.neutral_kills||0); if(neu){ neutralSum.set(aid, (neutralSum.get(aid)||0)+neu); neutralKills.set(aid, (neutralKills.get(aid)||0)+neu); }
  // healing to heroes
  const hHeal = Number(p.hero_healing||0); if(hHeal) healHero.set(aid, (healHero.get(aid)||0)+hHeal);
  // core stats
  const ksum = Number(p.kills||0); if(ksum) killsSum.set(aid, (killsSum.get(aid)||0)+ksum);
  const asum = Number(p.assists||0); if(asum) assistsSum.set(aid, (assistsSum.get(aid)||0)+asum);
  const gpm = Number(p.gold_per_min||0); if(gpm>0){ const prev=gpmBest.get(aid)||0; if(gpm>prev) gpmBest.set(aid, gpm); }
  const xpm = Number(p.xp_per_min||0); if(xpm>0){ const prev=xpmBest.get(aid)||0; if(xpm>prev) xpmBest.set(aid, xpm); }
  const lh = Number(p.last_hits||0); if(lh) lastHits.set(aid, (lastHits.get(aid)||0)+lh);
  const dn = Number(p.denies||0); if(dn) denies.set(aid, (denies.get(aid)||0)+dn);
  const hd = Number(p.hero_damage||0); if(hd) heroDmg.set(aid, (heroDmg.get(aid)||0)+hd);
  // lane efficiency
  const lep = Number(p.lane_efficiency_pct||0); if(lep>0){ const prev=laneEffBest.get(aid)||0; if(lep>prev) laneEffBest.set(aid, lep); }
  // runes pickups
  const rp = Number(p.rune_pickups||0); if(rp) runePickups.set(aid, (runePickups.get(aid)||0)+rp);
  // wards placed/killed
  const placed = Number(p.obs_placed||0)+Number(p.sen_placed||0); if(placed) wardsPlaced.set(aid, (wardsPlaced.get(aid)||0)+placed);
  let killed = 0;
  // Prefer explicit counters (support both *killed and *kills variants)
  if(p.obs_killed!=null || p.sen_killed!=null || p.obs_kills!=null || p.sen_kills!=null){
    killed = Number(p.obs_killed||p.obs_kills||0) + Number(p.sen_killed||p.sen_kills||0);
  } else if(p && typeof p.killed === 'object' && p.killed){
    // Fallback: derive from generic killed map
    killed = Number(p.killed['npc_dota_observer_wards']||0) + Number(p.killed['npc_dota_sentry_wards']||0);
  } else if(Array.isArray(p.wards)){
    // Last resort: some APIs expose a per-ward log; count removals
    killed = p.wards.reduce((acc,w)=> acc + (String(w.type||'').includes('destroyed')?1:0), 0);
  }
  if(killed) wardsKilled.set(aid, (wardsKilled.get(aid)||0)+killed);
  // purchases/logs/uses
  const plog2 = Array.isArray(p.purchase_log)? p.purchase_log:[];
  const uses = p.item_uses||{}; const purch = p.purchase||{};
  // Rune: haste pickups
  { const runes = p.runes||{}; const h = Number(runes['0']||runes.haste||0); if(h){ hasteRunes.set(aid, (hasteRunes.get(aid)||0)+h); } }
  // dust purchases + uses (support both 'dust' and 'dust_of_appearance' variants)
  const dustPurchases = plog2.reduce((acc,it)=>{
    const k = String(it.key||'').toLowerCase();
    return acc + ((k==='dust_of_appearance' || k==='dust') ? 1 : 0);
  }, 0);
  const aUses2 = p.ability_uses||{};
  const dustItemUses = Number(uses.dust_of_appearance||0) + Number(uses.dust||0);
  const dustAbilityUses = Number(aUses2.dust_of_appearance||0) + Number(aUses2.dust||0);
  // Prefer item uses when available; otherwise fall back to ability uses to avoid double counting
  const dustUses = dustItemUses>0 ? dustItemUses : dustAbilityUses;
  const dustP = dustPurchases + dustUses;
  if(dustP) dustDetect.set(aid, (dustDetect.get(aid)||0)+dustP);
  // savior items uses (force/glimmer/lotus)
  const sav = Number(uses.force_staff||0)+Number(uses.glimmer_cape||0)+Number(uses.lotus_orb||0); if(sav) saviorUses.set(aid, (saviorUses.get(aid)||0)+sav);
  // ability casts
  const aUses = p.ability_uses||{}; const aSum = Object.values(aUses).reduce((a,b)=> a+Number(b||0), 0); if(aSum) abilityCasts.set(aid, (abilityCasts.get(aid)||0)+aSum);
  // buybacks / tps
  const bb = Number(p.buyback_count||0); if(bb) buybacks.set(aid, (buybacks.get(aid)||0)+bb);
  let tpv = Number(p.tp_count||0);
  if(!tpv){ const iu = p.item_uses||{}; tpv = Number(iu.tpscroll||0); }
  if(tpv) tps.set(aid, (tps.get(aid)||0)+tpv);
  // smoke purchases (also count as uses in our simple model)
  const smkCnt2 = plog2.reduce((acc,it)=> acc + (String(it.key||'').toLowerCase()==='smoke_of_deceit'?1:0), 0); if(smkCnt2) smokePurch.set(aid, (smokePurch.get(aid)||0)+smkCnt2);
  // sentry/observer purchases
  const sentFromPurch = Number(purch.ward_sentry||0);
  const sentFromLog = plog2.reduce((acc,it)=> acc + (String(it.key||'').toLowerCase()==='ward_sentry'?1:0), 0);
  const sentTotal = sentFromPurch + sentFromLog; if(sentTotal) sentryPurch.set(aid, (sentryPurch.get(aid)||0)+sentTotal);
  const obsFromPurch = Number(purch.observer_ward||0);
  const obsFromLog = plog2.reduce((acc,it)=> acc + ((String(it.key||'').toLowerCase()==='observer_ward'||String(it.key||'').toLowerCase()==='ward_observer')?1:0), 0);
  const obsTotal = obsFromPurch + obsFromLog; if(obsTotal) observerPurch.set(aid, (observerPurch.get(aid)||0)+obsTotal);
  // bottle / tome
  const bott = Number(purch.bottle||0) + plog2.reduce((a,it)=> a + (String(it.key||'').toLowerCase()==='bottle'?1:0), 0); if(bott) bottlePurch.set(aid, (bottlePurch.get(aid)||0)+bott);
  const tom = Number(purch.tome_of_knowledge||0) + Number(uses.tome_of_knowledge||0); if(tom) tomeCount.set(aid, (tomeCount.get(aid)||0)+tom);
  // urn / vessel / lotus / glimmer / force / blink uses
  const urnU = Number(uses.urn_of_shadows||0)+Number(uses.spirit_vessel||0); if(urnU) urnSpiritUses.set(aid, (urnSpiritUses.get(aid)||0)+urnU);
  const lotU = Number(uses.lotus_orb||0); if(lotU) lotusUses.set(aid, (lotusUses.get(aid)||0)+lotU);
  const gliU = Number(uses.glimmer_cape||0); if(gliU) glimmerUses.set(aid, (glimmerUses.get(aid)||0)+gliU);
  const forU = Number(uses.force_staff||0); if(forU) forceUses.set(aid, (forceUses.get(aid)||0)+forU);
  const bliU = Number(uses.blink||0)+Number(uses.blink_dagger||0); if(bliU) blinkUses.set(aid, (blinkUses.get(aid)||0)+bliU);
      // New awards collection
      // Feeding Frenzy: highest single-game deaths
      { const d = Number(p.deaths||0); const prev = maxDeathsSingle.get(aid)||0; if(d>prev) maxDeathsSingle.set(aid, d); }
      // One Hit Wonder: 1 kill and win
      { const ok = (Number(p.kills||0)===1) && won; if(ok) oneKillWins.set(aid, (oneKillWins.get(aid)||0)+1); }
  // Solo Artist: kills in matches with 0 assists
  { const assists = Number(p.assists||0); if(assists===0){ const klog = Array.isArray(p.kills_log)? p.kills_log: []; const val = klog.length>0 ? klog.length : Number(p.kills||0); if(val){ soloNoAssistKills.set(aid, (soloNoAssistKills.get(aid)||0)+val); } } }
      // Assist Machine inputs
      totAssists.set(aid, (totAssists.get(aid)||0) + Number(p.assists||0));
      totDeaths.set(aid, (totDeaths.get(aid)||0) + Number(p.deaths||0));
      // Shopaholic: track max purchase_log length seen
      { const len = Array.isArray(p.purchase_log)? p.purchase_log.length : 0; const prev = maxPurchases.get(aid)||0; if(len>prev) maxPurchases.set(aid, len); }
      // No TP Club: game > 30m and 0 tp
      { let tpv2 = Number(p.tp_count||0); if(!tpv2){ const iu=p.item_uses||{}; tpv2 = Number(iu.tpscroll||0); }
        if(matchDuration>1800 && tpv2===0){ noTpCount.set(aid, (noTpCount.get(aid)||0)+1); } }
      // Invisible Man: glimmer + shadow blade uses + invis rune pickups
      { const iu = p.item_uses||{}; const runes2 = p.runes||{}; const val = Number(iu.glimmer_cape||0) + Number(iu.invis_sword||0) + Number(runes2['3']||0); if(val){ invisCount.set(aid, (invisCount.get(aid)||0)+val); } }
      // Bounty Hunter IRL: bounty runes (id '5')
      { let val = 0; const runes2 = p.runes||{}; if(Object.keys(runes2).length){ val = Number(runes2['5']||0); }
        else if(Number(p.rune_pickups||0)>0 && Array.isArray(p.kills_log)){ /* no per-type map; skip */ }
        if(val){ bountyRunes.set(aid, (bountyRunes.get(aid)||0)+val); } }
      // Die Hard (new): time spent dead in this match (prefer exact life_state, otherwise estimate)
      { let dead=0; const ls = p.life_state||{}; if(ls && typeof ls==='object'){
          const l1 = Number(ls['1'] ?? ls[1] ?? 0); const l2 = Number(ls['2'] ?? ls[2] ?? 0);
          dead = (isFinite(l1)?l1:0) + (isFinite(l2)?l2:0);
        }
        // Fallback explicit counter if provided by parser
        if(p.life_state_dead!=null){ const d2 = Number(p.life_state_dead)||0; if(d2>dead) dead = d2; }
        // Estimation fallback when no life_state available
        if(dead===0){
          const dlog = Array.isArray(p.deaths_log)? p.deaths_log: [];
          const estRespawnAt = (t)=>{ const m = Math.max(0, Math.min(100, (Number(t)||0)/60)); return Math.max(12, Math.min(95, Math.round(10 + m*1.6 + (m>30? (m-30)*0.7:0)))); };
          if(dlog.length){ dead = dlog.reduce((acc,it)=> acc + estRespawnAt(it.time||it.time_stamp||0), 0); }
          else{
            const dcnt = Number(p.deaths||0); const m = Math.max(0, Number(matchDuration||0)/60);
            const avg = Math.max(15, Math.min(80, Math.round(10 + m*1.2))); dead = dcnt * avg;
          }
        }
        if(dead>0){
          deadTimeTotal.set(aid, (deadTimeTotal.get(aid)||0)+dead);
          const prev = deadTimeBest.get(aid)||0; if(dead>prev) deadTimeBest.set(aid, dead);
        }
      }
      // Legacy longest gap (kept as reference)
      { const dl = Array.isArray(p.deaths_log)? p.deaths_log.map(e=>Number(e.time||0)).sort((a,b)=>a-b) : [];
        let best=0;
        if(dl.length){ for(let i=0;i<dl.length;i++){ const cur = (i<dl.length-1) ? (dl[i+1]-dl[i]) : (matchDuration - dl[i]); if(cur>best) best=cur; } }
        else if(p.firstblood_time!=null){ // rough fallback: time since first death to end
          const fd = Number(p.firstblood_time)||0; if(matchDuration>fd) best = matchDuration - fd; }
        else if(matchDuration>0){ // heuristic fallback: lower bound using evenly spaced deaths
          const dcnt = Number(p.deaths||0); const segs = Math.max(1, dcnt+1); best = Math.max(best, Math.floor(matchDuration / segs)); }
        if(best>0){ const prev=maxDeathGap.get(aid)||0; if(best>prev) maxDeathGap.set(aid, best); } }
      // AFK Farmer: GPM > 600 and hero_damage < 10k
      { const gpmv=Number(p.gold_per_min||0), hdv=Number(p.hero_damage||0); if(gpmv>600 && hdv<10000){ afkFarm.set(aid, (afkFarm.get(aid)||0)+1); } }
      // Bottle Hoarder: bottle uses
      { const iu = p.item_uses||{}; const b = Number(iu.bottle||0); if(b){ bottleUses.set(aid, (bottleUses.get(aid)||0)+b); } }
      // Jungle Enthusiast: neutral kills + camps stacked
      { const score = Number(p.neutral_kills||0) + Number(p.camps_stacked||0); if(score){ jungleScore.set(aid, (jungleScore.get(aid)||0)+score); } }
      // rampages (5x multi-kills)
      const mk = p.multi_kills||{};
      const ramps = Number(mk['5']||0);
      if(ramps>0){ rampageCount.set(aid, (rampageCount.get(aid)||0)+ramps); }

      // longest kill spree within this match using kill/death logs
      const killsLog = (p.kills_log||[]).map(e=>e.time).sort((a,b)=>a-b);
      const deathsLog = (p.deaths_log||[]).map(e=>e.time).sort((a,b)=>a-b);
      let dIdx=0, cur=0, best=0;
      for(const kt of killsLog){
        while(dIdx<deathsLog.length && deathsLog[dIdx] <= kt){ cur=0; dIdx++; }
        cur++;
        if(cur>best) best=cur;
      }
      if(best>0){ const prev = spreeMax.get(aid)||0; if(best>prev) spreeMax.set(aid, best); }
  // streaks ended
  // removed: streaksEnded award (dropped)
  // damage inflictor separation
  const di = p.damage_inflictor||{}; const exclude = new Set(['null','attack','attack_debuff','generic']);
  let spell=0, right=0; for(const [k,v] of Object.entries(di)){ const key=String(k||'').toLowerCase(); const val=Number(v||0); if(!val) continue; if(exclude.has(key)) right+=val; else spell+=val; }
  if(spell) spellDamage.set(aid, (spellDamage.get(aid)||0)+spell);
  if(right) rightClickDmg.set(aid, (rightClickDmg.get(aid)||0)+right);
  // shard hunter heuristic
  const buffs = Array.isArray(p.permanent_buffs)? p.permanent_buffs:[];
  // Do not rely on stack_count>0 — in observed data shard buff can have stack_count = 0.
  // Recognize a set of possible ids to be resilient across patches.
  const hasShardBuff = buffs.some(b=> SHARD_BUFF_IDS.has(Number(b.permanent_buff)));
  const boughtShard = plog2.some(it=> String(it.key||'').toLowerCase()==='aghanims_shard') || Number((purch||{}).aghanims_shard||0)>0;
  if(hasShardBuff && !boughtShard) shardGot.set(aid, (shardGot.get(aid)||0)+1);
    }
  // Roshan participation: credit all players on the killing team, and capture other objective events
  const objectivesArr = Array.isArray(md.objectives) ? md.objectives : (Array.isArray(md.objectives_events)? md.objectives_events: []);
  const roshByTeamKillers = {Radiant:new Set(), Dire:new Set()}; let roshCountTeam = {Radiant:0, Dire:0};
  let hasCaptureObjective = false; // track if we saw explicit capture events to avoid double counting with fallback
  // removed tips/pauses awards
  for(const ev of objectivesArr){
      const t = String(ev.type||ev.key||'');
      if(/roshan_kill|CHAT_MESSAGE_ROSHAN_KILL/i.test(t)){
        const team = (Number(ev.team)===2||Number(ev.team)===0)? 'Radiant' : 'Dire';
        for(const p of (md.players||[])){
          if(p && ((Number(p.player_slot)<128)?'Radiant':'Dire')===team){ const id=Number(p.account_id||0); if(id>0) roshPart.set(id, (roshPart.get(id)||0)+1); }
        }
    roshCountTeam[team]++;
    const slot = Number(ev.player_slot);
    const killerAid = slotToAid.get(slot)||0; if(killerAid){ roshByTeamKillers[team].add(killerAid); }
      }
      // Aegis snatch
  if(/CHAT_MESSAGE_AEGIS_STOLEN/i.test(t)){ const slot=ev.player_slot; const p = players.find(x=>x.player_slot===slot); if(p){ const id=Number(p.account_id||0); if(id>0) aegisStolen.set(id, (aegisStolen.get(id)||0)+1); } }
  // removed Tip Receiver
      // Tower kills credited to player
  if(/CHAT_MESSAGE_TOWER_KILL|TOWER_KILL|building_kill/i.test(t)){ const slot=Number(ev.player_slot); const p=players.find(x=>Number(x.player_slot)===slot); const id=p?Number(p.account_id||0):0; if(id>0) towerKillEvents.set(id, (towerKillEvents.get(id)||0)+1); }
      // First blood event
  if(/CHAT_MESSAGE_FIRSTBLOOD|FIRST_BLOOD/i.test(t)){ const slot=Number(ev.player_slot); const p=players.find(x=>Number(x.player_slot)===slot); const id=p?Number(p.account_id||0):0; if(id>0) firstBloods.set(id, (firstBloods.get(id)||0)+1); }
      // Capture point (outpost etc)
  if(/CHAT_MESSAGE_CAPTURE_POINT|CAPTURE_POINT|OUTPOST_CAPTURE|CAPTURE/i.test(t)){ const slot=Number(ev.player_slot); const p=players.find(x=>Number(x.player_slot)===slot); const id=p?Number(p.account_id||0):0; if(id>0) outpostCaptures.set(id, (outpostCaptures.get(id)||0)+1); hasCaptureObjective = true; }
  // removed Tips and Pauses counting
    }
    // Fallback: if we couldn't attribute any captures via objective events, sum players' ability_capture from ability_uses
    if(outpostCaptures.size===0){
      for(const p of players){
        const aid = Number(p.account_id||0); if(!(aid>0)) continue;
        const au = p.ability_uses || {};
        // Primary signal observed in cached matches
        let cap = Number(au.ability_capture||0);
        // Optional: be tolerant to variations like ability_capture_* keys
        if(!cap){
          try{
            for(const [k,v] of Object.entries(au)){
              if(/ability_capture/i.test(String(k||''))) cap += Number(v||0);
            }
          }catch(_e){}
        }
        if(cap>0){ outpostCaptures.set(aid, (outpostCaptures.get(aid)||0) + cap); }
      }
    }
    // Roshan Tourist: unique killer for team across rosh kills
    for(const side of ['Radiant','Dire']){
      if(roshCountTeam[side]>0){
        if(roshByTeamKillers[side].size===1){
          const aid = Array.from(roshByTeamKillers[side])[0];
          roshAllKillsKiller.set(aid, (roshAllKillsKiller.get(aid)||0)+1);
        }else{
          // Fallback per-side: objectives exist but didn't attribute a single killer; use per-player roshan_kills to infer sole killer
          const totalTeam = roshCountTeam[side];
          const killers = new Map();
          for(const p of players){
            const aid = Number(p.account_id||0); if(!(aid>0)) continue;
            const pSide = ((Number(p.player_slot)<128)?'Radiant':'Dire');
            if(pSide!==side) continue;
            const rk = Number(p.roshan_kills||0); if(rk>0) killers.set(aid, (killers.get(aid)||0)+rk);
          }
          if(killers.size===1){
            const aid = Array.from(killers.keys())[0];
            roshAllKillsKiller.set(aid, (roshAllKillsKiller.get(aid)||0)+1);
          }else if(killers.size>1){
            // If one player matches the team's total count, credit them
            for(const [aid,ct] of killers.entries()){
              if(ct===totalTeam){ roshAllKillsKiller.set(aid, (roshAllKillsKiller.get(aid)||0)+1); break; }
            }
          }
        }
      }
    }
    // Comeback King & Throw Master using radiant_gold_adv or fallback from gold_t sums
    try{
      let adv = Array.isArray(md.radiant_gold_adv)? md.radiant_gold_adv.map(Number) : [];
      if(!adv.length){
        // Fallback: compute advantage from per-player gold_t
        const rGT=[]; const dGT=[];
        for(const p of players){
          const gt = Array.isArray(p.gold_t)? p.gold_t.map(Number):[];
          if(gt.length){ ((p.isRadiant===true || p.is_radiant===true || Number(p.player_slot)<128)? rGT : dGT).push(gt); }
        }
        const maxLen = Math.max(0, ...rGT.map(a=>a.length), ...dGT.map(a=>a.length));
        if(maxLen>0){
          const sumAt = (arr, i)=> arr.reduce((s,a)=> s + Number(a[Math.min(i, a.length-1)]||0), 0);
          const tmp=[]; for(let i=0;i<maxLen;i++){ tmp.push(sumAt(rGT,i) - sumAt(dGT,i)); }
          adv = tmp;
        }
      }
      if(adv.length){
        const minA = Math.min(...adv.filter(isFinite));
        const maxA = Math.max(...adv.filter(isFinite));
        if((minA<=-10000) && md.radiant_win){
          for(const p of players){ if(p && Number(p.player_slot)<128){ const id=Number(p.account_id||0); if(id>0) comebackKing.set(id, (comebackKing.get(id)||0)+1); } }
        }
        if((maxA>=10000) && !md.radiant_win){
          for(const p of players){ if(p && !(Number(p.player_slot)<128)){ const id=Number(p.account_id||0); if(id>0) comebackKing.set(id, (comebackKing.get(id)||0)+1); } }
        }
        // Throw Master: if team had >=10k lead at any point and still lost
        if((maxA>=10000) && !md.radiant_win){
          // Radiant had big lead but lost -> credit Radiant players
          for(const p of players){
            if(p && Number(p.player_slot)<128){ const id=Number(p.account_id||0); if(id>0) throwCount.set(id, (throwCount.get(id)||0)+1); }
          }
        }
        if((minA<=-10000) && md.radiant_win){
          // Dire had big lead but lost -> credit Dire players
          for(const p of players){
            if(p && !(Number(p.player_slot)<128)){ const id=Number(p.account_id||0); if(id>0) throwCount.set(id, (throwCount.get(id)||0)+1); }
          }
        }
      }
    }catch(_e){}
    // First Blood fallback: if not detected via objectives, derive from earliest kills_log entry
    try{
      if(firstBloods.size===0){
        let tMin = Infinity; let killerId = 0;
        for(const p of players){
          const aid = Number(p.account_id||0); if(!(aid>0)) continue; const kl = Array.isArray(p.kills_log)? p.kills_log:[];
          if(kl.length){ const t = Number(kl[0].time||kl[0].time_stamp||kl[0].ts||0); if(isFinite(t) && t>=0 && t < tMin){ tMin=t; killerId=aid; } }
        }
        if(killerId>0 && Number.isFinite(tMin)) firstBloods.set(killerId, 1);
      }
    }catch(_e){}
    // Chat messages (Captain Obvious)
    try{
      const chat = Array.isArray(md.chat)? md.chat: [];
      for(const c of chat){
        const slot = Number(c.slot!=null? c.slot: c.player_slot);
        const aid = slotToAid.get(slot)||0; if(!aid) continue;
    const ctype = String(c.type||'').toLowerCase();
    if(ctype==='chatwheel') continue; // exclude voiceline/chatwheel entries
        chatCount.set(aid, (chatCount.get(aid)||0)+1);
        const key = String(c.key||c.unit||c.text||'').toLowerCase();
        if(key && /(lol|haha|lmao|rofl|xd)/i.test(key)){ laughMsgs.set(aid, (laughMsgs.get(aid)||0)+1); }
      }
    }catch(_e){}
    // removed Tip Spammer fallback
  // Roshan Tourist fallback: if no objective kills at all, use per-player roshan_kills grouped by team to detect a sole killer
    if(roshCountTeam.Radiant===0 && roshCountTeam.Dire===0){
  const killersByTeam={Radiant:new Map(), Dire:new Map()}; const totalByTeam={Radiant:0, Dire:0};
  for(const p of players){
        const aid=Number(p.account_id||0); if(!(aid>0)) continue; const side = ((Number(p.player_slot)<128)?'Radiant':'Dire'); const rk = Number(p.roshan_kills||0); if(rk>0){ killersByTeam[side].set(aid, (killersByTeam[side].get(aid)||0)+rk); totalByTeam[side]+=rk; }
      }
    // Tower kills fallback: if objectives didn't credit any, sum 'killed' tower entries per player
    try{
      if(towerKillEvents.size===0){
        for(const p of players){
          const aid=Number(p.account_id||0); if(!(aid>0)) continue;
          const killed = p && p.killed ? p.killed : null; if(!killed) continue;
          let ct=0; for(const k in killed){ if(/npc_dota_tower|tower/i.test(String(k||''))){ ct += Number(killed[k]||0); } }
          if(ct>0) towerKillEvents.set(aid, (towerKillEvents.get(aid)||0)+ct);
        }
      }
    }catch(_e){}
      for(const side of ['Radiant','Dire']){
        if(totalByTeam[side]>0 && killersByTeam[side].size===1){ const aid = Array.from(killersByTeam[side].keys())[0]; roshAllKillsKiller.set(aid, (roshAllKillsKiller.get(aid)||0)+1); }
      }
    }
    // Fountain Diver via killed_by
  for(const p of players){
      const aid = Number(p.account_id||0); if(!(aid>0)) continue; const kb = p.killed_by||{};
      // Primary sources: killed_by uses either 'dota_fountain' or 'npc_dota_fountain' depending on parser/version
      let fCount = Number(kb.dota_fountain||0) + Number(kb.npc_dota_fountain||0);
      // Fallback: scan deaths_log entries for fountain attacker
      if(!fCount && Array.isArray(p.deaths_log)){
        try{ fCount = p.deaths_log.reduce((acc, it)=> acc + (/dota_fountain|npc_dota_fountain/i.test(String(it.key||it.attackername||'')) ? 1 : 0), 0); }catch(_e){}
      }
      if(fCount){ fountainDeaths.set(aid, (fountainDeaths.get(aid)||0)+fCount); }
    // Self-Destruct: deaths to neutrals
    const neutralDeaths = Number(kb.npc_dota_neutral||0) + Object.entries(kb).reduce((acc,[k,v])=> acc + (/npc_dota_neutral|npc_dota_creep|neutral/i.test(String(k))? Number(v||0):0), 0);
    if(neutralDeaths){ selfDestructDeaths.set(aid, (selfDestructDeaths.get(aid)||0)+neutralDeaths); }
    }
  // Clutch King via teamfights in last 10% duration. Fallback: logs if no teamfights in late window.
    try{
      const dur = Number(md.duration||0) || 0; if(dur>0){
        const cutoff = dur * 0.9;
        const tfs = Array.isArray(md.teamfights) ? md.teamfights : [];
        const use = tfs.filter(tf=>{
          const s = Number(tf.start||tf.start_time||0); const e = Number(tf.end||tf.end_time||s);
          return (s>=cutoff) || (e>=cutoff);
        });
        // Swing Fighter: track best positive swing (gold_delta + xp_delta)
        for(const tf of (tfs||[])){
          const tfPlayers = Array.isArray(tf.players) ? tf.players : [];
          for(let i=0;i<tfPlayers.length;i++){
            const pfi = tfPlayers[i]||{};
            let slot = (pfi.player_slot!=null)? Number(pfi.player_slot) : null;
            if(slot==null && md.players && md.players[i]) slot = Number(md.players[i].player_slot);
            if(slot==null) continue;
            const aid = slotToAid.get(slot)||0; if(!(aid>0)) continue;
            const swing = Number(pfi.gold_delta||0) + Number(pfi.xp_delta||0);
            if(swing>0){ const prev = swingBest.get(aid)||0; if(swing>prev) swingBest.set(aid, swing); }
          }
        }
  if(use.length){
          for(const tf of use){
            const tfPlayers = Array.isArray(tf.players) ? tf.players : [];
            // Compute team kills per side for this fight
            let teamKills = {Radiant:0, Dire:0};
            for(let i=0;i<tfPlayers.length;i++){
              const pfi = tfPlayers[i]||{};
              let slot = (pfi.player_slot!=null)? Number(pfi.player_slot) : null;
              if(slot==null && md.players && md.players[i]) slot = Number(md.players[i].player_slot);
              if(slot==null) continue;
              const side = (slot<128)? 'Radiant' : 'Dire';
              teamKills[side] += Number(pfi.kills||0);
            }
            // Attribute contributions and denominators per player
            for(let i=0;i<tfPlayers.length;i++){
              const pfi = tfPlayers[i]||{};
              let slot = (pfi.player_slot!=null)? Number(pfi.player_slot) : null;
              if(slot==null && md.players && md.players[i]) slot = Number(md.players[i].player_slot);
              if(slot==null) continue;
              const aid = slotToAid.get(slot)||0; if(!(aid>0)) continue;
              const side = (slot<128)? 'Radiant' : 'Dire';
              const contrib = Number(pfi.kills||0) + Number(pfi.assists||0);
              if(contrib){ clutchKA.set(aid, (clutchKA.get(aid)||0)+contrib); }
              const denom = Number(teamKills[side]||0);
              if(denom>0){ clutchTeamK.set(aid, (clutchTeamK.get(aid)||0)+denom); }
            }
          }
        } else {
          // Fallback: use kill/assist logs in last 10% to estimate KP
          // Build per-side team kills in last 10%
          const sideKills = {Radiant:0, Dire:0};
          const perAidKA = new Map();
          for(const p of players){
            const slot = Number(p.player_slot); const aid = slotToAid.get(slot)||0; if(!(aid>0)) continue;
            const side = (slot<128)?'Radiant':'Dire';
            const klog = Array.isArray(p.kills_log)? p.kills_log:[];
            const alog = Array.isArray(p.assists_log)? p.assists_log:[]; // not always present
            const lateK = klog.filter(e=> Number(e.time||0) >= cutoff).length;
            // Approx assists: if no assists_log, use kills by others on same team while this player near deathless window; fallback to 0
            let lateA = 0; if(alog.length){ lateA = alog.filter(e=> Number(e.time||0) >= cutoff).length; }
            if(lateK||lateA){ perAidKA.set(aid, (perAidKA.get(aid)||0) + lateK + lateA); }
            sideKills[side] += lateK;
          }
          for(const p of players){
            const slot = Number(p.player_slot); const aid = slotToAid.get(slot)||0; if(!(aid>0)) continue;
            const side = (slot<128)?'Radiant':'Dire'; const denom = Number(sideKills[side]||0);
            const ka = Number(perAidKA.get(aid)||0);
            if(ka>0 && denom>0){ clutchKA.set(aid, (clutchKA.get(aid)||0)+ka); clutchTeamK.set(aid, (clutchTeamK.get(aid)||0)+denom); }
          }
        }
      }
    }catch(_e){}
  }

  function topN(map, n){ return Array.from(map.entries()).map(([id,val])=>({account_id:Number(id), val:Number(val)})).sort((a,b)=> b.val-a.val).slice(0,n); }
  function withNames(arr){ return arr.map(o=>{ const id=Number(o.account_id||o.id||0); const name = nameCache.get(id) || (id? `Player ${id}` : 'Unknown'); const profile = id? OD_PLAYER_URL(id) : '#'; return {...o, account_id:id, name, profile}; }); }

  // Space Creator top 3 with per-game breakdown
  const scTop = topN(deathsWon, 3);
  res.spaceCreator = withNames(scTop).map(o=>{
    const games = (deathsWonGames.get(o.account_id)||[])
      .slice()
      .sort((a,b)=> (b.deaths - a.deaths) || (b.match_id - a.match_id))
      .slice(0,10);
    return {...o, games};
  });

  // Objective Gamer: tower share (player td / team td on his side across games) + rosh participation
  const teamSums = new Map(); // id -> sum of his team's tower dmg across games he played
  for(const md of details){ const players=(Array.isArray(md.players)? md.players:[]); const sums={Radiant:0, Dire:0}; for(const p of players){ sums[sideOf(p.player_slot)] += Number(p.tower_damage||0); }
    for(const p of players){ const id=Number(p.account_id||0); if(!(id>0)) continue; const side=sideOf(p.player_slot); teamSums.set(id, (teamSums.get(id)||0) + (sums[side]||0)); }
  }
  const ogArr=[]; for(const [id,td] of towerDmg.entries()){ const teamTd = teamSums.get(id)||0; const share = teamTd>0 ? (td/teamTd) : 0; const rosh=roshPart.get(id)||0; ogArr.push({account_id:id, share, rosh, td, teamTd}); }
  res.objectiveGamer = withNames(ogArr.sort((a,b)=> (b.share-a.share) || (b.rosh-a.rosh)).slice(0,3));

  // Early Farmer top 3 (per-player best)
  res.earlyFarmer = withNames(Array.from(earlyBest.entries()).map(([id,val])=>({account_id:Number(id), value:Number(val)})).sort((a,b)=> b.value-a.value).slice(0,3));

  // Other simple top 3s
  res.courierAssassin = withNames(topN(courierKills, 3));
  res.stackMaster    = withNames(topN(stacks, 3));
  res.runeController = withNames(topN(runesCount, 3));
  res.visionMvp      = withNames(topN(wardScore, 3));
  res.aegisSnatcher  = withNames(topN(aegisStolen, 3));
  res.damageSponge        = withNames(topN(dmgTaken, 3));
  // Newly added awards
  res.bkbAbuser           = withNames(topN(bkbUses, 3));
  res.clarityAddict       = withNames(topN(clarityUses, 3));
  res.creepVacuum         = withNames(topN(creepVac, 3));
  res.csPerMinMaster      = withNames(Array.from(csPerMinBest.entries()).map(([id,val])=>({account_id:Number(id), val:Number(val.toFixed(1))})).sort((a,b)=> b.val-a.val).slice(0,3));
  res.backpacker          = withNames(topN(backpacker, 3));
  res.comebackKing        = withNames(topN(comebackKing, 3));
  res.fastFirstPurchase   = withNames(Array.from(firstPurchase.entries()).map(([id,val])=>({account_id:Number(id), val:Number(val)})).sort((a,b)=> a.val-b.val).slice(0,3));
  res.emptySlots          = withNames(topN(emptySlots, 3));
  res.gemCollector        = withNames(topN(gemPurch, 3));
  res.highFiveChamp       = withNames(topN(highFive, 3));
  res.illusionCommander   = withNames(topN(illusionCasts, 3));
  res.kdaGod              = withNames(Array.from(kdaBest.entries()).map(([id,val])=>({account_id:Number(id), val:Number(val)})).sort((a,b)=> b.val-a.val).slice(0,3));
  res.mangoManiac         = withNames(topN(mangoUses, 3));
  res.midasEnjoyer        = withNames(topN(midasUses, 3));
  res.megaKillMaestro     = withNames(Array.from(megaTier.entries()).map(([id,val])=>({account_id:Number(id), val:Number(val)})).sort((a,b)=> b.val-a.val).slice(0,3));
  res.rapierGambler       = withNames(topN(rapierPurch, 3));
  res.refresherFiend      = withNames(topN(refresherUse, 3));
  res.rootLord            = withNames(topN(rootCasts, 3));
  res.runeHasteLover      = withNames(topN(hasteRunes, 3));
  res.salveSavior         = withNames(topN(salveUse, 3));
  res.silenceMaster       = withNames(topN(silenceCasts, 3));
  res.soloArtist          = withNames(topN(soloNoAssistKills, 3));
  res.splitPusher         = withNames(topN(splitPush, 3));
  res.swingFighter        = withNames(topN(swingBest, 3));
  // removed: tipReceiver (award dropped)
  res.selfDestruct        = withNames(topN(selfDestructDeaths, 3));
  res.healBlocker         = withNames(topN(healBlock, 3));
  res.laneFreezer         = withNames(Array.from(laneFreeze10.entries()).map(([id,val])=>({account_id:Number(id), val:Number(val)})).sort((a,b)=> b.val-a.val).slice(0,3));
  res.laughMachine        = withNames(topN(laughMsgs, 3));
  res.lateComer           = withNames(Array.from(lateFirst.entries()).map(([id,val])=>({account_id:Number(id), val:Number(val)})).sort((a,b)=> b.val-a.val).slice(0,3));
  res.neutralItemJuggler  = withNames(Array.from(neutralActives.entries()).map(([id,set])=>({account_id:Number(id), val: Array.isArray(set)? set.length : (set && set.size || 0)})).sort((a,b)=> b.val-a.val).slice(0,3));
  // removed: pauseAbuser (award dropped)
  // Clutch King: aggregate (kills+assists) / team kills over last 10% fights; require denom >0
  {
    const arr=[];
    for(const [id,ka] of clutchKA.entries()){
      const denom = Number(clutchTeamK.get(id)||0);
      if(denom>0){ arr.push({account_id:Number(id), val: Number(((ka/denom)*100).toFixed(1))}); }
    }
    arr.sort((a,b)=> b.val-a.val);
    res.clutchKing = withNames(arr.slice(0,3));
  }
  // Extended awards
  res.disablerSupreme     = withNames(topN(stunsSum, 3));
  { const arr=[]; for(const [id,val] of ancientSum.entries()){ arr.push({account_id:Number(id), val:Number(val), neutral:Number(neutralSum.get(id)||0)}); } arr.sort((a,b)=> (b.val-a.val) || (b.neutral-a.neutral)); res.ancientFarmer = withNames(arr.slice(0,3)); }
  res.medic               = withNames(topN(healHero, 3));
  res.killLeader          = withNames(topN(killsSum, 3));
  res.assistArchitect     = withNames(topN(assistsSum, 3));
  res.gpmKing             = withNames(Array.from(gpmBest.entries()).map(([id,val])=>({account_id:Number(id), val:Number(val)})).sort((a,b)=> b.val-a.val).slice(0,3));
  res.xpmKing             = withNames(Array.from(xpmBest.entries()).map(([id,val])=>({account_id:Number(id), val:Number(val)})).sort((a,b)=> b.val-a.val).slice(0,3));
  res.lastHitLord         = withNames(topN(lastHits, 3));
  res.denyDemon           = withNames(topN(denies, 3));
  res.damageDealer        = withNames(topN(heroDmg, 3));
  res.buildingBreaker     = withNames(topN(towerDmg, 3));
  res.laneDominator       = withNames(Array.from(laneEffBest.entries()).map(([id,val])=>({account_id:Number(id), val:Number(val)})).sort((a,b)=> b.val-a.val).slice(0,3));
  res.runeMagnet          = withNames(topN(runePickups, 3));
  res.wardArchitect       = withNames(topN(wardsPlaced, 3));
  res.visionDenier        = withNames(topN(wardsKilled, 3));
  res.stackMasterPlus     = withNames(topN(stacks, 3));
  res.dustDetective       = withNames(topN(dustDetect, 3));
  res.saviorPlays         = withNames(topN(saviorUses, 3));
  res.spellSlinger        = withNames(topN(abilityCasts, 3));
  res.buybackBaron        = withNames(topN(buybacks, 3));
  res.tpTraveler          = withNames(topN(tps, 3));
  res.smokeSupplier       = withNames(topN(smokePurch, 3));
  res.sentryCfo           = withNames(topN(sentryPurch, 3));
  res.observerCeo         = withNames(topN(observerPurch, 3));
  res.shardHunter         = withNames(topN(shardGot, 3));
  res.neutralHoarder      = withNames(topN(neutralKills, 3));
  res.ancientAnnihilator  = withNames(topN(ancientKills, 3));
  res.towerTerminator     = withNames(topN(towerKillEvents, 3));
  res.firstBloodHunter    = withNames(topN(firstBloods, 3));
  res.rampageCollector    = withNames(Array.from(rampageCount.entries()).map(([id,val])=>({account_id:Number(id), val:Number(val)})).filter(o=>o.val>0).sort((a,b)=> b.val-a.val).slice(0,3));
  res.spreeLegend         = withNames(Array.from(spreeMax.entries()).map(([id,val])=>({account_id:Number(id), val:Number(val)})).filter(o=>o.val>0).sort((a,b)=> b.val-a.val).slice(0,3));
  // removed: streakBreaker (award dropped)
  res.spellDamageSpecialist = withNames(topN(spellDamage, 3));
  res.rightClickRoyalty   = withNames(topN(rightClickDmg, 3));
  res.objectiveScout      = withNames(topN(outpostCaptures, 3));
  res.bottleService       = withNames(topN(bottlePurch, 3));
  res.urnSpiritMvp        = withNames(topN(urnSpiritUses, 3));
  res.lotusLawyer         = withNames(topN(lotusUses, 3));
  res.glimmerGuardian     = withNames(topN(glimmerUses, 3));
  res.forceMaster         = withNames(topN(forceUses, 3));
  res.blinkJunkie         = withNames(topN(blinkUses, 3));
  res.throwMaster         = withNames(topN(throwCount, 3));
  // Heuristic ult awards and wave clear
  res.ultHoarder          = withNames(topN(zeroUltMatches, 3));
  res.ultSpammer          = withNames(topN(ultCastSum, 3));
  res.waveClearer         = withNames(topN(waveClear, 3));
  // New extras
  res.feedingFrenzy       = withNames(Array.from(maxDeathsSingle.entries()).map(([id,val])=>({account_id:Number(id), val:Number(val)})).sort((a,b)=> b.val-a.val).slice(0,3));
  res.oneHitWonder        = withNames(topN(oneKillWins, 3));
  res.assistMachine       = (function(){ const arr=[]; for(const [id,ass] of totAssists.entries()){ if(ass>=10){ const deaths = Math.max(1, Number(totDeaths.get(id)||0)); const ratio = ass/deaths; arr.push({account_id:Number(id), val:Number(ratio.toFixed(2))}); } } return withNames(arr.sort((a,b)=> b.val-a.val).slice(0,3)); })();
  res.captainObvious      = withNames(topN(chatCount, 3));
  res.shopaholic          = withNames(topN(maxPurchases, 3));
  res.noTpClub            = withNames(topN(noTpCount, 3));
  res.invisibleMan        = withNames(topN(invisCount, 3));
  res.bountyHunterIRL     = withNames(topN(bountyRunes, 3));
  res.dieHard             = withNames(topN(deadTimeTotal, 3));
  res.afkFarmer           = withNames(topN(afkFarm, 3));
  // removed: tipSpammer (award dropped)
  // removed: Voiceline Star (chatwheel)
  res.roshanTourist       = withNames(topN(roshAllKillsKiller, 3));
  res.fountainDiver       = withNames(topN(fountainDeaths, 3));
  res.bottleHoarder       = withNames(topN(bottleUses, 3));
  res.jungleEnthusiast    = withNames(topN(jungleScore, 3));
  return res;
}

function renderAwards(aw, heroMap, opts){
  const root = document.getElementById('awardsBody'); if(!root) return;
  window.__lastAwards = aw; // cache for re-render when toggling options
  const hideEmpty = !!(opts && opts.hideEmpty);
  const filterAid = Number((opts && opts.filterAid) || 0) || 0;
  function nm(obj){ const id=Number(obj.account_id||obj.id||0); const label = obj.name || (id?`Player ${id}`:'Unknown'); const href = obj.profile || (id? OD_PLAYER_URL(id): '#'); return `<a href='${href}' target='_blank'>${label}</a>`; }
  function uniqueById(arr){
    const seen = new Set();
    const out = [];
    for(const o of (arr||[])){
      const id = Number(o.account_id||o.id||0);
      if(seen.has(id)) continue;
      seen.add(id); out.push(o);
    }
    return out;
  }
  const fmtMap = {
    deaths: o => ''+o.val,
    objective: o => (o.share*100).toFixed(1)+'% · Rosh x'+(o.rosh||0),
    early: o => ''+o.value,
  plain: o => ''+o.val,
  seconds: o => (Number(o.val||0)).toFixed(1)+'s',
  pct: o => (Number(o.val||0)).toFixed(1)+'%',
  tier: o => 'T'+o.val,
    xval: o => 'x'+o.val,
    ward: o => (o.val||0).toFixed(1),
  };
  // Human-friendly explanations for how each award is computed
  const desc = {
    spaceCreator: 'Most total deaths, counted only in matches that your team won. Hover shows top matches.',
    objectiveGamer: 'Your tower damage share (your tower_damage divided by your team\'s total in your games), plus Roshan participation count.',
    earlyFarmer: 'Best personal net worth at 10:00 across matches (gold_t[10]).',
    courierAssassin: 'Total courier_kills across matches.',
    visionMvp: 'Observers placed + Sentries placed + Observer kills + Sentry kills.',
    stackMaster: 'Total camps_stacked.',
    runeController: 'Total runes picked up (sum of rune counters).',
    aegisSnatcher: 'Count of Aegis stolen events credited to the player.',
  backpacker: 'Total number of items occupying backpack slots at end of games (requires replay-parse fields).',
  bkbAbuser: 'Total Black King Bar uses (item_uses.black_king_bar).',
  clarityAddict: 'Total Clarity uses (item_uses.clarity).',
  comebackKing: 'Matches where your team was down by ≥10k networth and still won; credited to all winners on that side.',
  creepVacuum: 'Lane creeps + neutral creeps killed (sum of lane_kills and neutral_kills).',
  csPerMinMaster: 'Best CS per minute across matches (last hits divided by match minutes).',
  damageSponge: 'Total hero damage taken.',
  clutchKing: 'Kill participation share in the last 10% of game time (teamfight-based): (your kills+assists) / team kills in late fights.',
  fastFirstPurchase: 'Earliest purchase of an item costing >1000 gold across purchase_log (min time; negative pre-game allowed). Fallback to first_purchase_time/purchase_time if logs missing. Lower is better.',
  emptySlots: 'Max number of empty main item slots you had at end of games lasting 40+ minutes.',
  gemCollector: 'Gem of True Sight acquisitions (from purchases and purchase logs).',
  highFiveChamp: 'High Five uses (ability_uses.plus_high_five; fallback: item_uses.high_five).',
  illusionCommander: 'Manta uses plus illusion-creating ability casts (Phantasm, Mirror Image, Doppelganger, Conjure Image).',
  kdaGod: 'Best (Kills + Assists) / max(1, Deaths) ratio across matches.',
  mangoManiac: 'Enchanted Mango uses.',
  midasEnjoyer: 'Hand of Midas uses.',
  megaKillMaestro: 'Highest multi-kill tier achieved (2=Double … 5=Rampage).',
  healBlocker: 'Heals blocked via Spirit Vessel uses and Ancient Apparition Ice Blast casts.',
  laneFreezer: 'Best denies at 10:00 (dn_t[10] if available; otherwise total denies).',
  laughMachine: 'Chat messages with laughter patterns (lol, haha, lmao, rofl, xd).',
  lateComer: 'Latest first purchase of an item costing >1000 gold (min per match; then max across matches). Uses purchase_log; falls back to first_purchase_time/purchase_time. Higher is worse.',
  neutralItemJuggler: 'Distinct neutral items actively used or held across matches.',
  
    disablerSupreme: 'Total stun duration (seconds).',
    medic: 'Total healing done to heroes (hero_healing).',
    killLeader: 'Total kills.',
    assistArchitect: 'Total assists.',
    gpmKing: 'Highest GPM recorded in a single match.',
    xpmKing: 'Highest XPM recorded in a single match.',
    lastHitLord: 'Total last hits.',
    denyDemon: 'Total denies.',
    damageDealer: 'Total hero damage.',
    buildingBreaker: 'Total tower damage.',
    laneDominator: 'Best lane efficiency percentage (max lane_efficiency_pct).',
    runeMagnet: 'Total number of rune pickups.',
    wardArchitect: 'Observers + Sentries placed.',
    visionDenier: 'Observers + Sentries killed (dewards).',
    stackMasterPlus: 'Total camps stacked (same source as Stack Master).',
  dustDetective: "Dust purchases plus uses ('dust' and 'dust_of_appearance').",
    saviorPlays: 'Uses of Force Staff, Glimmer Cape, and Lotus Orb combined.',
    spellSlinger: 'Total ability casts (sum of ability_uses values).',
    buybackBaron: 'Total buybacks (buyback_count).',
    tpTraveler: 'Total TP scroll uses (tp_count or item uses).',
    smokeSupplier: 'Total smokes purchased.',
    sentryCfo: 'Total sentry wards purchased (from purchases and logs).',
    observerCeo: 'Total observer wards purchased (from purchases and logs).',
    shardHunter: 'Received Aghanim\'s Shard (permanent buff) without having purchased it.',
    neutralHoarder: 'Total neutral kills.',
    ancientAnnihilator: 'Total ancient camp kills.',
    towerTerminator: 'Count of tower kill events credited in objectives.',
    firstBloodHunter: 'Count of first blood events credited in objectives.',
    rampageCollector: 'Total Rampages (5x multi-kills).',
    spreeLegend: 'Longest kill spree reached across matches.',
  throwMaster: 'Games where your team led by ≥10k at any time but still lost; credited to all players on that team.',
    
    spellDamageSpecialist: 'Damage dealt by abilities (damage_inflictor minus right-click/generic).',
    rightClickRoyalty: 'Damage dealt by right-clicks (attack/generic buckets).',
  objectiveScout: 'Captures of Watchers/Outposts/Wisdom (objective events or ability_capture fallback).',
    bottleService: 'Bottles purchased/obtained.',
    urnSpiritMvp: 'Urn of Shadows + Spirit Vessel charges used.',
    lotusLawyer: 'Lotus Orb uses.',
    glimmerGuardian: 'Glimmer Cape uses.',
    forceMaster: 'Force Staff uses.',
  blinkJunkie: 'Blink uses (blink/blink_dagger).',
  // New fun awards
  feedingFrenzy: 'Most deaths in a single match (max per player).',
  oneHitWonder: 'Matches with exactly 1 kill where your team still won.',
  assistMachine: 'Highest Assist/Death ratio across the selected range (min. 10 assists total).',
  captainObvious: 'Most standard chat messages recorded in parsed matches.',
  shopaholic: 'Longest purchase_log length observed in a single match.',
  noTpClub: 'Matches over 30 minutes with 0 TP scroll uses.',
  invisibleMan: 'Glimmer Cape uses + Shadow Blade uses + Invisibility rune pickups.',
  bountyHunterIRL: 'Bounty runes picked up.',
  dieHard: 'Top 3 total time spent dead across the selected range.',
  afkFarmer: 'Matches with GPM > 600 and hero damage < 10k.',
  
  roshanTourist: 'Credited as killer for every Roshan killed by your team in a match.',
  fountainDiver: 'Deaths to the enemy fountain.',
  bottleHoarder: 'Bottle uses.',
  jungleEnthusiast: 'Neutral kills + camps stacked (jungle activity indicator).'
  ,rapierGambler: 'Divine Rapier purchases (from purchases and purchase logs).',
  refresherFiend: 'Refresher Orb and Refresher Shard uses (item_uses.refresher + item_uses.refresher_shard).',
  rootLord: 'Casts of root-inducing abilities (approximate proxy: Overgrowth, Entangle, Searing Chains, Frostbite, Ensare, etc.).',
  runeHasteLover: 'Haste rune pickups (runes["0"] or runes.haste).',
  salveSavior: 'Healing Salve uses.',
  selfDestruct: 'Deaths to neutral creeps (from killed_by buckets).',
  silenceMaster: 'Casts of silence abilities (Global Silence, Ancient Seal, Crippling Fear, etc.).',
  soloArtist: 'Kills in matches where the player had 0 assists.',
  splitPusher: 'Tower damage + Barracks damage combined.',
  swingFighter: 'Best single teamfight swing (gold_delta + xp_delta) credited to the player.',
  
  ultHoarder: 'Matches with 0 casts of a recognized ultimate ability (heuristic).',
  ultSpammer: 'Total casts of recognized ultimate abilities (heuristic).',
  waveClearer: 'Damage dealt by common AoE wave-clear spells (heuristic).'
  };
  function list3(title, arr, fmtKey, key){
    if(!Array.isArray(arr) || arr.length===0){
      if(hideEmpty) return '';
      return `<div class='aw-tile'><h3>${title}</h3><ul class='simple'><li><span class='sub'>no data</span></li></ul></div>`;
    }
    const fmt = fmtMap[fmtKey] || (function(o){ var v=(o&&('val' in o))?o.val:''; return String(v==null? '': v); });
    const list = uniqueById(arr).slice(0,3);
    const items = list.map(o=> `<li class='has-hover'><span>${nm(o)}</span><span class='badge'>${fmt(o)}</span>${(title.startsWith('Space Creator') && o.games && o.games.length) ? (`<div class='hovercard'><div class='title'>Deaths by match</div>` + o.games.map(g=>`<div><a class='badge' target='_blank' href='${OD_MATCH_URL(g.match_id)}'>M${g.match_id}</a><span class='badge'>x${g.deaths}</span></div>`).join('') + `</div>`) : ''}${(title.startsWith('Objective Gamer') && (o.td!=null) && (o.teamTd!=null)) ? (`<div class='hovercard'><div class='title'>Share breakdown</div><div><span class='badge'>Your tower dmg: ${o.td}</span><span class='badge'>Team total: ${o.teamTd}</span><span class='badge'>Share: ${(o.share*100).toFixed(1)}%</span></div></div>`) : ''}</li>`).join('');
    const info = (function(){
      if(!(key && desc[key])) return '';
      const hid = `inf-${key}`;
      const text = desc[key].replace(/'/g,"&#39;");
      return `<span class='has-hover' style='margin-left:6px'>
        <button class='badge' data-action='toggle-pop' data-target='${hid}' aria-haspopup='dialog' aria-expanded='false' title='Details'>&#9432;</button>
        <div id='${hid}' class='hovercard' role='dialog' aria-label='${title} – info' style='max-width:360px'>${text}</div>
      </span>`;
    })();
    return `<div class='aw-tile'><h3>${title}${info}</h3><ul class='simple'>${items}</ul></div>`;
  }
  // Build all award tiles, sort alphabetically by title, and render in rows of 3
  const defs = [
  {t:'Backpacker – items in backpack', k:'backpacker', f:'plain'},
  {t:'BKB Abuser – BKB uses', k:'bkbAbuser', f:'plain'},
  {t:'Clarity Addict – clarity uses', k:'clarityAddict', f:'plain'},
  {t:'Comeback King – 10k deficit wins', k:'comebackKing', f:'plain'},
  {t:'Creep Vacuum – lane+neutral kills', k:'creepVacuum', f:'plain'},
  {t:'CS/min Master – best CS per minute', k:'csPerMinMaster', f:'plain'},
  {t:'Clutch King – late fight KP%', k:'clutchKing', f:'pct'},
  {t:'Heal Blocker – vessel/AA anti-heal', k:'healBlocker', f:'plain'},
  {t:'Lane Freezer – denies @10:00', k:'laneFreezer', f:'plain'},
  {t:'Laugh Machine – chat laughs', k:'laughMachine', f:'plain'},
  {t:'Late Comer – latest first buy', k:'lateComer', f:'seconds'},
  {t:'Neutral Item Juggler – distinct items', k:'neutralItemJuggler', f:'plain'},
  
  {t:'Rapier Gambler – rapier buys', k:'rapierGambler', f:'plain'},
  {t:'Refresher Fiend – refresher uses', k:'refresherFiend', f:'plain'},
  {t:'Root Lord – root casts', k:'rootLord', f:'plain'},
  {t:'Rune Haste Lover – haste runes', k:'runeHasteLover', f:'plain'},
  {t:'Salve Savior – salve uses', k:'salveSavior', f:'plain'},
  {t:'Self Destruct – neutral deaths', k:'selfDestruct', f:'plain'},
  {t:'Silence Master – silence casts', k:'silenceMaster', f:'plain'},
  {t:'Solo Artist – kills with 0 assists', k:'soloArtist', f:'plain'},
  {t:'Split Pusher – building damage', k:'splitPusher', f:'plain'},
  {t:'Swing Fighter – best TF swing', k:'swingFighter', f:'plain'},
  
  {t:'Empty Slots – ≥40m empty item slots', k:'emptySlots', f:'plain'},
  {t:'Fast First Purchase – earliest buy', k:'fastFirstPurchase', f:'seconds'},
  {t:'Gem Collector – gems obtained', k:'gemCollector', f:'plain'},
  {t:'High-Five Champ – high five uses', k:'highFiveChamp', f:'plain'},
  {t:'Illusion Commander – illusion casts', k:'illusionCommander', f:'plain'},
  {t:'KDA God – best (K+A)/D', k:'kdaGod', f:'plain'},
  {t:'Mango Maniac – mango uses', k:'mangoManiac', f:'plain'},
  {t:'Midas Enjoyer – midas uses', k:'midasEnjoyer', f:'plain'},
  {t:'Mega Kill Maestro – highest tier', k:'megaKillMaestro', f:'tier'},
    {t:'AFK Farmer – high GPM, low dmg', k:'afkFarmer', f:'plain'},
    {t:'Aegis Snatcher – most snatches', k:'aegisSnatcher', f:'xval'},
    {t:'Ancient Annihilator – ancient kills', k:'ancientAnnihilator', f:'plain'},
    {t:'Assist Architect – most assists', k:'assistArchitect', f:'plain'},
    {t:'Assist Machine – best A/D (≥10A)', k:'assistMachine', f:'plain'},
    {t:'Blink Junkie – blink uses', k:'blinkJunkie', f:'plain'},
    {t:'Bottle Hoarder – bottle uses', k:'bottleHoarder', f:'plain'},
    {t:'Bottle Service – bottles bought', k:'bottleService', f:'plain'},
    {t:'Bounty Hunter IRL – bounty runes', k:'bountyHunterIRL', f:'plain'},
    {t:'Building Breaker – tower damage', k:'buildingBreaker', f:'plain'},
    {t:'Buyback Baron – buybacks', k:'buybackBaron', f:'plain'},
    {t:'Captain Obvious – most chat', k:'captainObvious', f:'plain'},
    {t:'Courier Assassin – most couriers', k:'courierAssassin', f:'xval'},
    {t:'Damage Dealer – hero damage', k:'damageDealer', f:'plain'},
  {t:'Damage Sponge – damage taken', k:'damageSponge', f:'plain'},
    {t:'Deny Demon – denies', k:'denyDemon', f:'plain'},
  {t:'Die Hard – most time dead (range total)', k:'dieHard', f:'seconds'},
    {t:'Disabler Supreme – stun duration', k:'disablerSupreme', f:'seconds'},
    {t:'Dust Detective – dust uses', k:'dustDetective', f:'plain'},
    {t:'Early Farmer – net worth @10:00', k:'earlyFarmer', f:'early'},
    {t:'Feeding Frenzy – most deaths (single game)', k:'feedingFrenzy', f:'plain'},
    {t:'First Blood Hunter – first bloods', k:'firstBloodHunter', f:'plain'},
    {t:'Fountain Diver – fountain deaths', k:'fountainDiver', f:'plain'},
    {t:'Glimmer Guardian – glimmer uses', k:'glimmerGuardian', f:'plain'},
    {t:'GPM King – highest GPM', k:'gpmKing', f:'plain'},
    {t:'Invisible Man – invis actions', k:'invisibleMan', f:'plain'},
    {t:'Jungle Enthusiast – jungle activity', k:'jungleEnthusiast', f:'plain'},
    {t:'Kill Leader – most kills', k:'killLeader', f:'plain'},
    {t:'Lane Dominator – lane efficiency', k:'laneDominator', f:'pct'},
    {t:'Last-Hit Lord – last hits', k:'lastHitLord', f:'plain'},
    {t:'Lotus Lawyer – lotus orb uses', k:'lotusLawyer', f:'plain'},
    {t:'Medic – hero healing', k:'medic', f:'plain'},
    {t:'Neutral Hoarder – neutral kills', k:'neutralHoarder', f:'plain'},
    {t:'No TP Club – 30m+, 0 TP', k:'noTpClub', f:'plain'},
    {t:'Objective Gamer – tower share + rosh', k:'objectiveGamer', f:'objective'},
    {t:'Objective Scout – captures', k:'objectiveScout', f:'plain'},
    {t:'Observer CEO – observers bought', k:'observerCeo', f:'plain'},
    {t:'One Hit Wonder – 1 kill, team won', k:'oneHitWonder', f:'plain'},
    {t:'Rampage Collector – total rampages', k:'rampageCollector', f:'plain'},
    {t:'Right-Click Royalty – attack dmg', k:'rightClickRoyalty', f:'plain'},
    {t:'Roshan Tourist – all team rosh kills (killer)', k:'roshanTourist', f:'plain'},
    {t:'Rune Controller – runes taken', k:'runeController', f:'xval'},
    {t:'Rune Magnet – rune pickups', k:'runeMagnet', f:'plain'},
    {t:'Savior Plays – Force/Glimmer/Lotus', k:'saviorPlays', f:'plain'},
    {t:'Sentry CFO – sentries bought', k:'sentryCfo', f:'plain'},
    {t:'Shard Hunter – shards (no buy)', k:'shardHunter', f:'plain'},
  {t:'Shopaholic – longest purchase log', k:'shopaholic', f:'plain'},
    {t:'Smoke Supplier – smokes bought', k:'smokeSupplier', f:'plain'},
    {t:'Space Creator – most deaths in wins', k:'spaceCreator', f:'deaths'},
    {t:'Spell Damage Specialist – spell dmg', k:'spellDamageSpecialist', f:'plain'},
    {t:'Spell Slinger – ability casts', k:'spellSlinger', f:'plain'},
    {t:'Spree Legend – longest kill streak', k:'spreeLegend', f:'plain'},
  {t:'Throw Master – 10k lead, then loss', k:'throwMaster', f:'plain'},
    {t:'Stack Master – most stacks', k:'stackMaster', f:'xval'},
    
    {t:'Tower Terminator – tower kills', k:'towerTerminator', f:'plain'},
    {t:'TP Traveler – teleports', k:'tpTraveler', f:'plain'},
    
    {t:'Urn/Spirit MVP – charges used', k:'urnSpiritMvp', f:'plain'},
    {t:'Vision Denier – wards killed', k:'visionDenier', f:'plain'},
    {t:'Vision MVP – warding/dewarding', k:'visionMvp', f:'ward'},
    {t:'Ward Architect – wards placed', k:'wardArchitect', f:'plain'},
    {t:'XPM King – highest XPM', k:'xpmKing', f:'plain'},
    {t:'Yedi Master – force uses', k:'forceMaster', f:'plain'},
    {t:'Ult Hoarder – 0-ult matches', k:'ultHoarder', f:'plain'},
    {t:'Ult Spammer – ult casts', k:'ultSpammer', f:'plain'},
    {t:'Wave Clearer – AoE spell dmg', k:'waveClearer', f:'plain'},
  ];
  defs.sort((a,b)=> a.t.localeCompare(b.t, undefined, {sensitivity:'base'}));
  const tiles = defs.map(d=>{
    const src = aw[d.k];
    const arr = (filterAid>0 && Array.isArray(src)) ? src.filter(x=> Number(x.account_id||x.id||0)===filterAid) : src;
    return list3(d.t, arr, d.f, d.k);
  }).filter(s=> s && s.length>0);
  // Chunk into rows of 3
  let html = '';
  for(let i=0;i<tiles.length;i+=3){
    const row = tiles.slice(i,i+3).join('\n');
    html += `<div class='grid3'${i>0?" style='margin-top:8px'":''}>${row}</div>`;
  }
  root.innerHTML = html;
  // Wire info popovers in awards
  try{
    const scope = root;
    scope.querySelectorAll('[data-action="toggle-pop"]').forEach(btn=>{
      btn.addEventListener('click', (e)=>{
        e.preventDefault(); e.stopPropagation();
        const id = btn.getAttribute('data-target');
        const wrapper = btn.closest('.has-hover');
        if(!id||!wrapper) return;
        // Close others under awards only
        scope.querySelectorAll('.has-hover.open').forEach(n=>{ if(n!==wrapper) n.classList.remove('open'); });
        const nowOpen = !wrapper.classList.contains('open');
        wrapper.classList.toggle('open', nowOpen);
        btn.setAttribute('aria-expanded', nowOpen ? 'true' : 'false');
      });
    });
    document.addEventListener('click', (e)=>{
      // Close any open popovers when clicking outside awards area
      if(!root.contains(e.target)){
        root.querySelectorAll('.has-hover.open').forEach(n=> n.classList.remove('open'));
      }
    });
  }catch(_e){}
}

// ===== Calendar rendering =====
function renderCalendarMonth(subset, range, cursor){
  try{
    const grid = document.getElementById('calGrid'); const title = document.getElementById('calTitle'); const prev = document.getElementById('calPrev'); const next = document.getElementById('calNext');
    if(!grid||!title||!prev||!next) return;
    const y = cursor.y, m = cursor.m; // m: 0..11 (UTC)
    const first = new Date(Date.UTC(y,m,1,0,0,0));
    const last  = new Date(Date.UTC(y,m+1,0,23,59,59));
    title.textContent = first.toLocaleString('en-US',{month:'long', year:'numeric', timeZone:'UTC'}) + ' (UTC)';
    // Meta: show how many matches are in this month (within selected period)
    try{
      const meta = document.getElementById('calMeta');
      if(meta){
        const monthCount = Array.isArray(subset) ? subset.reduce((acc, mrec)=>{
          const d = new Date(Number(mrec.start_time||0)*1000);
          return acc + ((d.getUTCFullYear()===y && d.getUTCMonth()===m) ? 1 : 0);
        }, 0) : 0;
        meta.textContent = monthCount>0 ? `${monthCount} matches in this month (within selected period)` : `No matches in this month (within selected period)`;
      }
    }catch(_e){}
    // Determine Monday-based start index
    let startDow = first.getUTCDay(); // 0=Sun
    startDow = (startDow+6)%7; // 0=Mon
    const daysInMonth = last.getUTCDate();
    // Group matches by YYYY-MM-DD (UTC)
    const byDay = new Map();
    for(const mrec of subset){ const d = new Date(mrec.start_time*1000); const key = d.toISOString().slice(0,10); if(!byDay.has(key)) byDay.set(key, []); byDay.get(key).push(mrec); }
    // Build cells
    const cells = [];
    for(let i=0;i<startDow;i++){ cells.push(`<div></div>`); }
    for(let day=1; day<=daysInMonth; day++){
      const key = `${y}-${String(m+1).padStart(2,'0')}-${String(day).padStart(2,'0')}`;
      const arr = (byDay.get(key)||[]).slice().sort((a,b)=> a.start_time-b.start_time);
      const chips = arr.map(x=> `<a href='${OD_MATCH_URL(x.match_id)}' target='_blank' title='${x.radiant_name||'Radiant'} vs ${x.dire_name||'Dire'}'>M${x.match_id}</a>`).join('');
      cells.push(`<div class='day'><div class='date'>${day}</div><div class='matches'>${chips||''}</div></div>`);
    }
    grid.innerHTML = cells.join('');
    // Enable/disable nav within selected range
    const minD = new Date(range.from*1000), maxD = new Date(range.to*1000);
    const prevMonthEnd = new Date(Date.UTC(y,m,0,23,59,59));
    const nextMonthStart = new Date(Date.UTC(y,m+1,1,0,0,0));
    prev.disabled = prevMonthEnd < new Date(Date.UTC(minD.getUTCFullYear(), minD.getUTCMonth(), 1, 0,0,0));
    next.disabled = nextMonthStart > new Date(Date.UTC(maxD.getUTCFullYear(), maxD.getUTCMonth(), 1, 23,59,59));
    prev.onclick = ()=>{ const nm = new Date(Date.UTC(cursor.y, cursor.m, 1)); nm.setUTCMonth(cursor.m-1); cursor.y = nm.getUTCFullYear(); cursor.m = nm.getUTCMonth(); renderCalendarMonth(subset, range, cursor); };
    next.onclick = ()=>{ const nm = new Date(Date.UTC(cursor.y, cursor.m, 1)); nm.setUTCMonth(cursor.m+1); cursor.y = nm.getUTCFullYear(); cursor.m = nm.getUTCMonth(); renderCalendarMonth(subset, range, cursor); };
  }catch(e){ console.warn('calendar render failed', e); }
}
main().catch(e=>{
  document.body.innerHTML = `<div style='padding:24px;color:#fff'>Failed to load data. ${e}</div>`;
  console.error(e);
});
</script>
</body>
</html>