<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1">
<title>Kret's EU Dota League â€“ Dynamic Viewer</title>
<link href='https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap' rel='stylesheet'>
<style>
:root{--bg:#0b1020;--panel:#121832;--muted:#9aa3b2;--text:#eef1f7;--accent:#6da6ff;--chip:#1a2142;--border:rgba(255,255,255,.08)}
*{box-sizing:border-box}
body{margin:0;background:radial-gradient(1200px 600px at 10% -10%, #172045, transparent 60%), var(--bg);color:var(--text);font-family:Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif}
.wrapper{max-width:1180px;margin:0 auto;padding:16px}
.header{display:flex;align-items:center;gap:12px;margin-bottom:12px}
.card{background:linear-gradient(180deg,rgba(255,255,255,.04),rgba(255,255,255,.02));border:1px solid var(--border);border-radius:14px;padding:12px}
.controls{display:flex;flex-wrap:wrap;gap:8px;align-items:end}
.controls .field{display:flex;flex-direction:column;gap:6px}
input,select,button{padding:8px 10px;border-radius:10px;border:1px solid var(--border);background:rgba(255,255,255,.06);color:var(--text)}
button{cursor:pointer}
.grid{display:grid;grid-template-columns:2fr 1fr;gap:12px}
.table{width:100%;border-collapse:collapse}
.table th,.table td{padding:8px;border-bottom:1px solid rgba(255,255,255,.06);font-size:14px}
.table th{text-align:left;color:var(--muted);font-weight:600}
.badge{display:inline-block;padding:4px 8px;border-radius:999px;background:var(--chip);color:var(--text);font-size:12px}
.win{color:#7be495} .loss{color:#ff8b8b}
.logo{width:18px;height:18px;border-radius:50%;object-fit:cover;border:1px solid rgba(255,255,255,.1);margin-right:6px}
.heroes{display:flex;gap:8px;flex-wrap:wrap}
.hero{display:inline-flex;flex-direction:column;align-items:center;gap:4px;font-size:11px;width:64px}
.hero img{width:64px;height:36px;object-fit:cover;border-radius:8px;border:1px solid rgba(255,255,255,.08)}
/* Highlights UI */
.grid3{display:grid;grid-template-columns:repeat(3,1fr);gap:12px}
.grid2{display:grid;grid-template-columns:repeat(2,1fr);gap:12px}
ul.simple{list-style:none;margin:0;padding:0}
ul.simple li{display:flex;align-items:center;justify-content:space-between;gap:8px;padding:6px 0;border-bottom:1px solid rgba(255,255,255,.06)}
.sub{color:var(--muted);font-size:12px}
.title{font-weight:600;margin-bottom:6px}
.has-hover{position:relative}
.has-hover .hovercard{display:none;position:absolute;left:0;top:100%;margin-top:6px;z-index:10;background:rgba(10,16,34,.96);border:1px solid var(--border);border-radius:10px;padding:8px;min-width:220px;box-shadow:0 8px 20px rgba(0,0,0,.4)}
.has-hover:hover .hovercard{display:block}
.ramp-badge{background:#23305f}
</style>
</head>
<body>
<div class="wrapper">
  <div class="header">
    <h1 style="margin:0;font-size:22px">Dynamic viewer</h1>
    <div class="badge">Client-side, using data/*.json</div>
  </div>
  <div class="card controls">
    <div class="field">
      <label for="from">From (UTC)</label>
      <input type="datetime-local" id="from">
    </div>
    <div class="field">
      <label for="to">To (UTC)</label>
      <input type="datetime-local" id="to">
    </div>
    <div class="field">
      <label for="quick">Quick range</label>
      <select id="quick">
        <option value="">-- pick --</option>
        <option value="30">Last 30 days</option>
        <option value="60">Last 60 days</option>
        <option value="120">Last 120 days</option>
        <option value="patch">Last patch</option>
        <option value="all">All time</option>
      </select>
    </div>
    <div class="field">
      <label>&nbsp;</label>
      <button id="apply">Apply</button>
    </div>
  </div>

  <div id="highlightsCard" class="card" style="margin-top:12px;display:none">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px">
      <h2 style="margin:0 0 0;font-size:18px">Highlights</h2>
      <div class="sub">Auto-switches with quick range (30 days / All time)</div>
    </div>
    <div id="highlightsBody"></div>
  </div>

  <div class="grid" style="margin-top:12px">
    <div class="card">
      <h2 style="margin:0 0 8px;font-size:18px">Players</h2>
      <table class="table sortable" id="playersTable"><thead><tr>
        <th data-type="text">Name</th><th data-type="num">Games</th><th data-type="num">W-L</th><th data-type="num">WR</th><th data-type="text">Top 3 heroes</th>
      </tr></thead><tbody></tbody></table>
    </div>
    <div class="card">
      <h2 style="margin:0 0 8px;font-size:18px">Teams</h2>
      <table class="table sortable" id="teamsTable"><thead><tr>
        <th data-type="text">Team</th><th data-type="num">Games</th><th data-type="num">W-L</th><th data-type="num">WR</th>
      </tr></thead><tbody></tbody></table>
    </div>
  </div>

  <div class="card" style="margin-top:12px">
    <h2 style="margin:0 0 8px;font-size:18px">Heroes</h2>
    <table class="table sortable" id="heroesTable"><thead><tr>
      <th data-type="text">Hero</th><th data-type="num">Picks</th><th data-type="num">Bans</th><th data-type="num">Wins</th><th data-type="num">WR</th><th data-type="text">Best player</th>
    </tr></thead><tbody></tbody></table>
  </div>
</div>

<script>
const OD_PLAYER_URL = id => `https://www.opendota.com/players/${id}`;
const OD_MATCH_URL = id => `https://www.opendota.com/matches/${id}`;
function fmtPct(x){ return (x*100).toFixed(1)+'%'; }
async function loadJson(url){ const r=await fetch(url,{cache:'no-store'}); if(!r.ok) throw new Error(`HTTP ${r.status}`); return r.json(); }
async function loadJsonWithFallback(rel, raw){
  try { return await loadJson(rel); } catch(e){ return await loadJson(raw); }
}
function unix(dt){ return Math.floor(dt.getTime()/1000); }
function toUTCInput(unixSec){ if(!unixSec) return ''; const d=new Date(unixSec*1000); const pad=n=>String(n).padStart(2,'0'); return `${d.getUTCFullYear()}-${pad(d.getUTCMonth()+1)}-${pad(d.getUTCDate())}T${pad(d.getUTCHours())}:${pad(d.getUTCMinutes())}`; }

// Sorting helpers
function val(td){
  const ds = td.dataset && td.dataset.sort !== undefined ? td.dataset.sort : null;
  if(ds!==null){ const n=parseFloat(String(ds).replace('%','').replace(',','.')); return isNaN(n)?String(ds).toLowerCase():n; }
  const t = td.textContent.trim().replace('%','').replace(',','.');
  const n = parseFloat(t);
  return isNaN(n) ? t.toLowerCase() : n;
}
function sortTable(table, col, type, asc){
  const tbody = table.tBodies[0]; if(!tbody) return;
  const rows = Array.from(tbody.rows);
  rows.sort((a,b)=>{
    let va=val(a.cells[col]), vb=val(b.cells[col]);
    if(type==='text'){ return asc ? String(va).localeCompare(String(vb)) : String(vb).localeCompare(String(va)); }
    va = parseFloat(va)||0; vb = parseFloat(vb)||0; return asc ? va - vb : vb - va;
  });
  rows.forEach(r=>tbody.appendChild(r));
  table.querySelectorAll('th').forEach(th=>th.classList.remove('sorted-asc','sorted-desc'));
  const th=table.querySelectorAll('th')[col]; if(th) th.classList.add(asc?'sorted-asc':'sorted-desc');
}
function enableSorting(){
  document.querySelectorAll('table.sortable').forEach(table=>{
    table.querySelectorAll('th').forEach((th,i)=>{
      th.style.cursor='pointer';
      th.addEventListener('click', ()=>{
        const type = th.dataset.type || 'text';
        const asc = !th.classList.contains('sorted-asc');
        sortTable(table,i,type,asc);
      });
    });
  });
}

function aggregate(matches, playerNames, teamNames){
  const teams=new Map(), players=new Map(), teamPlayers=new Map(), heroStats=new Map(), heroPlayerAgg=new Map();
  for(const m of matches){
    const radWin=!!m.radiant_win, radTeamId=m.radiant_team_id|0, dirTeamId=m.dire_team_id|0;
    const radName = teamNames[String(radTeamId)] || m.radiant_name || 'Radiant';
    const dirName = teamNames[String(dirTeamId)] || m.dire_name    || 'Dire';
    function ensureTeam(id,name){ if(!id) return; if(!teams.has(id)) teams.set(id,{team_id:id,name,games:0,wins:0,losses:0}); }
    ensureTeam(radTeamId,radName); ensureTeam(dirTeamId,dirName);
    if(radTeamId){ const t=teams.get(radTeamId); t.games++; if(radWin) t.wins++; else t.losses++; if(radName && radName!=='Radiant') t.name=radName; }
    if(dirTeamId){ const t=teams.get(dirTeamId); t.games++; if(radWin) t.losses++; else t.wins++; if(dirName && dirName!=='Dire') t.name=dirName; }

    if(Array.isArray(m.picks_bans)){
      for(const pb of m.picks_bans){ const hid=pb.hero_id|0; let hs=heroStats.get(hid); if(!hs){ hs={picks:0,wins:0,bans:0}; heroStats.set(hid,hs);} if(!pb.is_pick) hs.bans++; }
    }

    for(const p of m.players||[]){
      const id=Number(p.account_id||0); if(!(id>0)) continue;
      if(!players.has(id)){
        const nm = p.personaname || playerNames[String(id)] || `Player ${id}`;
        players.set(id,{account_id:id,name:nm,games:0,wins:0,roles:{},heroes:{},profile:OD_PLAYER_URL(id)});
      }
      const ps=players.get(id); ps.games++;
      const won = p.is_radiant ? radWin : !radWin; if(won) ps.wins++;
      ps.roles['Unknown'] = (ps.roles['Unknown']||0)+1;
      const hid = p.hero_id|0; if(hid>0){
        ps.heroes[String(hid)] = (ps.heroes[String(hid)]||0)+1;
        let hs=heroStats.get(hid); if(!hs){ hs={picks:0,wins:0,bans:0}; heroStats.set(hid,hs);} hs.picks++; if(won) hs.wins++;
        if(!heroPlayerAgg.has(hid)) heroPlayerAgg.set(hid,new Map());
        if(!heroPlayerAgg.get(hid).has(id)) heroPlayerAgg.get(hid).set(id,{account_id:id,name:ps.name,games:0,wins:0,profile:ps.profile});
        const hp=heroPlayerAgg.get(hid).get(id); hp.games++; if(won) hp.wins++;
      }
      const teamId = p.is_radiant ? radTeamId : dirTeamId; if(teamId){
        if(!teamPlayers.has(teamId)) teamPlayers.set(teamId,new Map());
        if(!teamPlayers.get(teamId).has(id)) teamPlayers.get(teamId).set(id,{account_id:id,name:ps.name,games:0,wins:0,profile:ps.profile});
        const tp=teamPlayers.get(teamId).get(id); tp.games++; if(won) tp.wins++;
      }
    }
  }
  return {teams,players,teamPlayers,heroStats,heroPlayerAgg};
}

function render({teams,players,teamPlayers,heroStats,heroPlayerAgg}, heroMap){
  // Players
  const playerRows = Array.from(players.values()).map(p=>{
    const wr = p.games>0 ? p.wins/p.games : 0;
    const heroes = Object.entries(p.heroes).sort((a,b)=>b[1]-a[1]).slice(0,3).map(([hid,cnt])=>{
      const meta=heroMap[hid]||{name:`Hero ${hid}`,img:''};
      return `<div class='hero' title='${meta.name}'><img src='${meta.img}' alt='${meta.name}'><div>${meta.name}<br><span class='badge'>x${cnt}</span></div></div>`;
    }).join('');
    return `<tr>
      <td data-sort="${p.name.toLowerCase()}"><a href='${p.profile}' target='_blank' rel='noopener'>${p.name}</a></td>
      <td data-sort="${p.games}">${p.games}</td>
      <td data-sort="${p.wins/(p.games||1)}"><span class='win'>${p.wins}</span>-<span class='loss'>${p.games-p.wins}</span></td>
      <td data-sort="${wr}">${fmtPct(wr)}</td>
      <td>${`<div class='heroes'>${heroes||'<span class="badge">-</span>'}</div>`}</td>
    </tr>`;
  }).join('');
  document.querySelector('#playersTable tbody').innerHTML = playerRows;

  // Teams
  const teamRows = Array.from(teams.values()).map(t=>{
    const wr = t.games>0 ? t.wins/t.games : 0;
    const nm = t.name || `Team ${t.team_id}`;
    return `<tr>
      <td data-sort="${nm.toLowerCase()}">${nm}</td>
      <td data-sort="${t.games}">${t.games}</td>
      <td data-sort="${t.wins/(t.games||1)}"><span class='win'>${t.wins}</span>-<span class='loss'>${t.losses}</span></td>
      <td data-sort="${wr}">${fmtPct(wr)}</td>
    </tr>`;
  }).join('');
  document.querySelector('#teamsTable tbody').innerHTML = teamRows;

  // Heroes
  const heroRows = Array.from(heroStats.keys()).map(hid=>{
    const hs=heroStats.get(hid), picks=hs.picks|0, wins=hs.wins|0, bans=hs.bans|0, wr = picks>0 ? wins/picks : 0;
    const meta = heroMap[String(hid)] || {name:`Hero ${hid}`,img:''};
    // best player
    let bestLabel='<span class="badge">no data</span>', bestWr=0; const hpa=heroPlayerAgg.get(hid);
    if(hpa){ const arr=Array.from(hpa.values()).filter(x=>x.games>0).map(x=>({...x,wr:x.wins/x.games})).sort((a,b)=> b.wr - a.wr || b.games - a.games || b.wins - a.wins );
      if(arr.length){ const b=arr[0]; bestLabel = `<a href='${b.profile}' target='_blank'>${b.name}</a> - ${fmtPct(b.wr)} (${b.wins}/${b.games})`; bestWr=b.wr; }
    }
    return `<tr>
      <td data-sort="${meta.name.toLowerCase()}"><div style='display:flex;align-items:center;gap:8px'><img src='${meta.img}' style='width:28px;height:28px;border-radius:6px;border:1px solid rgba(255,255,255,.1)'><span>${meta.name}</span></div></td>
      <td data-sort="${picks}">${picks}</td>
      <td data-sort="${bans}">${bans}</td>
      <td data-sort="${wins}">${wins}</td>
      <td data-sort="${wr}">${fmtPct(wr)}</td>
      <td data-sort="${bestWr}">${bestLabel}</td>
    </tr>`;
  }).join('');
  document.querySelector('#heroesTable tbody').innerHTML = heroRows;

  // Initial default sorts (desc): Players by WR, Teams by WR, Heroes by Picks
  if(!window.__dvSortedOnce){
    const pt = document.getElementById('playersTable');
    const tt = document.getElementById('teamsTable');
    const ht = document.getElementById('heroesTable');
    sortTable(pt, 3, 'num', false);
    sortTable(tt, 3, 'num', false);
    sortTable(ht, 1, 'num', false);
    window.__dvSortedOnce = true;
  }
}

function renderHighlights(high){
  const card = document.getElementById('highlightsCard');
  const body = document.getElementById('highlightsBody');
  if(!high || typeof high !== 'object'){ card.style.display='none'; body.innerHTML=''; return; }
  function esc(s){ return String(s||'').replace(/[&<>"']/g, c=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"}[c])); }
  function linkPlayer(obj){
    if(!obj) return '<span class="sub">Unknown</span>';
    const id = obj.account_id || obj.id || obj.accountId || 0;
    const name = esc(obj.name || obj.personaname || (id?`Player ${id}`:'Unknown'));
    const profile = esc(obj.profile || (id? OD_PLAYER_URL(id) : '#'));
    return `<a href='${profile}' target='_blank' rel='noopener'>${name}</a>`;
  }
  // Rampages
  let rampHtml = '<li><span class="sub">no games</span></li>';
  if(Array.isArray(high.rampages) && high.rampages.length){
    rampHtml = high.rampages.map(r=>{
      const name = esc(r.name||'Player'); const profile = esc(r.profile||'#');
      const cnt = Number(r.count||0);
      let matches = '';
      if(Array.isArray(r.matches)){
        matches = r.matches.map(m=>{
          const mid = String(m.match_id||m.matchId||''); const c = Number(m.count||1);
          const label = c>1 ? `x${c}` : 'match';
          return `<a class='badge' target='_blank' href='${OD_MATCH_URL(mid)}'>M${mid}</a><span class='badge'>${label}</span>`;
        }).join(' ');
      }
      return `<li class='has-hover'><span><a href='${profile}' target='_blank'>${name}</a></span><span class='badge ramp-badge'>x${cnt}</span><div class='hovercard'><div class='title'>Rampage matches</div>${matches||'<div class="sub">no links</div>'}</div></li>`;
    }).join('');
  }
  // New blocks: teammates, courier kills, camps stacked
  function teammatesList(arr){
    if(!Array.isArray(arr) || !arr.length) return `<li><span class="sub">no data</span></li>`;
    return arr.map(it=>{
      // Try to normalize pair structure
      const a = it.a || (Array.isArray(it.pair)? it.pair[0] : null) || (it.p1_id? {account_id: it.p1_id, name: it.p1_name, profile: it.p1_profile} : null);
      const b = it.b || (Array.isArray(it.pair)? it.pair[1] : null) || (it.p2_id? {account_id: it.p2_id, name: it.p2_name, profile: it.p2_profile} : null);
      const cnt = Number(it.count ?? it.games ?? it.value ?? 0);
      return `<li><span>${linkPlayer(a)} + ${linkPlayer(b)}</span><span class='badge'>x${cnt}</span></li>`;
    }).join('');
  }
  function simpleCountList(arr, unit){
    if(!Array.isArray(arr) || !arr.length) return `<li><span class="sub">no data</span></li>`;
    return arr.map(it=>{
      const cnt = Number(it.count ?? it.total ?? it.value ?? it.kills ?? it.stacks ?? 0);
      const player = it.player || it;
      return `<li><span>${linkPlayer(player)}</span><span class='badge'>x${cnt} ${unit}</span></li>`;
    }).join('');
  }
  // Roshan
  const rosR = high.roshan && typeof high.roshan.Radiant==='number' ? high.roshan.Radiant : 0;
  const rosD = high.roshan && typeof high.roshan.Dire==='number' ? high.roshan.Dire : 0;
  const objWarn = high.objectivesSeen===false ? `<div class='sub'>no objective data in parsed matches</div>` : '';
  const objNone = (rosR+rosD)===0 ? `<div class='sub'>no Roshan events in this period</div>` : '';
  function rosTop(side){
    const arr = high.roshanTop && Array.isArray(high.roshanTop[side]) ? high.roshanTop[side] : [];
    if(!arr.length) return '';
    return ' ' + arr.map(x=>{
      const mid = String(x.match_id||''); const c = Number(x.count||1);
      return `<a class='badge' target='_blank' href='${OD_MATCH_URL(mid)}'>M${mid}</a><span class='badge'>x${c}</span>`;
    }).join(' ');
  }
  // Top single-match performances
  const ts = high.topSingle||{};
  const topHtml = ['gpm','kills','assists','networth'].map(k=>{
    const p = ts[k]; if(!p) return '';
    const name=esc(p.name||'Player'); const profile=esc(p.profile||'#'); const val = esc(p.value); const mid = esc(p.match_id||'');
    const label = k==='gpm'?'Highest GPM':k==='kills'?'Highest Kills':k==='assists'?'Highest Assists':'Highest Net Worth';
    return `<li><span><a href='${profile}' target='_blank'>${name}</a></span><span class='badge'>${label}: <strong>${val}</strong></span><a class='badge' target='_blank' href='${OD_MATCH_URL(mid)}'>Match</a></li>`;
  }).filter(Boolean).join('') || `<li><span class='sub'>no games</span></li>`;
  // Durations
  function durList(arr){
    if(!Array.isArray(arr) || !arr.length) return `<li><span class='sub'>no games</span></li>`;
    return arr.map(x=>{
      const sec = Number(x.duration||0); const mm=Math.floor(sec/60), ss=sec%60;
      const vs = esc(`${x.radiant||'Radiant'} vs ${x.dire||'Dire'}`);
      const win = x.radiant_win ? 'Radiant' : 'Dire';
      const mid = esc(x.match_id||'');
      return `<li><span><a target='_blank' href='${OD_MATCH_URL(mid)}'>${vs}</a></span><span class='badge'>${mm}m ${ss}s</span><span class='badge'>Winner: ${win}</span></li>`;
    }).join('');
  }
  const html = `
    <div class="grid3">
      <div>
        <h3>Rampages</h3>
        <ul class="simple">${rampHtml}</ul>
      </div>
      <div>
        <h3>Roshan taken</h3>
        <ul class="simple">
          <li><span>Radiant</span><span class='badge'>x${rosR}</span>${rosTop('Radiant')}</li>
          <li><span>Dire</span><span class='badge'>x${rosD}</span>${rosTop('Dire')}</li>
        </ul>
        ${objWarn}${objNone}
      </div>
      <div>
        <h3>Top single-match performances</h3>
        <ul class="simple">${topHtml}</ul>
      </div>
    </div>
    <div class="grid3" style="margin-top:8px">
      <div>
        <h3>Most common teammates</h3>
        <ul class="simple">${teammatesList(high.teammates)}</ul>
      </div>
      <div>
        <h3>Most courier kills</h3>
        <ul class="simple">${simpleCountList(high.courierTop, 'couriers')}</ul>
      </div>
      <div>
        <h3>Most camps stacked</h3>
        <ul class="simple">${simpleCountList(high.stackTop, 'stacks')}</ul>
      </div>
    </div>
    <div class="grid2" style="margin-top:8px">
      <div>
        <h3>3 longest matches</h3>
        <ul class="simple">${durList(high.durationLongest)}</ul>
      </div>
      <div>
        <h3>3 shortest matches</h3>
        <ul class="simple">${durList(high.durationShortest)}</ul>
      </div>
    </div>`;
  body.innerHTML = html; card.style.display='';
}

async function main(){
  // Load from root-level data/ via relative path (local) or raw.githubusercontent.com (GitHub Pages)
  const REPO='Zeroks77/Kret_Dota'; const BRANCH='main';
  const relBase='../data'; const rawBase=`https://raw.githubusercontent.com/${REPO}/${BRANCH}/data`;
  const [manifest, heroes, info, high30, highAll] = await Promise.all([
    loadJsonWithFallback(`${relBase}/manifest.json`, `${rawBase}/manifest.json`),
    loadJsonWithFallback(`${relBase}/heroes.json`, `${rawBase}/heroes.json`),
    loadJsonWithFallback(`${relBase}/info.json`, `${rawBase}/info.json`).catch(()=>({})),
    loadJsonWithFallback(`${relBase}/highlights_30.json`, `${rawBase}/highlights_30.json`).catch(()=>null),
    loadJsonWithFallback(`${relBase}/highlights_all.json`, `${rawBase}/highlights_all.json`).catch(()=>null)
  ]);
  // Fetch all month shards listed in manifest
  const months = (manifest && Array.isArray(manifest.months)) ? manifest.months : [];
  const files = months.map(m => ({rel: `${relBase}/${m.file}`, raw: `${rawBase}/${m.file}`}));
  const shards = await Promise.all(files.map(p => loadJsonWithFallback(p.rel, p.raw).catch(()=>[])));
  let allMatches = shards.flat();
  // Names arenâ€™t shipped separately in shards; derive names from matches where available
  const playerNames = {}; const teamNames = {};
  for(const m of allMatches){
    if(Array.isArray(m.players)){
      for(const p of m.players){ if(p && p.account_id>0 && p.personaname){ playerNames[String(p.account_id)] = p.personaname; } }
    }
    if(m.radiant_team_id && m.radiant_name) teamNames[String(m.radiant_team_id)] = m.radiant_name;
    if(m.dire_team_id && m.dire_name)       teamNames[String(m.dire_team_id)]    = m.dire_name;
  }

  const from = document.getElementById('from'), to = document.getElementById('to'), quick = document.getElementById('quick');
  function apply(){
    let f=from.valueAsDate? unix(new Date(from.value)) : 0;
    let t=to.valueAsDate? unix(new Date(to.value)) : Number.MAX_SAFE_INTEGER;
    const subset = allMatches.filter(m=> (m.start_time>=f) && (m.start_time<=t) );
    const agg = aggregate(subset, playerNames, teamNames);
    render(agg, heroes);
    // Render highlights based on quick selection
    const hv = quick.value;
    if(hv==='30' && high30){ renderHighlights(high30); }
    else if(hv==='all' && highAll){ renderHighlights(highAll); }
    else { renderHighlights(null); }
  }
  document.getElementById('apply').addEventListener('click', apply);
  quick.addEventListener('change', async ()=>{
    const v=quick.value;
    const now = Math.floor(Date.now()/1000);
    let fromUnix=0;
    if(v==='30') fromUnix = now - 30*86400; else if(v==='60') fromUnix = now - 60*86400; else if(v==='120') fromUnix = now - 120*86400; else if(v==='patch'){
      try{ const patch=await fetch('https://api.opendota.com/api/constants/patch',{cache:'force-cache'}).then(r=>r.json());
        let latest=0; for(const k in patch){ const it=patch[k]; const d = typeof it.date==='number' ? it.date : Date.parse(it.date)/1000; if(!isNaN(d) && d>latest) latest=d; }
        fromUnix = latest||0;
      }catch{ fromUnix=0; }
    } else if(v==='all'){ fromUnix = 0; }
    from.value = toUTCInput(fromUnix); to.value = toUTCInput(now);
    // Auto-apply when quick changes for instant feedback
    apply();
  });

  // Initialize inputs to last 30 days
  const now = Math.floor(Date.now()/1000);
  from.value = toUTCInput(now - 30*86400);
  to.value   = toUTCInput(now);
  // Default quick to 30 to show highlights
  const quickSel = document.getElementById('quick'); quickSel.value='30';
  apply();
}
enableSorting();
main().catch(e=>{
  document.body.innerHTML = `<div style='padding:24px;color:#fff'>Failed to load data. ${e}</div>`;
  console.error(e);
});
</script>
</body>
</html>
