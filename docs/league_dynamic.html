<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>League Dynamic Viewer</title>
  <base href="./">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #0b1020;
      --panel: #121832;
      --muted: #9aa3b2;
      --text: #eef1f7;
      --accent: #9ec7ff;
      --chip: #1a2142;
      --border: rgba(255,255,255,.08);
    }
    * { box-sizing: border-box }
    body {
      margin: 0;
      background: radial-gradient(1200px 600px at 10% -10%, #172045, transparent 60%), var(--bg);
      color: var(--text);
      font-family: Inter, system-ui, Segoe UI, Roboto, Arial, sans-serif;
    }
    a { color: var(--accent); text-decoration: none }
    .wrapper { max-width: 1180px; margin: 0 auto; padding: 16px }
  </style>
</head>
<body>
  <div class="wrapper">

  <div id="pane-wards" class="tabpane" style="display:none" role="tabpanel" aria-labelledby="tab-wards" hidden>
      <section class="card" style="margin-top:12px">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px">
          <h2 style="margin:0;font-size:18px">Wards</h2>
          <div class="sub">League ward stats</div>
        </div>
        <div id="dvWardMount">
          <div class="tabs" id="wardSubTabs" role="tablist" aria-label="Ward subtabs">
            <button class="tab active" data-wtab="spots" role="tab" aria-selected="true">Spots</button>
            <button class="tab" data-wtab="players" role="tab" aria-selected="false">Players</button>
            <button class="tab" data-wtab="trend" role="tab" aria-selected="false">Trend</button>
          </div>
          <div id="wtab-spots" class="tabpane active" role="tabpanel" aria-labelledby="wtab-btn-spots">
            <div id="dvWardStd" class="sub" role="status" aria-live="polite"><span class="spinner" aria-hidden="true"></span> Preparing‚Ä¶</div>
          </div>
          <div id="wtab-players" class="tabpane" role="tabpanel" aria-labelledby="wtab-btn-players" style="display:none">
            <div id="dvWardPlayers" class="sub">Select a range to load ward player stats.</div>
          </div>
          <div id="wtab-trend" class="tabpane" role="tabpanel" aria-labelledby="wtab-btn-trend" style="display:none">
            <div id="dvWardTrend" class="sub">Observer lifetime trend over time.</div>
          </div>
        </div>
      </section>
    </div>
  </div>

  <script>
    const OD_PLAYER_URL = id => `https://www.opendota.com/players/${id}`;
    const OD_MATCH_URL = id => `https://www.opendota.com/matches/${id}`;
    function fmtPct(x) { return (x * 100).toFixed(1) + '%'; }
    function buildPatchList(src){
      const out=[]; const push=(name,d)=>{ let ts=0; if(typeof d==='number'){ ts=Math.floor(d);} else if(typeof d==='string'){ const ms=Date.parse(d); if(!isNaN(ms)) ts=Math.floor(ms/1000);} if(name && ts>0) out.push({name:String(name), ts}); };
      try{
        if(Array.isArray(src)){ src.forEach(o=>{ if(!o) return; push(o.name||o.version||o.patch||o.id, o.date||o.time||o.released||o.start_date); }); }
        else if(src && typeof src==='object'){ for(const k in src){ const o=src[k]||{}; push(o.name||o.version||o.patch||k, o.date||o.time||o.released||o.start_date); } }
      }catch(_e){}
      return out.sort((a,b)=>a.ts-b.ts);
    }

    async function loadJson(u) {
      try {
        const r = await fetch(u, { cache: 'no-store' });
        if (!r.ok) return null;
        return await r.json();
      } catch (_e) { return null; }
    }
    async function loadJsonWithFallback(rel, raw) {
      const isFile = (typeof location !== 'undefined' && location.protocol === 'file:');
      if (isFile) { const a = await loadJson(raw); if (a) return a; return await loadJson(rel); }
      else { const a = await loadJson(rel); if (a) return a; return await loadJson(raw); }
    }
    async function loadFirst(urls) {
      for (const u of urls) { const j = await loadJson(u); if (j) return j; }
      return null;
    }
    const IS_GHPAGES = (typeof location !== 'undefined' && /\.github\.io$/i.test(String(location.hostname||'')));

    function makeHeroMap(heroesRaw) {
      const map = {};
      if (!heroesRaw) return map;
      const add = (obj) => {
        if (!obj) return;
        const id = String(obj.id || obj.hero_id || obj.npc_id || obj.key || obj.key_id || obj.code || obj.slug || obj);
        if (!/^[0-9]+$/.test(id)) return;
        const name = obj.localized_name || obj.name_localized || obj.displayName || obj.name || `Hero ${id}`;
        let img = obj.img || obj.icon || '';
        if (img && !/^https?:/i.test(img)) {
          // OpenDota/Valve asset paths start with /apps/dota2/...; prefix Valve CDN for absolute access
          img = `https://cdn.cloudflare.steamstatic.com${img}`;
        }
        map[id] = { id: Number(id), name, img };
      };
      if (Array.isArray(heroesRaw)) { heroesRaw.forEach(add); }
      else if (typeof heroesRaw === 'object') { Object.values(heroesRaw).forEach(add); }
      return map;
    }

    function sortTable(table, col, type, asc) {
      const tbody = table.tBodies[0];
      if (!tbody) return;
      const rows = Array.from(tbody.rows);
      function val(td) {
        const ds = td.dataset && td.dataset.sort !== undefined ? td.dataset.sort : null;
        if (ds !== null) {
          const n = parseFloat(String(ds).replace('%', '').replace(',', '.'));
          return isNaN(n) ? String(ds).toLowerCase() : n;
        }
        const t = td.textContent.trim().replace('%', '').replace(',', '.');
        const n = parseFloat(t);
        return isNaN(n) ? t.toLowerCase() : n;
      }
      rows.sort((a, b) => {
        let va = val(a.cells[col]), vb = val(b.cells[col]);
        if (type === 'text') return asc ? String(va).localeCompare(String(vb)) : String(vb).localeCompare(String(va));
        va = parseFloat(va) || 0; vb = parseFloat(vb) || 0;
        return asc ? va - vb : vb - va;
      });
      rows.forEach(r => tbody.appendChild(r));
      table.querySelectorAll('th').forEach(th => { th.classList.remove('sorted-asc', 'sorted-desc'); th.removeAttribute('aria-sort'); });
      const th = table.querySelectorAll('th')[col];
      if (th) { th.classList.add(asc ? 'sorted-asc' : 'sorted-desc'); th.setAttribute('aria-sort', asc ? 'ascending' : 'descending'); }
    }
    function enableSorting() {
      document.querySelectorAll('table.sortable').forEach(table => {
        table.querySelectorAll('th').forEach((th, i) => {
          th.tabIndex = 0; th.setAttribute('role','columnheader');
          th.addEventListener('click', () => {
            const type = th.dataset.type || 'text';
            const asc = !th.classList.contains('sorted-asc');
            sortTable(table, i, type, asc);
          });
          th.addEventListener('keydown', (ev) => {
            if(ev.key==='Enter' || ev.key===' '){ ev.preventDefault();
              const type = th.dataset.type || 'text';
              const asc = !th.classList.contains('sorted-asc');
              sortTable(table, i, type, asc);
            }
          });
        });
      });
    }

    function aggregate(matches, playerNames, teamNames) {
      const teams = new Map(), players = new Map(), teamPlayers = new Map(), heroStats = new Map(), heroPlayerAgg = new Map();
      for (const m of matches) {
        const radWin = !!m.radiant_win, radTeamId = m.radiant_team_id | 0, dirTeamId = m.dire_team_id | 0;
        const radName = teamNames[String(radTeamId)] || m.radiant_name || 'Radiant';
        const dirName = teamNames[String(dirTeamId)] || m.dire_name || 'Dire';
        function ensureTeam(id, name) { if (!id) return; if (!teams.has(id)) teams.set(id, { team_id: id, name, games: 0, wins: 0, losses: 0 }); }
        ensureTeam(radTeamId, radName); ensureTeam(dirTeamId, dirName);
        if (radTeamId) { const t = teams.get(radTeamId); t.games++; if (radWin) t.wins++; else t.losses++; if (radName && radName !== 'Radiant') t.name = radName; }
        if (dirTeamId) { const t = teams.get(dirTeamId); t.games++; if (radWin) t.losses++; else t.wins++; if (dirName && dirName !== 'Dire') t.name = dirName; }
        if (Array.isArray(m.picks_bans)) for (const pb of m.picks_bans) {
          const hid = pb.hero_id | 0; let hs = heroStats.get(hid);
          if (!hs) { hs = { picks: 0, wins: 0, bans: 0 }; heroStats.set(hid, hs); }
          if (!pb.is_pick) hs.bans++;
        }
        for (const p of m.players || []) {
          const id = Number(p.account_id || 0); if (!(id > 0)) continue;
          if (!players.has(id)) { const nm = playerNames[String(id)] || p.personaname || `Player ${id}`; players.set(id, { account_id: id, name: nm, games: 0, wins: 0, heroes: {}, heroWins: {}, profile: OD_PLAYER_URL(id) }); }
          const ps = players.get(id); ps.games++; const won = p.is_radiant ? radWin : !radWin; if (won) ps.wins++;
          const hid = p.hero_id | 0; if (hid > 0) {
            ps.heroes[String(hid)] = (ps.heroes[String(hid)] || 0) + 1; ps.heroWins[String(hid)] = (ps.heroWins[String(hid)] || 0) + (won ? 1 : 0);
            let hs = heroStats.get(hid); if (!hs) { hs = { picks: 0, wins: 0, bans: 0 }; heroStats.set(hid, hs); }
            hs.picks++; if (won) hs.wins++;
            if (!heroPlayerAgg.has(hid)) heroPlayerAgg.set(hid, new Map());
            if (!heroPlayerAgg.get(hid).has(id)) heroPlayerAgg.get(hid).set(id, { account_id: id, name: ps.name, games: 0, wins: 0, profile: ps.profile });
            const hp = heroPlayerAgg.get(hid).get(id); hp.games++; if (won) hp.wins++;
          }
          const teamId = p.is_radiant ? radTeamId : dirTeamId; if (teamId) {
            if (!teamPlayers.has(teamId)) teamPlayers.set(teamId, new Map());
            if (!teamPlayers.get(teamId).has(id)) teamPlayers.get(teamId).set(id, { account_id: id, name: ps.name, games: 0, wins: 0, profile: ps.profile });
            const tp = teamPlayers.get(teamId).get(id); tp.games++; if (won) tp.wins++;
          }
        }
      }
      return { teams, players, teamPlayers, heroStats, heroPlayerAgg };
    }

    let __focusAid = 0, __userOnlyAid = 0;
    function render({ teams, players, teamPlayers, heroStats, heroPlayerAgg }, heroMap, opts) {
      const teamResolver = opts && typeof opts.teamResolver === 'function' ? opts.teamResolver : null;
      // Build primary team mapping: for each player choose the team with most games in this league
      const primaryTeamByAid = {};
      for (const [tid, pmap] of teamPlayers.entries()) {
        const teamName = (teams.get(tid) && teams.get(tid).name) || `Team ${tid}`;
        for (const [aid, st] of pmap.entries()) {
          const k = String(aid);
          const prev = primaryTeamByAid[k];
          if (!prev || (st.games || 0) > (prev.games || 0)) {
            primaryTeamByAid[k] = { name: teamName, games: st.games };
          }
        }
      }
      let plist = Array.from(players.values());
      if (__userOnlyAid > 0) plist = plist.filter(p => Number(p.account_id) === __userOnlyAid);
      if (__focusAid > 0) { const idx = plist.findIndex(p => Number(p.account_id) === __focusAid); if (idx > 0) { const [it] = plist.splice(idx, 1); plist.unshift(it); } }

      const playerRows = plist.map(p => {
        const wr = p.games ? p.wins / p.games : 0; const poolSize = Object.keys(p.heroes || {}).length;
        const resolvedTeam = teamResolver ? (teamResolver(p.account_id) || '') : '';
        const pt = primaryTeamByAid[String(p.account_id)];
        const teamName = resolvedTeam || (pt && pt.name) || '';
        const teamLabel = teamName ? ` <span class='sub' style='margin-left:6px'>(${teamName})</span>` : '';
        return (
          `<tr>
            <td data-sort='${p.name.toLowerCase()} ${teamName ? teamName.toLowerCase() : ''}'>
              <a href='${p.profile}' target='_blank'>${p.name}</a>${teamLabel}
            </td>
            <td data-sort='${p.games}'>${p.games}</td>
            <td data-sort='${p.wins / (p.games || 1)}'><span class='win'>${p.wins}</span>-<span class='loss'>${p.games - p.wins}</span></td>
            <td data-sort='${wr}'>${fmtPct(wr)}</td>
            <td data-sort='${poolSize}'>${poolSize}</td>
          </tr>`
        );
      }).join('');
      document.querySelector('#playersTable tbody').innerHTML = playerRows;

      const teamRows = Array.from(teams.values()).map(t => {
        const wr = t.games ? t.wins / t.games : 0;
        return (
          `<tr>
            <td data-sort='${t.name.toLowerCase()}'>${t.name}</td>
            <td data-sort='${t.games}'>${t.games}</td>
            <td data-sort='${t.wins / (t.games || 1)}'><span class='win'>${t.wins}</span>-<span class='loss'>${t.losses}</span></td>
            <td data-sort='${wr}'>${fmtPct(wr)}</td>
          </tr>`
        );
      }).join('');
      document.querySelector('#teamsTable tbody').innerHTML = teamRows;

      const heroRows = Array.from(heroStats.keys()).map(hid => {
        const hs = heroStats.get(hid);
        const picks = hs.picks | 0, wins = hs.wins | 0, bans = hs.bans | 0, wr = picks ? wins / picks : 0;
        const meta = heroMap[String(hid)] || { name: `Hero ${hid}`, img: '' };
        let bestLabel = '<span class="badge">no data</span>', bestWr = 0;
        const hpa = heroPlayerAgg.get(hid);
        if (hpa) {
          const arr = Array.from(hpa.values()).filter(x => x.games > 0).map(x => ({ ...x, wr: x.wins / x.games })).sort((a, b) => b.wr - a.wr || b.games - a.games);
          if (arr.length) { const b = arr[0]; bestLabel = `<a href='${b.profile}' target='_blank'>${b.name}</a> - ${fmtPct(b.wr)} (${b.wins}/${b.games})`; bestWr = b.wr; }
        }
        return (
          `<tr>
            <td data-sort='${meta.name.toLowerCase()}'>
              <div style='display:flex;align-items:center;gap:8px'>
                <img src='${meta.img}' alt='${meta.name}' loading='lazy' decoding='async' style='width:28px;height:28px;border-radius:6px;border:1px solid rgba(255,255,255,.1)'>
                <span>${meta.name}</span>
              </div>
            </td>
            <td data-sort='${picks}'>${picks}</td>
            <td data-sort='${bans}'>${bans}</td>
            <td data-sort='${wins}'>${wins}</td>
            <td data-sort='${wr}'>${fmtPct(wr)}</td>
            <td data-sort='${bestWr}'>${bestLabel}</td>
          </tr>`
        );
      }).join('');
      document.querySelector('#heroesTable tbody').innerHTML = heroRows;

      if (!window.__lvSortedOnce) {
        sortTable(document.getElementById('playersTable'), 3, 'num', false);
        sortTable(document.getElementById('teamsTable'), 3, 'num', false);
        sortTable(document.getElementById('heroesTable'), 1, 'num', false);
        window.__lvSortedOnce = true;
      }
    }

    // summary cards removed for league view

    async function pMap(items, limit, worker) {
      const ret = new Array(items.length); let i = 0; let active = 0;
      return await new Promise(res => {
        function next() {
          if (i >= items.length && active === 0) { res(ret); return; }
          while (active < limit && i < items.length) {
            const idx = i++; active++;
            Promise.resolve(worker(items[idx], idx)).then(v => { ret[idx] = v; active--; next(); }).catch(() => { ret[idx] = null; active--; next(); });
          }
        }
        next();
      });
    }

    async function fetchMatchDetail(id, relBase, rawBase) {
      const localPreferred = `${relBase}/cache/OpenDota/matches/${id}.json`;
      const localAlt = `data/cache/OpenDota/matches/${id}.json`;
      const remote = `${rawBase}/cache/OpenDota/matches/${id}.json`;
      const order = IS_GHPAGES ? [remote, localPreferred, localAlt] : [localPreferred, localAlt, remote];
      return await loadFirst(order);
    }

    function computeHighlightsFromDetails(details, resolver, teamResolver) {
      const rampages = new Map(), rapierBy = new Map(), gemBy = new Map(), duosSafe = new Map(), duosOff = new Map(), roshanTeam = { Radiant: 0, Dire: 0 };
      let bestGPM = null, bestKills = null, bestAssists = null, bestNet = null;
      const durList = [];
      function add(map, k, inc = 1) { map.set(String(k), (map.get(String(k)) || 0) + inc); }

      for (const md of details) {
        if (!md) continue; const mid = Number(md.match_id || 0);
        const players = Array.isArray(md.players) ? md.players : []; const radWin = !!md.radiant_win;
        for (const p of players) {
          const aid = Number(p.account_id || 0); if (aid > 0) {
            const mk = p.multi_kills || {}; const r = Number(mk['5'] || 0); if (r > 0) add(rampages, aid, r);
            const displayName = (resolver && resolver(aid)) || p.personaname || `Player ${aid}`;
            const teamTag = (teamResolver && teamResolver(aid)) || '';
            const display = teamTag ? `${displayName} (${teamTag})` : displayName;
            const setBest = (cur, val) => val > 0 && (!cur || (cur.value || 0) < val)
              ? { account_id: aid, name: display, profile: OD_PLAYER_URL(aid), value: val, match_id: mid } : cur;
            bestGPM = setBest(bestGPM, Number(p.gold_per_min || 0));
            bestKills = setBest(bestKills, Number(p.kills || 0));
            bestAssists = setBest(bestAssists, Number(p.assists || 0));
            bestNet = setBest(bestNet, Number(p.net_worth || 0) || Number(p.total_gold || 0));
            const log = Array.isArray(p.purchase_log) ? p.purchase_log : [];
            for (const ev of log) { const k = String(ev.key || '').toLowerCase(); if (k.includes('rapier')) add(rapierBy, aid, 1); if (k === 'gem' || k.includes('gem_of_true_sight')) add(gemBy, aid, 1); }
          }
        }
        for (const side of ['radiant', 'dire']) {
          const sidePlayers = players.filter(pl => (pl.is_radiant && side === 'radiant') || (!pl.is_radiant && side === 'dire'));
          for (const laneName of ['Safe', 'Off']) {
            const code = laneName === 'Safe' ? 1 : 3; const lanePlayers = sidePlayers.filter(pl => (pl.lane_role | 0) === code);
            if (lanePlayers.length === 2) { const pair = [Number(lanePlayers[0].hero_id), Number(lanePlayers[1].hero_id)].sort((a, b) => a - b); const key = `${pair[0]}-${pair[1]}`; const mp = laneName === 'Safe' ? duosSafe : duosOff; const rec = mp.get(key) || { games: 0, wins: 0 }; rec.games++; const laneWin = (side === 'radiant' && radWin) || (side === 'dire' && !radWin); if (laneWin) rec.wins++; mp.set(key, rec); }
          }
        }
        if (Array.isArray(md.objectives)) for (const ev of md.objectives) { if (/roshan_kill/i.test(String(ev.type || ''))) { const team = (ev.team === 2 || ev.team === 0 || ev.key === 'radiant') ? 'Radiant' : 'Dire'; roshanTeam[team]++; } }
        durList.push({ match_id: mid, duration: Number(md.duration || 0), radiant_win: radWin });
      }
  function topN(map, n) { return Array.from(map.entries()).map(([aid, c]) => { const id = Number(aid); const base = (resolver && resolver(id)) || `Player ${id}`; const tag = (teamResolver && teamResolver(id)) || ''; const name = tag ? `${base} (${tag})` : base; return { account_id: id, name, profile: OD_PLAYER_URL(id), count: c }; }).sort((a, b) => b.count - a.count).slice(0, n); }
      function duosFrom(mp) { return Array.from(mp.entries()).map(([k, v]) => { const [a, b] = k.split('-').map(Number); return { a, b, games: v.games, wins: v.wins, winrate: v.games ? v.wins / v.games : 0 }; }).sort((a, b) => b.winrate - a.winrate || b.games - a.games).slice(0, 5); }
      const topSingle = {}; if (bestGPM) topSingle.gpm = bestGPM; if (bestKills) topSingle.kills = bestKills; if (bestAssists) topSingle.assists = bestAssists; if (bestNet) topSingle.networth = bestNet;
      const durationLongest = durList.slice().sort((a, b) => b.duration - a.duration).slice(0, 3);
      const durationShortest = durList.slice().sort((a, b) => a.duration - b.duration).slice(0, 3);
      return { rampages: topN(rampages, 10), rapierTop: topN(rapierBy, 3), gemTop: topN(gemBy, 3), topSingle, safeDuos: duosFrom(duosSafe), offDuos: duosFrom(duosOff), roshan: roshanTeam, durationLongest, durationShortest };
    }

    function detailsToMatches(details, matchesFallback) {
      // Convert detailed match objects to the lightweight structure expected by aggregate()
      const out = [];
      // Build a quick lookup from matches.json for missing team IDs/names
      const matchById = new Map();
      if (Array.isArray(matchesFallback)) {
        for (const m of matchesFallback) {
          const mid = Number(m.match_id || 0);
          if (!mid) continue;
          matchById.set(mid, {
            radiant_team_id: Number(m.radiant_team_id || 0),
            dire_team_id: Number(m.dire_team_id || 0),
            radiant_name: m.radiant_name || '',
            dire_name: m.dire_name || ''
          });
        }
      }
      for (const d of details || []) {
        if (!d) continue;
        const mid = Number(d.match_id || 0);
        // Primary from details
        let radTeamId = Number(d.radiant_team_id || (d.radiant_team && d.radiant_team.team_id) || 0);
        let dirTeamId = Number(d.dire_team_id || (d.dire_team && d.dire_team.team_id) || 0);
        let radName = (d.radiant_team && d.radiant_team.name) || d.radiant_name || '';
        let dirName = (d.dire_team && d.dire_team.name) || d.dire_name || '';
        // Fallback from matches.json if details missing/0 or generic
        const isGeneric = (s) => { const t = (s||'').toString().trim(); return !t || /^radiant$/i.test(t) || /^dire$/i.test(t); };
        const fb = matchById.get(mid);
        if (fb) {
          if (!radTeamId && Number(fb.radiant_team_id || 0)) radTeamId = Number(fb.radiant_team_id || 0);
          if (!dirTeamId && Number(fb.dire_team_id || 0)) dirTeamId = Number(fb.dire_team_id || 0);
          if (isGeneric(radName) && fb.radiant_name) radName = fb.radiant_name;
          if (isGeneric(dirName) && fb.dire_name) dirName = fb.dire_name;
        }
        if (!radName) radName = 'Radiant';
        if (!dirName) dirName = 'Dire';
        const players = Array.isArray(d.players) ? d.players.map(p => ({
          account_id: Number(p.account_id || 0),
          hero_id: Number(p.hero_id || 0),
          // Robust radiant detection across schemas
          is_radiant: !!(p.isRadiant ?? p.is_radiant ?? ((p.player_slot|0) < 128)),
          personaname: p.personaname || null
        })) : [];
        const picks_bans = Array.isArray(d.picks_bans) ? d.picks_bans.map(pb => ({
          hero_id: Number(pb.hero_id || 0),
          is_pick: !!pb.is_pick,
          team: (pb.team !== undefined ? Number(pb.team) : (pb.is_radiant ? 0 : 1)),
          order: Number(pb.order || pb.pick_order || pb.draft_order || 0)
        })) : [];
        out.push({
          match_id: mid,
          radiant_win: !!d.radiant_win,
          radiant_team_id: radTeamId,
          dire_team_id: dirTeamId,
          radiant_name: radName,
          dire_name: dirName,
          players,
          picks_bans
        });
      }
      return out;
    }

    function renderHighlights(high) {
      const card = document.getElementById('highlightsCard');
      const body = document.getElementById('highlightsBody');
      if (!high) { card.style.display = 'none'; body.innerHTML = ''; return; }
      function simple(arr) { if (!Array.isArray(arr) || !arr.length) return `<li><span class='sub'>no data</span></li>`; return arr.map(it => `<li><span>${it.name}</span><span class='badge'>x${it.count}</span></li>`).join(''); }
      function durList(arr) { if (!Array.isArray(arr) || !arr.length) return `<li><span class='sub'>no games</span></li>`; return arr.map(x => { const sec = Number(x.duration || 0); const mm = Math.floor(sec / 60), ss = sec % 60; return `<li><span><a target='_blank' href='${OD_MATCH_URL(x.match_id)}'>M${x.match_id}</a></span><span class='badge'>${mm}m ${ss}s</span></li>`; }).join(''); }
      function topPerf() {
        const order = ['gpm', 'kills', 'assists', 'networth']; const icons = { gpm: 'üí∞', kills: '‚öîÔ∏è', assists: 'ü§ù', networth: 'üíé' };
        return `<div class='perf-grid'>` + order.map(k => { const p = high.topSingle[k]; if (!p) return ''; return `<div class='perf-card'><div class='perf-left'><div class='perf-icon'>${icons[k]}</div><div class='perf-meta'><div class='perf-label'>${k}</div><div class='perf-player'><a href='${p.profile}' target='_blank'>${p.name}</a></div></div></div><div class='perf-actions'><div class='perf-value'>${p.value}</div><a class='badge' target='_blank' href='${OD_MATCH_URL(p.match_id)}'>Match</a></div></div>`; }).join('') + `</div>`;
      }
      body.innerHTML = `
        ${topPerf()}
        <div class='grid3' style='display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:12px;margin-top:8px'>
          <div><h3>Rampages</h3><ul class='simple'>${simple(high.rampages)}</ul></div>
          <div><h3>Rapiers</h3><ul class='simple'>${simple(high.rapierTop)}</ul></div>
          <div><h3>Gems</h3><ul class='simple'>${simple(high.gemTop)}</ul></div>
        </div>
        <div style='margin-top:8px'>
          <h3>Roshan Taken</h3>
          <ul class='simple'>
            <li><span>Radiant</span><span class='badge'>x${high.roshan.Radiant}</span></li>
            <li><span>Dire</span><span class='badge'>x${high.roshan.Dire}</span></li>
          </ul>
        </div>
        <div class='grid2' style='display:grid;grid-template-columns:repeat(auto-fit,minmax(260px,1fr));gap:12px;margin-top:8px'>
          <div><h3>3 longest matches</h3><ul class='simple'>${durList(high.durationLongest)}</ul></div>
          <div><h3>3 shortest matches</h3><ul class='simple'>${durList(high.durationShortest)}</ul></div>
        </div>`;
      card.style.display = '';
    }

    function computeAwardsFromDetails(details, resolver) {
      const agg = new Map(); // aid -> aggregated stats
      function ensure(aid){ if (!agg.has(aid)) agg.set(aid, { games:0, wins:0, k:0, a:0, d:0, gpmTotal:0, obs:0, sent:0, obsLog:0, sentLog:0, mvpCount:0, dmg:0, tdmg:0, lh10:0, stuns:0, visionScore:0, kpSum:0, name: (resolver && resolver(aid)) || `Player ${aid}`, profile: OD_PLAYER_URL(aid) }); return agg.get(aid); }
      for (const md of details) {
        if (!md) continue; const radWin = !!md.radiant_win;
        // Per-match MVP proxy: pick the player with highest score = kills*2 + assists + gpm/100 + (win?1:0)
        let best = null;
        for (const p of (md.players || [])) {
          const aid = Number(p.account_id || 0); if (!(aid > 0)) continue; const won = p.is_radiant ? radWin : !radWin;
          const st = ensure(aid); st.games++; if (won) st.wins++;
          const k = Number(p.kills || 0), a = Number(p.assists || 0), d = Number(p.deaths || 0), gpm = Number(p.gold_per_min || 0);
          st.k += k; st.a += a; st.d += d; st.gpmTotal += gpm;
          st.dmg += Number(p.hero_damage || 0);
          st.tdmg += Number(p.tower_damage || 0);
          // Last hits at 10 (when available)
          try { if (p.lh_t && (Array.isArray(p.lh_t) || typeof p.lh_t === 'object')) { const arr = Array.isArray(p.lh_t) ? p.lh_t : Object.values(p.lh_t); if (arr && arr.length > 10) st.lh10 += Number(arr[10] || 0); } } catch(_e) {}
          st.stuns += Number(p.stuns || 0);
          const obsPlaced = Number(p.obs_placed || 0), senPlaced = Number(p.sen_placed || 0);
          st.obs += obsPlaced; st.sent += senPlaced; st.visionScore += obsPlaced + senPlaced;
          const oblog = Array.isArray(p.obs_log) ? p.obs_log.length : 0; const sl = Array.isArray(p.sen_log) ? p.sen_log.length : 0;
          st.obsLog += oblog; st.sentLog += sl; st.visionScore += oblog + sl + Number(p.camps_stacked || 0);
          const score = (k*2) + a + (gpm/100) + (won ? 1 : 0);
          if (!best || score > best.score) best = { aid, score };
        }
        // Kill participation proxy per team
        const radKills = (md.players||[]).filter(x=>x.is_radiant).reduce((s,x)=> s + Number(x.kills||0),0);
        const dirKills = (md.players||[]).filter(x=>!x.is_radiant).reduce((s,x)=> s + Number(x.kills||0),0);
        for (const p of (md.players||[])) {
          const aid = Number(p.account_id||0); if (!(aid>0)) continue;
          const teamKills = p.is_radiant ? radKills : dirKills; const kp = teamKills>0 ? (Number(p.kills||0)+Number(p.assists||0))/teamKills : 0;
          ensure(aid).kpSum += kp;
        }
        if (best && agg.has(best.aid)) agg.get(best.aid).mvpCount++;
      }
      const list = Array.from(agg.entries()).map(([aid, v]) => ({ aid: Number(aid), ...v, kda: (v.k + v.a) / Math.max(1, v.d), avgGpm: v.games ? v.gpmTotal / v.games : 0, avgWards: v.games ? (v.obs + v.sent) / v.games : 0, avgDmg: v.games? v.dmg/v.games:0, avgTDmg: v.games? v.tdmg/v.games:0, avgLH10: v.games? v.lh10/v.games:0, avgStuns: v.games? v.stuns/v.games:0, avgVisionScore: v.games? v.visionScore/v.games:0, avgKP: v.games? v.kpSum/v.games:0 }));
      const minGames = Math.max(3, Math.min(5, Math.floor(list.reduce((m,x)=>Math.max(m,x.games),0) * 0.2) || 3));
      function topBy(fn, filter = x=>x.games>=minGames, n=3){ return list.filter(filter).sort((a,b)=> fn(b)-fn(a) || b.games - a.games).slice(0,n); }
      return {
        mvp: topBy(x=>x.mvpCount, x=>x.mvpCount>0).map(x=>({ name:x.name, profile:x.profile, count:x.mvpCount, games:x.games })),
        bestKDA: topBy(x=>x.kda).map(x=>({ name:x.name, profile:x.profile, kda:x.kda, k:x.k, a:x.a, d:x.d, games:x.games })),
        bestGPM: topBy(x=>x.avgGpm).map(x=>({ name:x.name, profile:x.profile, gpm:x.avgGpm, games:x.games })),
        visionary: topBy(x=>x.avgWards).map(x=>({ name:x.name, profile:x.profile, wards:x.avgWards, games:x.games })),
        mostDamage: topBy(x=>x.avgDmg).map(x=>({ name:x.name, profile:x.profile, dmg:Math.round(x.avgDmg), games:x.games })),
        mostTowerDamage: topBy(x=>x.avgTDmg).map(x=>({ name:x.name, profile:x.profile, tdmg:Math.round(x.avgTDmg), games:x.games })),
        bestCS10: topBy(x=>x.avgLH10).map(x=>({ name:x.name, profile:x.profile, lh10:Math.round(x.avgLH10), games:x.games })),
        mostStuns: topBy(x=>x.avgStuns).map(x=>({ name:x.name, profile:x.profile, stuns:x.avgStuns.toFixed(1), games:x.games })),
        bestVisionScore: topBy(x=>x.avgVisionScore).map(x=>({ name:x.name, profile:x.profile, vs:x.avgVisionScore.toFixed(1), games:x.games })),
        bestKP: topBy(x=>x.avgKP).map(x=>({ name:x.name, profile:x.profile, kp:(x.avgKP*100).toFixed(1)+'%', games:x.games }))
      };
    }
    function renderAwards(awards) {
      const root = document.getElementById('awardsBody'); if (!root) return;
      function simple(items, fmt){ if (!items || !items.length) return '<div class="sub">no data</div>'; return '<ul class="simple">'+items.map(it=>`<li><span><a href='${it.profile}' target='_blank'>${it.name}</a></span><span class='badge'>${fmt(it)}</span></li>`).join('')+'</ul>'; }
      root.innerHTML = `
        <div class='summary-grid'>
          <div class='summary-card'>
            <h3>MVP (match tops)</h3>
            ${simple(awards.mvp, it=>`x${it.count}`)}
          </div>
          <div class='summary-card'>
            <h3>Best KDA</h3>
            ${simple(awards.bestKDA, it=>`${(it.kda).toFixed(2)} (${it.k}/${it.d}/${it.a})`)}
          </div>
          <div class='summary-card'>
            <h3>Best GPM</h3>
            ${simple(awards.bestGPM, it=>`${Math.round(it.gpm)} gpm`)}
          </div>
          <div class='summary-card'>
            <h3>Visionary</h3>
            ${simple(awards.visionary, it=>`${it.wards.toFixed(1)} wards/game`)}
          </div>
          <div class='summary-card'>
            <h3>Most Damage</h3>
            ${simple(awards.mostDamage, it=>`${it.dmg} hero dmg`)}
          </div>
          <div class='summary-card'>
            <h3>Most Tower Damage</h3>
            ${simple(awards.mostTowerDamage, it=>`${it.tdmg} tower dmg`)}
          </div>
          <div class='summary-card'>
            <h3>Best CS @10</h3>
            ${simple(awards.bestCS10, it=>`${it.lh10} LH @10`)}
          </div>
          <div class='summary-card'>
            <h3>Most Stuns</h3>
            ${simple(awards.mostStuns, it=>`${it.stuns} stuns`)}
          </div>
          <div class='summary-card'>
            <h3>Best Vision Score</h3>
            ${simple(awards.bestVisionScore, it=>`${it.vs} score`)}
          </div>
          <div class='summary-card'>
            <h3>Best Kill Participation</h3>
            ${simple(awards.bestKP, it=>`${it.kp}`)}
          </div>
        </div>`;
    }

    

    async function main() {
      (function () {
        const tabsRoot = document.getElementById('mainTabs'); const tabs = Array.from(tabsRoot.querySelectorAll('.tab'));
        // ensure ids and ARIA linkage
  tabs.forEach(btn=>{ const name = btn.getAttribute('data-tab'); if(!btn.id) btn.id = `tab-${name}`; btn.setAttribute('role','tab'); btn.setAttribute('aria-selected', btn.classList.contains('active')?'true':'false'); btn.setAttribute('tabindex','0'); const pane = document.getElementById(`pane-${name}`); if(pane){ pane.setAttribute('role','tabpanel'); pane.setAttribute('aria-labelledby', btn.id); if(!btn.classList.contains('active')) pane.setAttribute('hidden',''); }});
        function showTab(name) {
          const order = ['highlights','players','heroes','draft','teams','placement','awards','laneduos','itemsbought','wards'];
          order.forEach(id => { const pane = document.getElementById('pane-' + id); const active = (id === name); if (pane) { pane.style.display = active ? '' : 'none'; if(active) pane.removeAttribute('hidden'); else pane.setAttribute('hidden',''); pane.setAttribute('aria-busy','false'); }});
          tabs.forEach(b => { const active = (b.getAttribute('data-tab') === name); b.classList.toggle('active', active); b.setAttribute('aria-selected', active?'true':'false'); b.setAttribute('tabindex','0'); });
          try { localStorage.setItem('lv_tab', name || 'highlights'); } catch (_e) {}
          // Keep URL in sync for sharing
          try {
            const url = new URL(location.href);
            url.searchParams.set('tab', name || 'highlights');
            history.replaceState(null, '', url);
          } catch(_e){}
          // Lazy-mount heavy tabs when opened
          if (name === 'draft' && window.__ensureDraft) window.__ensureDraft();
          if (name === 'laneduos' && window.__ensureLaneDuos) window.__ensureLaneDuos();
          if (name === 'itemsbought' && window.__ensureItems) window.__ensureItems();
          if (name === 'wards' && window.__ensureWards) window.__ensureWards();
          if (name === 'awards' && window.__ensureAwards) window.__ensureAwards();
          if (name === 'placement' && window.__ensurePlacement) window.__ensurePlacement();
          try{ const activeBtn = tabs.find(b=> b.getAttribute('data-tab')===name); if(activeBtn) activeBtn.focus(); }catch(_e){}
        }
        tabs.forEach(b => b.addEventListener('click', () => showTab(b.getAttribute('data-tab'))));
        tabsRoot.addEventListener('keydown', (ev)=>{
          const activeEl = document.activeElement;
          const idx = tabs.indexOf(activeEl);
          if (idx === -1) return; // not focused on a tab
          if (ev.key==='ArrowRight' || ev.key==='ArrowLeft' || ev.key==='Home' || ev.key==='End') { ev.preventDefault(); }
          if (ev.key==='ArrowRight') { const ni=(idx+1)%tabs.length; tabs[ni].focus(); showTab(tabs[ni].getAttribute('data-tab')); }
          else if (ev.key==='ArrowLeft') { const ni=(idx-1+tabs.length)%tabs.length; tabs[ni].focus(); showTab(tabs[ni].getAttribute('data-tab')); }
          else if (ev.key==='Home') { tabs[0].focus(); showTab(tabs[0].getAttribute('data-tab')); }
          else if (ev.key==='End') { const last=tabs[tabs.length-1]; last.focus(); showTab(last.getAttribute('data-tab')); }
        });
        window.__lvShowTab = showTab;
      })();
      // Global digit shortcuts: 1‚Äì0 jump to main tabs (1=first ‚Ä¶ 0=10th). No modifiers, ignore while typing.
      try{
        document.addEventListener('keydown', (ev)=>{
          if (ev.altKey || ev.ctrlKey || ev.metaKey) return;
          const el = document.activeElement;
          const tag = (el && el.tagName) ? el.tagName.toLowerCase() : '';
          const typing = (tag==='input' || tag==='textarea' || tag==='select' || (el && el.isContentEditable));
          if (typing) return;
          const key = ev.key; if (!(/^\d$/.test(key))) return;
          const n = (key === '0') ? 10 : parseInt(key, 10);
          const root = document.getElementById('mainTabs'); if(!root) return;
          const tabs = Array.from(root.querySelectorAll('.tab')); if(!tabs.length) return;
          const idx = n - 1; if (idx < 0 || idx >= tabs.length) return;
          const target = tabs[idx]; if(!target) return;
          ev.preventDefault(); target.focus(); if(window.__lvShowTab) window.__lvShowTab(target.getAttribute('data-tab'));
        });
      }catch(_e){}

  // Allow overriding repo/branch and raw preference via URL params to avoid 404s when browsing locally or on a non-main branch
  const __sp_local = new URLSearchParams((typeof location !== 'undefined' && location.search) || '');
  const REPO = (__sp_local.get('repo') || 'Zeroks77/Kret_Dota');
  const BRANCH = (__sp_local.get('branch') || 'main');
  const PREFER_RAW = (__sp_local.get('preferRaw') === '1' || __sp_local.get('raw') === '1');
  const relBase = (typeof location !== 'undefined' && (/\.github\.io$/i.test(String(location.hostname||'')) || /\/docs\/?$/i.test(String(location.pathname||'')))) ? 'data' : '../data';
  const rawBase = `https://raw.githubusercontent.com/${REPO}/${BRANCH}/data`, rawDocsBase = `https://raw.githubusercontent.com/${REPO}/${BRANCH}/docs/data`;
  const sp = (window.UrlParams && UrlParams.canonicalizeInPlace) ? UrlParams.canonicalizeInPlace() : new URLSearchParams(location.search); const slug = sp.get('league') || 'TI2025';

    // Optional: explicit folder under docs containing matches.json/report.json (e.g., 'league/2025/TI2025')
    const leaguePath = (sp.get('leaguePath') || '').replace(/^\/+/, '').replace(/\/+$/, '');
    const relBases = [
      ...(leaguePath ? [leaguePath] : []),
      // Prefer docs/data when running under GH Pages; otherwise prefer ../data when browsing repo locally
      ...(IS_GHPAGES ? ['data','../data'] : ['../data','data'])
    ];
    const fromBases = (p) => relBases.map(b => `${b}/${p}`);
    // Parallelize all initial JSON loads
    function pref(relArr, rawArr){ return PREFER_RAW ? [...rawArr, ...relArr] : [...relArr, ...rawArr]; }
  const [matchesRaw, heroesRaw, mapConfRaw, report, proPlayers, patchRaw] = await Promise.all([
      // League-specific files primarily live under docs/data/league/<slug>/ ...
      loadFirst(pref(
        fromBases(`league/${slug}/matches.json`),
        [`${rawBase}/league/${slug}/matches.json`, `${rawDocsBase}/league/${slug}/matches.json`]
      )),
      // Core constants exist in both data/ and docs/data/
      loadFirst(pref(
        fromBases(`heroes.json`),
        [`${rawBase}/heroes.json`, `${rawDocsBase}/heroes.json`]
      )),
      loadFirst(pref(
        fromBases(`maps.json`),
        [`${rawBase}/maps.json`, `${rawDocsBase}/maps.json`]
      )),
      loadFirst(pref(
        fromBases(`league/${slug}/report.json`),
        [`${rawBase}/league/${slug}/report.json`, `${rawDocsBase}/league/${slug}/report.json`]
      )),
      loadFirst(pref(
        fromBases(`cache/OpenDota/proPlayers.json`),
        [`${rawBase}/cache/OpenDota/proPlayers.json`, `${rawDocsBase}/cache/OpenDota/proPlayers.json`]
      )),
      // Patches constants for Trend markers
      loadFirst(pref(
        fromBases(`constants/patch.json`),
        [`${rawBase}/constants/patch.json`, `${rawDocsBase}/constants/patch.json`]
      ))
    ]);
  const matches = Array.isArray(matchesRaw) ? matchesRaw : (matchesRaw && matchesRaw.matches ? matchesRaw.matches : []);
    const heroes = makeHeroMap(heroesRaw);
  const mapConf = mapConfRaw || {};
  const patches = buildPatchList(patchRaw);
      try {
        const name = (report && ((report.meta && (report.meta.name || report.meta.title)) || (report.league && report.league.name))) || slug;
        document.getElementById('leagueTitle').textContent = `${name} ‚Äì League viewer`;
        const times = matches.map(m => m.start_time).filter(Boolean); const min = Math.min(...times), max = Math.max(...times);
        const fmt = s => { const d = new Date(s * 1000); return d.toISOString().slice(0, 10); };
        const hdr = document.getElementById('headerSub');
        if (hdr) {
          let txt = `${matches.length} matches ¬∑ ${isFinite(min) ? fmt(min) : '?'} to ${isFinite(max) ? fmt(max) : '?'} (UTC)`;
          // Optional build info (generated_at and commit)
          try {
            const genAt = (report && report.meta && (report.meta.generated_at || report.meta.generatedAt)) || (report && (report.generated_at || report.generatedAt));
            if (genAt) {
              const dt = new Date(genAt);
              if (!isNaN(dt.getTime())) txt += ` ¬∑ data as of ${dt.toISOString().replace('T',' ').slice(0,19)}Z`;
            }
            const commit = report && report.meta && (report.meta.commit || report.meta.git_commit || report.meta.sha);
            if (commit && typeof commit === 'string' && commit.length >= 7) {
              const short = commit.slice(0,7);
              const url = `https://github.com/${REPO}/commit/${commit}`;
              txt += ` ¬∑ <a href="${url}" target="_blank" rel="noopener">${short}</a>`;
            }
          } catch(_e){}
          hdr.innerHTML = txt;
        }
        const rl = document.getElementById('rangeLabel'); if (rl) rl.textContent = `${matches.length} matches`;
      } catch (_e) {}

  const playerNames = {}, teamNames = {};
      // Build pro metadata: display name + optional team tag/name from proPlayers
      const proMap = new Map(); // aid -> display name
      const proMeta = new Map(); // aid -> { name, team_tag, team_name }
      if (Array.isArray(proPlayers)) {
        for (const p of proPlayers) {
          const aid = Number(p && p.account_id || 0); if (!(aid > 0)) continue;
          const nm = (p.name && String(p.name).trim()) || (p.personaname && String(p.personaname).trim()) || null;
          if (nm) proMap.set(aid, nm);
          proMeta.set(aid, {
            name: nm || null,
            team_tag: (p.team_tag && String(p.team_tag).trim()) || null,
            team_name: (p.team_name && String(p.team_name).trim()) || null
          });
        }
      }
      // 1) Overlay names from report.playerTeams first (league-scoped canonical names)
      try {
        const pts = report && report.playerTeams; if (Array.isArray(pts)) {
          for (const it of pts) {
            const aid = Number(it && it.account_id || 0); if (!(aid > 0)) continue;
            const nm = (it.name && String(it.name).trim()) || null; if (nm) playerNames[String(aid)] = nm;
            const tid = Number(it.team_id || 0); const tn = (it.team_name && String(it.team_name).trim()) || null;
            if (tid && tn) teamNames[String(tid)] = tn;
          }
        }
      } catch(_e){}

      // 2) Add/complete from matches list (fallbacks)
      for (const m of matches) {
        if (Array.isArray(m.players)) for (const p of m.players) {
          if (p && p.account_id > 0) {
            const aid = Number(p.account_id);
            const pro = proMap.get(aid);
            const nm = pro || (p.personaname || '').trim();
            if (nm && !playerNames[String(aid)]) playerNames[String(aid)] = nm;
          }
        }
        if (m.radiant_team_id && m.radiant_name && !teamNames[String(m.radiant_team_id)]) teamNames[String(m.radiant_team_id)] = m.radiant_name;
        if (m.dire_team_id && m.dire_name && !teamNames[String(m.dire_team_id)]) teamNames[String(m.dire_team_id)] = m.dire_name;
      }

  const agg = aggregate(matches, playerNames, teamNames);
  render(agg, heroes);
      enableSorting();
      // Start fetching details in background with higher concurrency
      const ids = matches.map(m => m.match_id).filter(Boolean);
      const conc = Math.min(8, Math.max(4, (typeof navigator !== 'undefined' && navigator.hardwareConcurrency) ? navigator.hardwareConcurrency : 4));
      // Caching: try hydrate details from localStorage first
      const cacheKey = `lv_details_${slug}`;
      const cacheMetaKey = `lv_details_meta_${slug}`;
      function computeFingerprint(ms){ try{ const ids = (ms||[]).map(m=>m.match_id).filter(Boolean).sort().join(','); return String(ids).slice(-100); }catch(_e){ return 'na'; } }
      const expectedFp = computeFingerprint(matches);
      let cachedDetails = null;
      try {
        const meta = JSON.parse(localStorage.getItem(cacheMetaKey) || 'null');
        if (meta && meta.fp === expectedFp) {
          const raw = localStorage.getItem(cacheKey);
          if (raw) cachedDetails = JSON.parse(raw);
        }
      } catch(_e){}
      const detailsPromise = (async ()=>{
        if (Array.isArray(cachedDetails) && cachedDetails.length){ return cachedDetails; }
        const arr = await pMap(ids, conc, id => fetchMatchDetail(id, relBase, rawBase));
        const cleaned = (arr || []).filter(Boolean);
        try { localStorage.setItem(cacheKey, JSON.stringify(cleaned)); localStorage.setItem(cacheMetaKey, JSON.stringify({ fp: expectedFp, ts: Date.now(), count: cleaned.length })); } catch(_e){}
        return cleaned;
      })();

      // Once details are ready, enhance names/teams and render Highlights immediately
  let __detailsCache = null, __resolver = null, __teamResolver = null, __highCache = null;
      detailsPromise.then(details => {
        __detailsCache = details;
        // Build names from details and overlay into playerNames with pro priority
        const namesFromDetails = {};
        for (const d of details) {
          for (const p of (d.players || [])) {
            const aid = Number(p.account_id || 0); if (!(aid > 0)) continue;
            const nm = (p.personaname && String(p.personaname).trim()) || '';
            if (nm) namesFromDetails[String(aid)] = nm;
            const pro = proMap.get(aid);
            if (pro) playerNames[String(aid)] = pro; else if (nm) playerNames[String(aid)] = nm;
          }
        }
        // Build per-player team from league details using team IDs
        const teamNameById = new Map();
        const teamIdCountByAid = new Map();
        const teamLabelCountByAid = new Map(); // aid -> Map<label, count>
        const isGeneric = (s) => { const t = (s||'').toString().trim(); return !t || /^radiant$/i.test(t) || /^dire$/i.test(t); };
        for (const d of details) {
          const rid = Number(d.radiant_team_id || (d.radiant_team && d.radiant_team.team_id) || 0);
          const did = Number(d.dire_team_id || (d.dire_team && d.dire_team.team_id) || 0);
          const rnameRaw = (d.radiant_team && d.radiant_team.name) || d.radiant_name || teamNames[String(rid)] || 'Radiant';
          const dnameRaw = (d.dire_team && d.dire_team.name) || d.dire_name || teamNames[String(did)] || 'Dire';
          const rname = isGeneric(rnameRaw) ? '' : String(rnameRaw);
          const dname = isGeneric(dnameRaw) ? '' : String(dnameRaw);
          if (rid) teamNameById.set(rid, rname || `Team ${rid}`); if (did) teamNameById.set(did, dname || `Team ${did}`);
          for (const p of (d.players || [])) {
            const aid = Number(p.account_id || 0); if (!(aid > 0)) continue;
            const tid = p.is_radiant ? rid : did; if (!tid) continue;
            if (!teamIdCountByAid.has(aid)) teamIdCountByAid.set(aid, new Map());
            const inner = teamIdCountByAid.get(aid);
            inner.set(tid, (inner.get(tid) || 0) + 1);
            const label = p.is_radiant ? rname : dname;
            if (label) {
              if (!teamLabelCountByAid.has(aid)) teamLabelCountByAid.set(aid, new Map());
              const lmap = teamLabelCountByAid.get(aid);
              lmap.set(label, (lmap.get(label) || 0) + 1);
            }
          }
        }
        // Pre-build mapping from report.playerTeams if provided by backend generation
        const playerTeamMap = new Map();
        try {
          const arr = report && report.playerTeams; if (Array.isArray(arr)) {
            for (const it of arr) {
              const id = Number(it && it.account_id || 0); if (!(id > 0)) continue;
              const nm = (it.team_name && String(it.team_name).trim()) || '';
              if (nm) playerTeamMap.set(id, nm);
            }
          }
        } catch(_e){}

        __teamResolver = (aid) => {
          const id = Number(aid);
          // Backend-provided mapping preferred
          if (playerTeamMap.has(id)) return playerTeamMap.get(id);
          // Prefer most frequent non-generic team label observed in details
          const lmap = teamLabelCountByAid.get(id);
          if (lmap && lmap.size) {
            let bestLabel = '', bestCnt = -1;
            for (const [label, cnt] of lmap.entries()) { if (cnt > bestCnt) { bestCnt = cnt; bestLabel = label; } }
            if (bestLabel) return bestLabel;
          }
          // Fallback: choose most frequent team id, map to name
          const inner = teamIdCountByAid.get(id);
          if (inner && inner.size) {
            let bestId = 0, bestG = -1;
            for (const [tid, g] of inner.entries()) { if (g > bestG) { bestG = g; bestId = tid; } }
            if (bestId) return teamNameById.get(bestId) || `Team ${bestId}`;
          }
          // Do not use global pro metadata as a fallback here to avoid stale/wrong teams for the league timeframe
          return '';
        };
        __resolver = (aid) => (proMap.get(Number(aid)) || namesFromDetails[String(aid)] || playerNames[String(aid)] || null);

  // Overlay non-generic team names from details for accurate team display
    try { for (const [tid, nm] of teamNameById.entries()) { if (tid && nm && !/^radiant|dire$/i.test(String(nm))) teamNames[String(tid)] = nm; } } catch (_e) {}

  // Re-render tables using detailed data (players, picks/bans) and team resolver
  const matchesFromDetails = detailsToMatches(details, matches);
  const agg2 = aggregate(matchesFromDetails.length ? matchesFromDetails : matches, playerNames, teamNames);
        render(agg2, heroes, { teamResolver: __teamResolver });

        // Compute and render Highlights now
        __highCache = computeHighlightsFromDetails(details, __resolver, __teamResolver);
        renderHighlights(__highCache);
      }).catch(e => console.warn('Details processing failed', e));

      // Lazy mount helpers for heavy tabs
  let mountedDraft = false, mountedLaneDuos = false, mountedItems = false, mountedWards = false, mountedAwards = false, mountedPlacement = false;
      window.__ensureDraft = () => {
        if (mountedDraft) return; mountedDraft = true;
        try {
          const pre = report && report.highlights && report.highlights.draft;
          if (window.DraftViewer && pre && (Array.isArray(pre.contest) || Array.isArray(pre.firstPicks) || Array.isArray(pre.openingPairs))) {
            // Pass full precomputed draft block so charts (top picked/banned), captains, and totals are available
            window.DraftViewer.mount(document.getElementById('draftMount'), { data: pre, heroes, persistKey: `lv_draft_${slug}`, nameResolver: (__resolver || ((aid)=> (playerNames[String(aid)] || `Player ${aid}`))) });
            return;
          }
        } catch(e){ console.warn('DraftViewer precomputed mount failed, falling back', e); }
        // Fallback to client-side computation when precompute not available
        detailsPromise.then(details => {
          try { if (window.DraftViewer) { const draftData = window.DraftViewer.compute(details); window.DraftViewer.mount(document.getElementById('draftMount'), { data: draftData, heroes, persistKey: `lv_draft_${slug}`, nameResolver: (__resolver || ((aid)=> (playerNames[String(aid)] || `Player ${aid}`))) }); } }
          catch(e){ console.warn('DraftViewer mount failed', e); }
        });
      };
      window.__ensureLaneDuos = () => {
        if (mountedLaneDuos) return; mountedLaneDuos = true;
        try {
          const mountEl = document.getElementById('ldMount');
          const pre = report && report.highlights && report.highlights.duos;
          if (window.LaneDuosViewer && pre) {
            const safe = Array.isArray(pre.safelane) ? pre.safelane : [];
            const off = Array.isArray(pre.offlane) ? pre.offlane : [];
            window.LaneDuosViewer.mount(mountEl, { data: { safe, off }, heroes, persistKey: `lv_laneduos_${slug}` });
            return;
          }
        } catch(e){ console.warn('LaneDuosViewer precomputed mount failed, falling back', e); }
        // Fallback to client-side computation when precompute not available
        detailsPromise.then(() => {
          try { if (window.LaneDuosViewer && __highCache) { window.LaneDuosViewer.mount(document.getElementById('ldMount'), { data: { safe: __highCache.safeDuos || [], off: __highCache.offDuos || [] }, heroes, persistKey: `lv_laneduos_${slug}` }); } }
          catch(e){ console.warn('LaneDuosViewer mount failed', e); }
        });
      };
      window.__ensureItems = () => {
        if (mountedItems) return; mountedItems = true;
        detailsPromise.then(details => {
            try {
            const ib = document.getElementById('ibMount'); if (!ib) return;
            // Role heuristic via GPM
            const roleCache = new Map();
            for (const md of details || []) {
              for (const p of (md.players || [])) {
                const aid = Number(p.account_id || 0); if (!(aid > 0)) continue;
                const gpm = Number(p.gold_per_min || 0);
                roleCache.set(aid, gpm >= 420 ? 'core' : 'support');
              }
            }
            const itemAgg = new Map();
            const consumables = new Set(['tango','flask','healing_salve','enchanted_mango','clarity','faerie_fire','smoke_of_deceit','dust','dust_of_appearance','ward_observer','ward_sentry','sentry_wards','observer_ward','sentry_ward','tpscroll','tp_scroll','enchanted_quiver','bottle','refresher_shard','cheese','tome_of_knowledge','blood_grenade']);
            const norm = (k) => String(k || '').toLowerCase();
            for (const md of details || []) {
              for (const p of (md.players || [])) {
                const aid = Number(p.account_id || 0); if (!(aid > 0)) continue;
                const role = roleCache.get(aid) || 'support';
                const log = Array.isArray(p.purchase_log) ? p.purchase_log : [];
                for (const ev of log) {
                  const key = norm(ev.key || ev.item || ''); if (!key || /recipe_/.test(key)) continue;
                  const rec = itemAgg.get(key) || { count: 0, coreCount: 0, supportCount: 0, cost: 0, consumable: false };
                  rec.count++; if (role === 'core') rec.coreCount++; else rec.supportCount++;
                  if (consumables.has(key)) rec.consumable = true;
                  itemAgg.set(key, rec);
                }
              }
            }
            if (__highCache) {
              (__highCache.rapierTop || []).forEach(r => { const key = 'rapier'; const rec = itemAgg.get(key) || { count: 0, coreCount: 0, supportCount: 0, cost: 6000, consumable: false, display: 'Divine Rapier' }; rec.count += r.count; itemAgg.set(key, rec); });
              (__highCache.gemTop || []).forEach(r => { const key = 'gem'; const rec = itemAgg.get(key) || { count: 0, coreCount: 0, supportCount: 0, cost: 900, consumable: true, display: 'Gem of True Sight' }; rec.count += r.count; rec.consumable = true; itemAgg.set(key, rec); });
            }
            const items = Array.from(itemAgg.entries()).map(([k, v]) => {
              const role = v.coreCount === v.supportCount ? (v.coreCount > 0 ? 'core' : 'support') : (v.coreCount > v.supportCount ? 'core' : 'support');
              const namePretty = v.display || k.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
              return { item: k, name: namePretty, count: v.count, gold: v.cost || 0, role, consumable: v.consumable };
            }).sort((a, b) => b.count - a.count || b.gold - a.gold || a.name.localeCompare(b.name));
            const meta = {}; for (const it of items) { meta[it.item] = { cost: it.gold, consumable: it.consumable, role: it.role }; }
            window.ItemsBoughtViewer.mount(ib, { data: { items, meta, playerNames } });
          } catch(e){ console.warn('ItemsBoughtViewer mount failed', e); }
        });
      };
      
      
  window.__ensureWards = () => {
        if (mountedWards) return; mountedWards = true;
        detailsPromise.then(details => {
          // Mount Spots into std host using WardViewer (no extras)
          try {
            const stdHost = document.getElementById('dvWardStd');
            const container = document.getElementById('dvWardMount');
            if (stdHost && container && window.WardViewer) {
              const countBy = new Map(), totalBy = new Map(), samplesBy = new Map();
              const senCountBy = new Map(), senBySide = new Map(), senByTeam = new Map(), senSamplesBy = new Map();
              const playersSet = new Map();
              const teamNameByIdLocal = new Map();
              const placerCount = new Map();
              for (const md of details||[]) {
                const dur = Number(md.duration||0);
                const rid = Number(md.radiant_team_id || (md.radiant_team && md.radiant_team.team_id) || 0);
                const did = Number(md.dire_team_id || (md.dire_team && md.dire_team.team_id) || 0);
                const rname = (md.radiant_team && md.radiant_team.name) || md.radiant_name || teamNames[String(rid)] || 'Radiant';
                const dname = (md.dire_team && md.dire_team.name) || md.dire_name || teamNames[String(did)] || 'Dire';
                if (rid) teamNameByIdLocal.set(rid, rname);
                if (did) teamNameByIdLocal.set(did, dname);
                for (const p of (md.players||[])) {
                  const aid = Number(p.account_id||0);
                  const isRad = !!(p.isRadiant ?? p.is_radiant ?? ((p.player_slot|0) < 128));
                  const teamId = isRad ? rid : did;
                  const side = isRad ? 'Radiant' : 'Dire';
                  const obs = Array.isArray(p.obs_log) ? p.obs_log : [];
                  const left = Array.isArray(p.obs_left_log) ? p.obs_left_log : [];
                  const L = left.map(o => ({ x:o.x, y:o.y, time:Number(o.time||0) })).sort((a,b)=>a.time-b.time);
                  if (aid > 0 && obs.length) {
                    const nm = (__resolver && __resolver(aid)) || playerNames[String(aid)] || p.personaname || `Player ${aid}`;
                    if (!playersSet.has(aid)) playersSet.set(aid, nm);
                  }
                  for (const o of obs) {
                    const start = Number(o.time||0); let removal=null;
                    for (const l of L) { if (!l.used && l.x===o.x && l.y===o.y && Number(l.time||0) >= start) { removal=l; l.used=true; break; } }
                    let life = removal ? (removal.time - start) : Math.min(360, Math.max(0, dur - start)); if (life>360) life=360;
                    const k = `${o.x},${o.y}`;
                    countBy.set(k, (countBy.get(k)||0)+1);
                    totalBy.set(k, (totalBy.get(k)||0)+life);
                    const sm = samplesBy.get(k) || [];
                    sm.push({ t:start, life, aid:aid||0, teamId:teamId||0, side });
                    samplesBy.set(k, sm);
                    if (aid>0) placerCount.set(aid, (placerCount.get(aid)||0)+1);
                  }
                  const sp = Array.isArray(p.sen_log) ? p.sen_log : [];
                  for (const se of sp) {
                    const sx = Number(se.x), sy = Number(se.y), st = Number(se.time||0);
                    const k = `${sx},${sy}`;
                    senCountBy.set(k, (senCountBy.get(k)||0)+1);
                    const sb = senBySide.get(k) || { Radiant:{count:0}, Dire:{count:0} };
                    sb[side].count++;
                    senBySide.set(k, sb);
                    if (teamId>0) {
                      const tb = senByTeam.get(k) || {}; const to = tb[teamId] || { count:0 }; to.count++; tb[teamId]=to; senByTeam.set(k,tb);
                    }
                    const sm2 = senSamplesBy.get(k) || []; sm2.push({ t:st, side, teamId, aid }); senSamplesBy.set(k, sm2);
                  }
                }
              }
              const spots = Array.from(countBy.keys()).map(k=>{ const [x,y]=k.split(',').map(Number); const count=countBy.get(k)||0; const total=totalBy.get(k)||0; return { spot:k, x,y, count, total, avgSeconds: count? Math.round(total/count):0, bySide:{Radiant:{count:0,total:0}, Dire:{count:0,total:0}}, byTeam:{}, samples: samplesBy.get(k)||[] }; });
              const sentries = Array.from(senCountBy.keys()).map(k=>{ const [x,y]=k.split(',').map(Number); return { spot:k, x,y, count: senCountBy.get(k)||0, bySide: senBySide.get(k)||{Radiant:{count:0},Dire:{count:0}}, byTeam: senByTeam.get(k)||{}, samples: senSamplesBy.get(k)||[] }; });
              const teamsList = Array.from(teamNameByIdLocal.entries()).map(([id,name])=>({ id:Number(id), name:String(name||`Team ${id}`) })).sort((a,b)=> String(a.name||'').localeCompare(String(b.name||'')));
              const playersList = Array.from(playersSet.entries()).map(([id,name])=>({ id:Number(id), name:String(name||`Player ${id}`), count: placerCount.get(id)||0 })).filter(p=>p.count>0).sort((a,b)=> String(a.name||'').localeCompare(String(b.name||'')));
              window.WardViewer.mount(stdHost, { mapConf, data: { spots, sentries, teams: teamsList, players: playersList }, options: { modeDefault: 'best', showExtras: false, showLongest: false, ignorePersistedPlayer: true, ignorePersistedCluster: true, extras: { wardPlayers: {}, wardLongest: [] } } });
            }
          } catch(err){ console.warn('WardViewer mount failed', err); }

          // Subtab switcher (spots / players / trend)
          try{
            if(!window.__lvWardSubTabsBooted){
              const bar = document.getElementById('wardSubTabs');
              if(bar){
                const buttons = Array.from(bar.querySelectorAll('.tab'));
                function show(name){
                  const a = (name==='players' || name==='trend') ? name : 'spots';
                  const spotsPane = document.getElementById('wtab-spots');
                  const playersPane = document.getElementById('wtab-players');
                  const trendPane = document.getElementById('wtab-trend');
                  if(spotsPane && playersPane){ const onPlayers=(a==='players'), onTrend=(a==='trend'); spotsPane.style.display=(onPlayers||onTrend)?'none':''; playersPane.style.display=onPlayers?'':'none'; if(trendPane) trendPane.style.display=onTrend?'':'none'; }
                  buttons.forEach(b=>{ const active = b.getAttribute('data-wtab')===a; b.classList.toggle('active',active); b.setAttribute('aria-selected', active?'true':'false'); });
                }
                buttons.forEach(b=> b.addEventListener('click', ()=> show(b.getAttribute('data-wtab'))));
                window.__lvWardSubTabsBooted = true;
              }
            }
          }catch(_e){}

          // Players subtab with extra filters and Dist legend
          try{
            const mountPl = document.getElementById('dvWardPlayers');
            if(mountPl){
              const teamsList = (function(){ const m=new Map(); try{ for(const md of details||[]){ const rid=Number(md.radiant_team_id||0), did=Number(md.dire_team_id||0); const r=(md.radiant_team&&md.radiant_team.name)||md.radiant_name||teamNames[String(rid)]||'Radiant'; const d=(md.dire_team&&md.dire_team.name)||md.dire_name||teamNames[String(did)]||'Dire'; if(rid) m.set(rid, r); if(did) m.set(did, d);} }catch(_e){} return Array.from(m.entries()).map(([id,name])=>({id:Number(id),name:String(name)})).sort((a,b)=> String(a.name||'').localeCompare(String(b.name||''))); })();
              function distLegend(){ return `<div class='sub' style='display:flex;gap:10px;align-items:center;margin:4px 0 8px'>
                <span>Dist:</span>
                <span style='display:inline-flex;gap:6px;align-items:center'><span style='width:16px;height:8px;background:#94a3b8;border:1px solid rgba(255,255,255,.12)'></span><span class='sub'>&le;5s</span></span>
                <span style='display:inline-flex;gap:6px;align-items:center'><span style='width:16px;height:8px;background:#60a5fa;border:1px solid rgba(255,255,255,.12)'></span><span class='sub'>&le;30s</span></span>
                <span style='display:inline-flex;gap:6px;align-items:center'><span style='width:16px;height:8px;background:#fbbf24;border:1px solid rgba(255,255,255,.12)'></span><span class='sub'>&le;150s</span></span>
                <span style='display:inline-flex;gap:6px;align-items:center'><span style='width:16px;height:8px;background:#22c55e;border:1px solid rgba(255,255,255,.12)'></span><span class='sub'>&gt;150s</span></span>
              </div>`; }
              let sideSel=''; let teamSel=''; let minSamples=0; let onlyDew=false;
              const teamOptions = ['<option value="">All</option>'].concat(teamsList.map(t=>`<option value="team:${t.id}">${t.name||('Team '+t.id)}</option>`)).join('');
              function controlsHtml(){ return `<div class='controls' style='margin-bottom:8px;display:flex;flex-wrap:wrap;gap:16px'>
                <div class='field'><label class='sub'>Side</label><div class='tabs' id='wpSideLv'><button class='tab ${sideSel===''?'active':''}' data-side=''>All</button><button class='tab ${sideSel==='Radiant'?'active':''}' data-side='Radiant'>Radiant</button><button class='tab ${sideSel==='Dire'?'active':''}' data-side='Dire'>Dire</button></div></div>
                <div class='field'><label class='sub'>Team</label><select id='wpTeamLv'>${teamOptions}</select><div class='sub'>Team overrides Side</div></div>
                <div class='field'><label class='sub'>Min samples</label><input id='wpMinSamplesLv' type='number' min='0' step='1' value='${minSamples}' style='width:90px' /></div>
                <div class='field'><label class='sub'>Filter</label><label style='display:inline-flex;gap:6px;align-items:center'><input id='wpOnlyDewLv' type='checkbox' ${onlyDew?'checked':''}/> <span class='sub'>Only dewarders</span></label></div>
              </div>`; }
              function teamIdFromSel(){ if(!teamSel) return 0; if(teamSel.startsWith('team:')) return Number(teamSel.split(':')[1]||0); const n=Number(teamSel)||0; return n>0?n:0; }
              function distSpark(d){ const total=Math.max(1,(d.le5||0)+(d.le30||0)+(d.le150||0)+(d.gt150||0)); const w=80,h=8; const p1=Math.round(100*(d.le5||0)/total), p2=Math.round(100*(d.le30||0)/total), p3=Math.round(100*(d.le150||0)/total), p4=100-p1-p2-p3; const seg=(pct,color)=>`<div style='height:${h}px;width:${pct}%;background:${color}'></div>`; const tip=`<=5s:${d.le5||0} | <=30s:${d.le30||0} | <=150s:${d.le150||0} | >150s:${d.gt150||0}`; return `<div title='${tip}' aria-label='${tip}' style='display:flex;border:1px solid rgba(255,255,255,.12);border-radius:6px;overflow:hidden;width:${w}px'>${seg(p1,'#94a3b8')}${seg(p2,'#60a5fa')}${seg(p3,'#fbbf24')}${seg(p4,'#22c55e')}</div>`; }
              function computePlayers({side='', teamId=0}){
                const idx=new Map(); const rec=(aid)=>{ aid=Number(aid)||0; if(!aid) return null; if(!idx.has(aid)) idx.set(aid,{ account_id:aid, name: playerNames[String(aid)]||`Player ${aid}`, profile: OD_PLAYER_URL(aid), obsP:0, senP:0, deobs:0, desen:0, life:[], gems:0 }); return idx.get(aid); };
                for(const md of details||[]){ const pls=Array.isArray(md.players)? md.players:[]; const rId=Number(md.radiant_team_id||0), dId=Number(md.dire_team_id||0); const heroToAccount=new Map(); for(const p of pls){ const id=Number(p.account_id||0); if(!(id>0)) continue; const hid=Number(p.hero_id||0); if(hid>0) heroToAccount.set(hid,id); }
                  const leftAll=[]; for(const p of pls){ const aid=Number(p.account_id||0); if(!(aid>0)) continue; const isRad = (p.isRadiant===true || p.is_radiant===true || Number(p.player_slot)<128); const sideStr=isRad?'Radiant':'Dire'; const tid=isRad?rId:dId; if(teamId>0){ if(tid!==teamId) continue; } else if(side && (side==='Radiant'||side==='Dire')){ if(sideStr!==side) continue; }
                    const r=rec(aid); if(!r) continue; const obsLog=Array.isArray(p.obs_log)?p.obs_log:[]; r.obsP+=obsLog.length; const senLog=Array.isArray(p.sen_log)?p.sen_log:[]; r.senP+=senLog.length;
                    const ok=Number(p.obs_kills||p.obs_killed||p.observer_kills||0); if(ok>0) r.deobs+=ok; const sk=Number(p.sen_kills||p.sentry_kills||p.sen_killed||p.sentry_wards_destroyed||0); if(sk>0) r.desen+=sk;
                    const leftLog=Array.isArray(p.obs_left_log)? p.obs_left_log:[]; const P=obsLog.map(o=>Number(o.time||0)).sort((a,b)=>a-b); const L=leftLog.map(o=>Number(o.time||0)).sort((a,b)=>a-b); for(const ev of leftLog){ if(ev&&ev.attackername) leftAll.push(ev); }
                    let j=0; for(let i=0;i<P.length;i++){ const tP=P[i]; while(j<L.length && L[j]<tP) j++; let life=360; if(j<L.length){ life=Math.max(0, L[j]-tP); j++; } else { life=Math.max(0, Math.min(360, Number(md.duration||0) - tP)); } r.life.push(Math.min(360, life)); }
                    const plog=Array.isArray(p.purchase_log)? p.purchase_log:[]; for(const ev of plog){ const key=String(ev.key||ev.item||'').toLowerCase(); if(key==='gem' || key==='gem_of_true_sight') r.gems++; }
                  }
                  try{ const tag2id={}; for(const id in heroes){ const v=heroes[id]; if(v && v.tag) tag2id[v.tag]=Number(id); } for(const ev of leftAll){ const an=String(ev.attackername||''); if(an.startsWith('npc_dota_hero_')){ const hid = tag2id[an.replace(/^npc_dota_hero_/,'')]; const killer = heroToAccount.get(hid); if(killer){ const r=rec(killer); if(r) r.deobs+=1; } } } } catch(_e){}
                return Array.from(idx.values()).map(o=>{ const n=o.life.length; const avg=n? Math.round(o.life.reduce((a,b)=>a+b,0)/n):0; const med=(function(a){ if(!a.length) return 0; const s=a.slice().sort((x,y)=>x-y); const m=s.length>>1; return (s.length%2)? s[m] : Math.floor((s[m-1]+s[m])/2); })(o.life); const dist=(function(a){ const d={le5:0,le30:0,le150:0,gt150:0}; for(const v of a){ if(v<=5) d.le5++; else if(v<=30) d.le30++; else if(v<=150) d.le150++; else d.gt150++; } return d; })(o.life); return { account_id:o.account_id, name:o.name, profile:o.profile, placed:o.obsP, senPlaced:o.senP, dewards:o.deobs, senDewards:o.desen, avgSeconds:avg, medianSeconds:med, samples:n, gems:o.gems, dist }; });
              }
              function renderPlayers(){
                const tid = teamIdFromSel();
                let rowsData = computePlayers({ side: sideSel, teamId: tid });
                if(minSamples>0) rowsData = rowsData.filter(r=> (r.samples||0) >= minSamples);
                if(onlyDew) rowsData = rowsData.filter(r=> (r.dewards||0)+(r.senDewards||0) > 0);
                rowsData.sort((a,b)=> (b.placed-a.placed)||(b.dewards-a.dewards)||(b.avgSeconds-a.avgSeconds)||String(a.name).localeCompare(String(b.name)));
                const rows = rowsData.map(p=>{ const nm=p.name||`Player ${p.account_id}`; const prof=p.profile||(p.account_id?OD_PLAYER_URL(p.account_id):'#'); const avg=Number(p.avgSeconds||0), med=Number(p.medianSeconds||0); return `<tr><td data-sort='${String(nm).toLowerCase()}'><a href='${prof}' target='_blank' rel='noopener'>${nm}</a></td><td data-sort='${p.placed||0}'>${p.placed||0}</td><td data-sort='${p.senPlaced||0}'>${p.senPlaced||0}</td><td data-sort='${p.dewards||0}'>${p.dewards||0}</td><td data-sort='${p.senDewards||0}'>${p.senDewards||0}</td><td data-sort='${avg}'>${(function(a,m){ const cap=360; const pa=Math.min(100, Math.max(0, Math.round(100*a/cap))); const pm=Math.min(100, Math.max(0, Math.round(100*m/cap))); return `<div style='height:6px;background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.12);border-radius:6px;position:relative'><div style='position:absolute;left:0;top:0;bottom:0;width:${pa}%;background:linear-gradient(90deg, rgba(110,180,255,.9), rgba(110,175,255,.55));box-shadow:0 0 6px rgba(110,180,255,.35) inset;border-radius:6px'></div><div style='position:absolute;left:${pm}%;top:-2px;bottom:-2px;width:2px;background:#fbbf24;opacity:.95'></div></div>`; })(avg,med)}<div class='sub'>avg ${Math.floor(avg/60)}m ${avg%60}s ¬∑ med ${Math.floor(med/60)}m ${med%60}s</div></td><td>${distSpark(p.dist||{})}</td><td data-sort='${p.samples||0}'>${p.samples||0}</td><td data-sort='${p.gems||0}'>${p.gems||0}</td></tr>`; }).join('');
                mountPl.innerHTML = controlsHtml() + distLegend() + `<table class='table sortable' id='wardPlayersTableLv'><thead><tr><th data-type='text'>Player</th><th data-type='num' title='Observer wards placed'>Obs placed</th><th data-type='num' title='Sentry wards placed'>Sen placed</th><th data-type='num' title='Observer wards dewarded'>Dewards (obs)</th><th data-type='num' title='Sentry wards dewarded'>Dewards (sen)</th><th data-type='num' title='Avg/Median lifetime of their observers'>Lifetime</th><th data-type='num' title='Lifetime distribution (‚â§5s, ‚â§30s, ‚â§150s, >150s)'>Dist</th><th data-type='num' title='Samples used for lifetime stats'>Samples</th><th data-type='num' title='Gems bought'>Gems</th></tr></thead><tbody>${rows}</tbody></table>`;
                try{ enableSorting(); }catch(_e){}
                try{
                  const sideWrap=document.getElementById('wpSideLv'); if(sideWrap){ sideWrap.querySelectorAll('.tab').forEach(b=> b.addEventListener('click', ()=>{ sideWrap.querySelectorAll('.tab').forEach(x=>x.classList.remove('active')); b.classList.add('active'); sideSel=String(b.getAttribute('data-side')||''); renderPlayers(); })); }
                  const sel=document.getElementById('wpTeamLv'); if(sel){ sel.value=teamSel||''; sel.addEventListener('change', ()=>{ teamSel=String(sel.value||''); renderPlayers(); }); }
                  const ms=document.getElementById('wpMinSamplesLv'); if(ms){ ms.addEventListener('input', ()=>{ const v=Number(ms.value)||0; minSamples = v<0?0:v; renderPlayers(); }); }
                  const od=document.getElementById('wpOnlyDewLv'); if(od){ od.addEventListener('change', ()=>{ onlyDew = !!od.checked; renderPlayers(); }); }
                }catch(_e){}
              }
              renderPlayers();
            }
          }catch(_e){}

          // Trend subtab with Player mode
          try{
            const mountTr = document.getElementById('dvWardTrend');
            if(mountTr){
              const teamsList = (function(){ const m=new Map(); try{ for(const md of details||[]){ const rid=Number(md.radiant_team_id||0), did=Number(md.dire_team_id||0); const r=(md.radiant_team&&md.radiant_team.name)||md.radiant_name||teamNames[String(rid)]||'Radiant'; const d=(md.dire_team&&md.dire_team.name)||md.dire_name||teamNames[String(did)]||'Dire'; if(rid) m.set(rid, r); if(did) m.set(did, d);} }catch(_e){} return Array.from(m.entries()).map(([id,name])=>({id:Number(id),name:String(name)})).sort((a,b)=> String(a.name||'').localeCompare(String(b.name||''))); })();
              // Trend state (league view)
              let wtSideSelLv = '';
              let wtTeamSelLv = '';
              let wtPlayerSelLv = 0;
              function buildPlayersList(){ const m=new Map(); try{ for(const md of details||[]){ for(const p of (md.players||[])){ const aid=Number(p.account_id||0); if(!(aid>0)) continue; if(!m.has(aid)){ const nm=(playerNames&&playerNames[String(aid)])||String(p.personaname||'')||`Player ${aid}`; m.set(aid,nm); } } } }catch(_e){} return Array.from(m.entries()).map(([id,name])=>({id:Number(id), name:String(name)})).sort((a,b)=> String(a.name||'').localeCompare(String(b.name||''))); }
              function controlsHtml(){ const players=buildPlayersList(); const teamOptions=[`<option value="" ${wtTeamSelLv===''?'selected':''}>All</option>`].concat(teamsList.map(t=>`<option value="team:${t.id}" ${wtTeamSelLv===`team:${t.id}`?'selected':''}>${t.name||('Team '+t.id)}</option>`)).join(''); const playerOptions=[`<option value="" ${wtPlayerSelLv? '':'selected'}>All players</option>`].concat(players.map(p=>`<option value="${p.id}" ${wtPlayerSelLv===p.id?'selected':''}>${p.name||('Player '+p.id)}</option>`)).join(''); const sideBtn=(val,label)=>`<button class='tab ${wtSideSelLv===val?'active':''}' data-side='${val}'>${label}</button>`; const sideDisabled = wtTeamSelLv && String(wtTeamSelLv).length>0; const sideStyle = sideDisabled? 'opacity:.55;pointer-events:none' : ''; const filterSummary=(function(){ const sideTxt=wtTeamSelLv? '' : (wtSideSelLv||'All'); const teamTxt=(function(){ if(!wtTeamSelLv) return ''; const id=Number((wtTeamSelLv.split(':')[1]||'0')); const t=teamsList.find(x=>x.id===id); return t? (t.name||('Team '+id)) : ('Team '+id); })(); const playerTxt=(function(){ if(!(wtPlayerSelLv>0)) return ''; const p=players.find(x=>x.id===wtPlayerSelLv); return p? (p.name||('Player '+wtPlayerSelLv)) : ('Player '+wtPlayerSelLv); })(); const parts=[]; if(teamTxt) parts.push(`Team: ${teamTxt}`); else if(sideTxt) parts.push(`Side: ${sideTxt}`); if(playerTxt) parts.push(`Player: ${playerTxt}`); return parts.length? `<div class='sub' style='margin:4px 0 0'>Showing ${parts.join(' ¬∑ ')}</div>`:''; })(); return `<div class='controls' style='margin-bottom:8px;display:flex;flex-wrap:wrap;gap:16px;align-items:flex-end'><div class='field' style='min-width:180px'><label class='sub'>Side</label><div class='tabs' id='wtSideLv' style='gap:8px; ${sideStyle}' title='${sideDisabled? 'Disabled because Team is selected' : ''}'>${sideBtn('','All')}${sideBtn('Radiant','Radiant')}${sideBtn('Dire','Dire')}</div></div><div class='field' style='min-width:280px'><label class='sub'>Team</label><select id='wtTeamLv' style='min-width:260px'>${teamOptions}</select><div class='sub' style='opacity:.8'>Team overrides Side</div></div><div class='field' style='min-width:280px'><label class='sub'>Player</label><select id='wtPlayerLv' style='min-width:260px'>${playerOptions}</select></div><div style='margin-left:auto'><button id='wtResetLv' style='padding:6px 10px;border:1px solid rgba(255,255,255,.15);border-radius:6px;background:rgba(255,255,255,.06);color:#fff'>Reset</button></div></div>${filterSummary}`; }
              function bucketize(details,{side='',teamId=0,playerId=0}){ const from=(typeof window!=='undefined' && window.__dvRangeUnix && window.__dvRangeUnix.from)||0; const to=(typeof window!=='undefined' && window.__dvRangeUnix && window.__dvRangeUnix.to)||0; const span=Math.max(1,to-from); const days=Math.max(1,Math.ceil(span/86400)); const maxBuckets=60; const stepDays=Math.max(1,Math.ceil(days/maxBuckets)); const step=stepDays*86400; const first=from>0?from:((details&&details.length&&Number(details[0].start_time||0))||0); const last=to>0?to:((details&&details.length&&Number(details[details.length-1].start_time||0))|| (first+step)); const count=Math.max(1,Math.ceil((last-first)/step)); const buckets=new Array(count).fill(0).map((_,i)=>({s:first+i*step,e:first+(i+1)*step, lifeObs:[], lifeSen:[], samplesObs:0,samplesSen:0})); for(const md of details||[]){ const startT=Number(md.start_time||0), dur=Number(md.duration||0); let idx=(startT>0&&step>0)? Math.floor((startT-first)/step):0; if(idx<0) idx=0; if(idx>=buckets.length) idx=buckets.length-1; const rid=Number(md.radiant_team_id||0), did=Number(md.dire_team_id||0); for(const p of (md.players||[])){ const aid=Number(p.account_id||0); if(!(aid>0)) continue; if(playerId>0 && aid!==playerId) continue; const isRad=(p.isRadiant===true||p.is_radiant===true||Number(p.player_slot)<128); const sideStr=isRad?'Radiant':'Dire'; const tid=isRad?rid:did; if(teamId>0){ if(tid!==teamId) continue; } else if(side && (side==='Radiant'||side==='Dire')){ if(sideStr!==side) continue; } const obsLog=Array.isArray(p.obs_log)?p.obs_log:[]; const leftLog=Array.isArray(p.obs_left_log)?p.obs_left_log:[]; const P=obsLog.map(o=>Number(o.time||0)).sort((a,b)=>a-b); const L=leftLog.map(o=>Number(o.time||0)).sort((a,b)=>a-b); let j=0; for(let i=0;i<P.length;i++){ const tP=P[i]; while(j<L.length && L[j]<tP) j++; let life=360; if(j<L.length){ life=Math.max(0,L[j]-tP); j++; } else { life=Math.max(0, Math.min(360, dur-tP)); } buckets[idx].lifeObs.push(Math.min(360, life)); buckets[idx].samplesObs++; } const senLog=Array.isArray(p.sen_log)?p.sen_log:[]; const senLeft=Array.isArray(p.sen_left_log)?p.sen_left_log:[]; const PS=senLog.map(o=>Number(o.time||0)).sort((a,b)=>a-b); const LS=senLeft.map(o=>Number(o.time||0)).sort((a,b)=>a-b); let js=0; for(let i=0;i<PS.length;i++){ const tP=PS[i]; while(js<LS.length && LS[js]<tP) js++; let life=360; if(js<LS.length){ life=Math.max(0,LS[js]-tP); js++; } else { life=Math.max(0, Math.min(360, dur-tP)); } buckets[idx].lifeSen.push(Math.min(360,life)); buckets[idx].samplesSen++; } } } const medOf=(arr)=>{ if(!arr.length) return 0; const s=arr.slice().sort((x,y)=>x-y); const m=s.length>>1; return (s.length%2)? s[m] : Math.floor((s[m-1]+s[m])/2); }; const avgOf=(arr)=> arr.length? Math.round(arr.reduce((a,c)=>a+c,0)/arr.length):0; const arr=buckets.map(b=>({ s:b.s,e:b.e, avg:avgOf(b.lifeObs), med:medOf(b.lifeObs), samples:b.samplesObs, avgS:avgOf(b.lifeSen), medS:medOf(b.lifeSen), samplesS:b.samplesSen })); let lastAvg=0,lastMed=0,lastAvgS=0,lastMedS=0; for(const b of arr){ if(b.samples>0){ lastAvg=b.avg; lastMed=b.med; } else { b.avg=lastAvg; b.med=lastMed; } if(b.samplesS>0){ lastAvgS=b.avgS; lastMedS=b.medS; } else { b.avgS=lastAvgS; b.medS=lastMedS; } } return arr; }
              function miniLegend(){ return `<div class='sub' style='display:flex;align-items:center;gap:12px;margin:6px 0 4px'><span style='display:inline-flex;align-items:center;gap:6px'><span style='width:18px;height:2px;background:#6db0ff;display:inline-block'></span>Obs Avg</span><span style='display-inline-flex;align-items:center;gap:6px'><span style='width:18px;height:2px;background:#fbbf24;display:inline-block'></span>Obs Median</span><span style='display-inline-flex;align-items:center;gap:6px'><span style='width:18px;height:2px;background:#a78bfa;display:inline-block'></span>Sen Avg</span><span style='display-inline-flex;align-items:center;gap:6px'><span style='width:18px;height:2px;background:#ddd6fe;display:inline-block'></span>Sen Median</span></div>`; }
              function renderTrend(){
                const side = wtSideSelLv || '';
                const teamId = (function(){ const v=String(wtTeamSelLv||''); if(v.startsWith('team:')) return Number(v.split(':')[1]||0); const n=Number(v)||0; return n>0?n:0; })();
                const playerId = wtPlayerSelLv>0? wtPlayerSelLv : 0;
                const series = bucketize(details, { side, teamId, playerId });
                const W=780, H=160, P=22;
                const n=Math.max(1, series.length);
                const xmax=n-1, ymax=360;
                const sx=(i)=> P + (i/xmax)*(W-2*P);
                const sy=(val)=> H - P - (val/ymax)*(H-2*P);
                const line=(vals)=> vals.map((p,i)=> `${sx(i)},${sy(p)}`).join(' ');
                const avgPts=line(series.map(s=>s.avg));
                const medPts=line(series.map(s=>s.med));
                const avgPtsS=line(series.map(s=>s.avgS));
                const medPtsS=line(series.map(s=>s.medS));
                const fmtD=(u)=>{ if(!u) return ''; const d=new Date(u*1000); return d.toISOString().slice(5,10); };
                const xStart=series[0]? fmtD(series[0].s):'';
                const xEnd=series[n-1]? fmtD(series[n-1].e):'';
                const tFirst=series[0]? series[0].s:0;
                const tLast=series[n-1]? series[n-1].e:0;
                const patchLines=(patches||[]).filter(p=> p.ts>=tFirst && p.ts<=tLast).map(p=>({ x: P + ((p.ts-tFirst)/(tLast-tFirst))*(W-2*P), label:p.name }));
                const rows = series.map(s=>`<tr><td data-sort='${s.s}'>${fmtD(s.s)}</td><td data-sort='${s.avg}'>${fmtMMSS(s.avg)}</td><td data-sort='${s.med}'>${fmtMMSS(s.med)}</td><td data-sort='${s.samples}'>${s.samples}</td><td data-sort='${s.avgS}'>${fmtMMSS(s.avgS)}</td><td data-sort='${s.medS}'>${fmtMMSS(s.medS)}</td><td data-sort='${s.samplesS}'>${s.samplesS}</td></tr>`).join('');
                mountTr.innerHTML = controlsHtml() + miniLegend() + `
                  <div id='wtGraphWrapLv' style='position:relative; overflow:auto'>
                    <svg id='wtSvgLv' viewBox='0 0 ${W} ${H}' width='100%' height='${H}' role='img'>
                      <rect x='0' y='0' width='${W}' height='${H}' fill='transparent' />
                      <line x1='${P}' y1='${sy(0)}' x2='${W-P}' y2='${sy(0)}' stroke='rgba(255,255,255,.2)' stroke-width='1' />
                      <polyline fill='none' stroke='#6db0ff' stroke-width='2' points='${avgPts}' />
                      <polyline fill='none' stroke='#fbbf24' stroke-width='2' points='${medPts}' />
                      <polyline fill='none' stroke='#a78bfa' stroke-width='2' points='${avgPtsS}' />
                      <polyline fill='none' stroke='#ddd6fe' stroke-width='2' points='${medPtsS}' />
                      <g id='wtHoverLayerLv' pointer-events='none'>
                        <line id='wtHoverLineLv' x1='${P}' x2='${P}' y1='${P}' y2='${H-P}' stroke='rgba(255,255,255,.5)' stroke-width='1' stroke-dasharray='3 3' style='display:none' />
                      </g>
                      ${patchLines.map(pl=>`<line x1='${pl.x}' y1='${P}' x2='${pl.x}' y2='${H-P}' stroke='rgba(158,199,255,.35)' stroke-width='1' />`).join('')}
                      ${patchLines.map(pl=>`<text x='${pl.x+2}' y='${P+10}' fill='rgba(158,199,255,.85)' font-size='10'>${pl.label}</text>`).join('')}
                      <text x='${P}' y='${H-4}' fill='rgba(255,255,255,.6)' font-size='10'>${xStart}</text>
                      <text x='${W-P-28}' y='${H-4}' fill='rgba(255,255,255,.6)' font-size='10' text-anchor='end'>${xEnd}</text>
                      <text x='${P-6}' y='${sy(360)}' fill='rgba(255,255,255,.6)' font-size='10' text-anchor='end'>360s</text>
                      <text x='${P-6}' y='${sy(180)}' fill='rgba(255,255,255,.6)' font-size='10' text-anchor='end'>180s</text>
                      <text x='${P-6}' y='${sy(0)}' fill='rgba(255,255,255,.6)' font-size='10' text-anchor='end'>0</text>
                    </svg>
                    <div id='wtTipLv' style='position:absolute; top:6px; left:0; transform:translateX(-50%); background:rgba(10,12,16,.92); border:1px solid rgba(255,255,255,.15); padding:6px 8px; border-radius:6px; font-size:12px; line-height:1.3; display:none; pointer-events:none; white-space:nowrap'></div>
                  </div>
                  <table class='table sortable' id='wardTrendTableLv' style='margin-top:6px'>
                    <thead><tr><th data-type='num'>Bucket</th><th data-type='num'>Obs Avg</th><th data-type='num'>Obs Median</th><th data-type='num'>Obs Samples</th><th data-type='num'>Sen Avg</th><th data-type='num'>Sen Median</th><th data-type='num'>Sen Samples</th></tr></thead>
                    <tbody>${rows}</tbody>
                  </table>`;
                try { enableSorting(); } catch(_e) {}
                try{
                  const pSel2=document.getElementById('wtPlayerLv');
                  const sideWrap2=document.getElementById('wtSideLv'); sideWrap2.querySelectorAll('.tab').forEach(btn=> btn.addEventListener('click', ()=>{ wtSideSelLv=String(btn.getAttribute('data-side')||''); renderTrend(); }));
                  const sel2=document.getElementById('wtTeamLv'); sel2.addEventListener('change', ()=>{ wtTeamSelLv=String(sel2.value||''); renderTrend(); });
                  if(pSel2) pSel2.addEventListener('change', ()=>{ wtPlayerSelLv = Number(pSel2.value)||0; renderTrend(); });
                  const resetBtnLv = document.getElementById('wtResetLv'); if(resetBtnLv){ resetBtnLv.addEventListener('click', ()=>{ wtSideSelLv=''; wtTeamSelLv=''; wtPlayerSelLv=0; renderTrend(); }); }
                  // hover interactions
                  const svg = document.getElementById('wtSvgLv');
                  const tip = document.getElementById('wtTipLv');
                  const hoverLine = document.getElementById('wtHoverLineLv');
                  function showAtIndex(i){ i=Math.max(0,Math.min(n-1,i)); const s=series[i]; const x=sx(i); if(hoverLine){ hoverLine.setAttribute('x1', String(x)); hoverLine.setAttribute('x2', String(x)); hoverLine.style.display=''; }
                    if(tip && svg){ const rect=svg.getBoundingClientRect(); const rx=(x/W)*rect.width; const left=Math.max(8, Math.min(rect.width-8, rx)); tip.style.left=`${left}px`; tip.style.display=''; const teamTxt=(function(){ if(!wtTeamSelLv) return ''; const id=Number((wtTeamSelLv.split(':')[1]||'0')); const t=teamsList.find(x=>x.id===id); return t? (t.name||('Team '+id)) : ('Team '+id); })(); const players=buildPlayersList(); const playerTxt=(function(){ if(!(wtPlayerSelLv>0)) return ''; const p=players.find(x=>x.id===wtPlayerSelLv); return p? (p.name||('Player '+wtPlayerSelLv)) : ('Player '+wtPlayerSelLv); })(); const scope = playerTxt ? ` ¬∑ Player: ${playerTxt}` : (teamTxt ? ` ¬∑ Team: ${teamTxt}` : (wtSideSelLv? ` ¬∑ Side: ${wtSideSelLv}` : '')); tip.innerHTML = `${fmtD(s.s)} ¬∑ Obs ${fmtMMSS(s.avg)}s/${fmtMMSS(s.med)}s (${s.samples}) ¬∑ Sen ${fmtMMSS(s.avgS)}s/${fmtMMSS(s.medS)}s (${s.samplesS})${scope}`; }
                  }
                  function svgPoint(evt){ const pt=svg.createSVGPoint(); pt.x=evt.clientX; pt.y=evt.clientY; return pt.matrixTransform(svg.getScreenCTM().inverse()); }
                  function onMove(e){ if(!svg) return; const cur=svgPoint(e); const x=Math.max(P, Math.min(W-P, cur.x)); const i=Math.round(((x - P)/(W - 2*P))*(n-1)); showAtIndex(i); }
                  function onLeave(){ if(hoverLine) hoverLine.style.display='none'; if(tip) tip.style.display='none'; }
                  if(svg){ svg.addEventListener('mousemove', onMove); svg.addEventListener('mouseleave', onLeave); }
                }catch(_e){}
              }
              renderTrend();
            }
          }
        });
      };

      // Placement tab mounting from report.json
      window.__ensurePlacement = () => {
        if (mountedPlacement) return; mountedPlacement = true;
        try {
          const tbl = document.getElementById('placementTable'); if (!tbl) return;
          const tbody = tbl.tBodies && tbl.tBodies[0]; if (!tbody) return;
          const arr = (report && (report.placements || (report.highlights && report.highlights.placements))) || [];
          if (Array.isArray(arr) && arr.length) {
            const rows = arr.map(p => {
              const wr = p.games ? (p.wins / p.games) : 0;
              return `<tr>
                <td data-sort='${p.place||0}'>${p.place||''}</td>
                <td data-sort='${(p.name||'').toLowerCase()}'>${p.name||''}</td>
                <td data-sort='${p.games||0}'>${p.games||0}</td>
                <td data-sort='${(p.wins||0)/(p.games||1)}'><span class='win'>${p.wins||0}</span>-<span class='loss'>${(p.losses||0)}</span></td>
                <td data-sort='${wr}'>${fmtPct(wr)}</td>
              </tr>`;
            }).join('');
            tbody.innerHTML = rows;
            sortTable(tbl, 0, 'num', true);
          } else {
            tbody.innerHTML = "<tr><td colspan='5' class='sub'>no placement data</td></tr>";
          }
        } catch(e){ console.warn('Placement render failed', e); }
      };

      // CSV export wiring
      function tableToCSV(tableId) {
        const table = document.getElementById(tableId); if (!table) return '';
        const rows = [];
        const esc = (v) => {
          const s = String(v).replace(/\u00A0/g,' ').trim();
          if (/[",\n]/.test(s)) return '"' + s.replace(/"/g,'""') + '"';
          return s;
        };
        const hdr = Array.from(table.tHead ? table.tHead.rows[0].cells : []).map(th => th.textContent.trim());
        if (hdr.length) rows.push(hdr.map(esc).join(','));
        Array.from(table.tBodies[0].rows).forEach(tr => {
          const cols = Array.from(tr.cells).map(td => td.textContent.replace(/\s+/g,' ').trim());
          rows.push(cols.map(esc).join(','));
        });
        return rows.join('\n');
      }
      function downloadCSV(filename, csv) {
        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href = url; a.download = filename; document.body.appendChild(a); a.click();
        setTimeout(() => { document.body.removeChild(a); URL.revokeObjectURL(url); }, 0);
      }
      try {
        const suffix = `_${slug}`;
        const ep = document.getElementById('exportPlayersCsv'); if (ep) ep.addEventListener('click', () => { const csv = tableToCSV('playersTable'); if (csv) downloadCSV(`players${suffix}.csv`, csv); });
        const eh = document.getElementById('exportHeroesCsv'); if (eh) eh.addEventListener('click', () => { const csv = tableToCSV('heroesTable'); if (csv) downloadCSV(`heroes${suffix}.csv`, csv); });
  const et = document.getElementById('exportTeamsCsv'); if (et) et.addEventListener('click', () => { const csv = tableToCSV('teamsTable'); if (csv) downloadCSV(`teams${suffix}.csv`, csv); });
  const epc = document.getElementById('exportPlacementCsv'); if (epc) epc.addEventListener('click', () => { const csv = tableToCSV('placementTable'); if (csv) downloadCSV(`placement${suffix}.csv`, csv); });
        const edv = document.getElementById('exportDraftCsv'); if (edv) edv.addEventListener('click', () => {
          const mount = document.getElementById('draftMount'); const csv = mount && mount.__getDraftCSV ? mount.__getDraftCSV() : '';
          if (csv) downloadCSV(`draft${suffix}.csv`, csv);
        });
        const eld = document.getElementById('exportLaneDuosCsv'); if (eld) eld.addEventListener('click', () => {
          const mount = document.getElementById('ldMount'); const csv = mount && mount.__getLaneDuosCSV ? mount.__getLaneDuosCSV() : '';
          if (csv) downloadCSV(`lane_duos${suffix}.csv`, csv);
        });
      } catch (_e) {}

      const times = matches.map(m => m.start_time).filter(Boolean); const max = Math.max(...times);
      

      // Initial tab selection: prefer URL ?tab=, then persisted last tab
      try {
        const urlTab = ((window.UrlParams && UrlParams.getCanonical) ? UrlParams.getCanonical() : new URLSearchParams(location.search)).get('tab');
        const last = localStorage.getItem('lv_tab');
        const initial = urlTab || last;
        if (initial && window.__lvShowTab) { window.__lvShowTab(initial); }
      } catch (_e) {}

      // Wire cache clear button
      try {
        const clearBtn = document.getElementById('btnClearCache');
        if (clearBtn) {
          clearBtn.addEventListener('click', () => {
            const keys = [
              `lv_details_${slug}`,
              `lv_details_meta_${slug}`,
              `lv_draft_${slug}`,
              `lv_laneduos_${slug}`
            ];
            try {
              keys.forEach(k => localStorage.removeItem(k));
              // Optional: keep last tab selection; just reload data
              location.reload();
            } catch (e) {
              console.warn('Cache clear failed', e);
            }
          });
        }
      } catch(_e) {}

      // Share controls: Copy link and Copy embed
      try {
        const status = document.getElementById('shareStatus');
        function announce(msg){ if(status){ status.textContent = msg; setTimeout(()=>{ if(status) status.textContent=''; }, 2000); } }
        function buildPermalink() {
          const url = new URL(location.href);
          // ensure key params are present
          url.searchParams.set('league', slug);
          if (leaguePath) url.searchParams.set('leaguePath', leaguePath);
          // include current tab if available
          try {
            const tabsRoot = document.getElementById('mainTabs');
            const activeBtn = Array.from(tabsRoot.querySelectorAll('.tab')).find(b=> b.classList.contains('active'));
            const tab = activeBtn ? activeBtn.getAttribute('data-tab') : (new URLSearchParams(location.search)).get('tab') || 'highlights';
            url.searchParams.set('tab', tab);
          } catch(_e){}
          return url.toString();
        }
        function copyText(txt){
          if (navigator.clipboard && navigator.clipboard.writeText) { return navigator.clipboard.writeText(txt); }
          // fallback
          return new Promise((res)=>{ const ta=document.createElement('textarea'); ta.value=txt; document.body.appendChild(ta); ta.select(); try{ document.execCommand('copy'); }catch(_e){} document.body.removeChild(ta); res(); });
        }
        const btnLink = document.getElementById('btnCopyLink');
        if (btnLink) btnLink.addEventListener('click', async ()=>{ const link = buildPermalink(); await copyText(link); announce('Link copied to clipboard'); btnLink.textContent='Copied!'; setTimeout(()=>{ btnLink.textContent='Copy link'; }, 1000); });
        const btnEmbed = document.getElementById('btnCopyEmbed');
        if (btnEmbed) btnEmbed.addEventListener('click', async ()=>{
          const link = buildPermalink();
          const html = `<iframe src="${link}" width="100%" height="900" loading="lazy" style="border:0"></iframe>`;
          await copyText(html);
          announce('Embed snippet copied to clipboard');
          btnEmbed.textContent='Copied!'; setTimeout(()=>{ btnEmbed.textContent='Copy embed'; }, 1000);
        });
      } catch(_e){}
    }

  enableSorting();
  main();
  </script>
</body>
</html>
