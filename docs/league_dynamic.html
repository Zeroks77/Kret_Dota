<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>League Dynamic Viewer</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #0b1020;
      --panel: #121832;
      --muted: #9aa3b2;
      --text: #eef1f7;
      --accent: #9ec7ff;
      --chip: #1a2142;
      --border: rgba(255,255,255,.08);
    }
    * { box-sizing: border-box }
    body {
      margin: 0;
      background: radial-gradient(1200px 600px at 10% -10%, #172045, transparent 60%), var(--bg);
      color: var(--text);
      font-family: Inter, system-ui, Segoe UI, Roboto, Arial, sans-serif;
    }
    a { color: var(--accent); text-decoration: none }
    .wrapper { max-width: 1180px; margin: 0 auto; padding: 16px }
    .header { display: flex; align-items: center; gap: 12px; margin-bottom: 12px }
    .badge { background: var(--chip); padding: 4px 10px; border-radius: 999px; font-size: 12px }
    .tabs { display: flex; gap: 6px; margin: 6px 0 8px; flex-wrap: wrap }
    .tab {
      padding: 6px 10px;
      border: 1px solid var(--border);
      background: linear-gradient(180deg, rgba(255,255,255,.07), rgba(255,255,255,.03));
      border-radius: 10px; color: var(--text); cursor: pointer; font-size: 12px
    }
    .tab.active {
      outline: 2px solid rgba(109,166,255,.5);
      background: linear-gradient(180deg, rgba(109,166,255,.2), rgba(109,166,255,.08));
      border-color: rgba(109,166,255,.45)
    }
    .card { background: linear-gradient(180deg,rgba(255,255,255,.04),rgba(255,255,255,.02)); border:1px solid var(--border); border-radius:14px; padding:12px; overflow:visible }
    .tabpane { margin-top: 6px }
    ul.simple { list-style: none; margin: 0; padding: 0 }
    ul.simple li { display: flex; align-items: center; justify-content: space-between; gap: 8px; padding: 6px 0; border-bottom: 1px solid rgba(255,255,255,.06) }
    .sub { color: var(--muted); font-size: 12px }
    .summary-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 12px }
    .summary-card { background: linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.02)); border: 1px solid var(--border); border-radius: 12px; padding: 10px }
    .summary-card h3 { margin: 0 0 6px; font-size: 15px; color: var(--muted) }
    .summary-card ul { list-style: none; margin: 0; padding: 0 }
    .summary-card li { display: flex; align-items: center; gap: 8px; justify-content: space-between; padding: 6px 0; border-bottom: 1px solid rgba(255,255,255,.06) }
    .summary-card li:last-child { border-bottom: 0 }
    .table { width: 100%; border-collapse: collapse }
    .table th, .table td { padding: 8px; border-bottom: 1px solid rgba(255,255,255,.06); font-size: 14px; vertical-align: middle }
    .table th { text-align: left; color: var(--muted); font-weight: 600; user-select: none; cursor: pointer }
    .badge.inline { margin-left: 6px }
    .win { color: #7be495 } .loss { color: #ff8b8b }
    th.sorted-asc, th.sorted-desc { color: var(--accent) }
    th.sorted-asc:after, th.sorted-desc:after { content: ' '; display: inline-block; margin-left: 4px; width: 0; height: 0; border-left: 4px solid transparent; border-right: 4px solid transparent }
    th.sorted-asc:after { border-bottom: 6px solid var(--accent) }
    th.sorted-desc:after { border-top: 6px solid var(--accent) }
    .perf-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(240px, 1fr)); gap: 12px }
    .perf-card { display:flex; align-items:center; justify-content:space-between; padding:10px; border:1px solid var(--border); border-radius:12px; background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.025)) }
    .perf-left { display: flex; align-items: center; gap: 10px }
    .perf-icon { width: 40px; height: 40px; border-radius: 10px; display:flex; align-items:center; justify-content:center; background: radial-gradient(22px 22px at 30% 30%, rgba(158,199,255,.45), rgba(158,199,255,.12)); border: 1px solid rgba(158,199,255,.25); font-size: 18px }
  .spinner { display:inline-block; width:16px; height:16px; border:2px solid rgba(255,255,255,.2); border-top-color: var(--accent); border-radius:50%; animation: spin 0.8s linear infinite; vertical-align: middle }
  @keyframes spin { to { transform: rotate(360deg) } }
    .perf-meta { display: flex; flex-direction: column; line-height: 1.15 }
    .perf-label { font-size: 12px; color: var(--muted); text-transform: uppercase; letter-spacing: .5px }
    .perf-player a { color: var(--text) }
    .perf-value { font-weight: 700; font-size: 18px }
    #calGrid .day { transition: .15s box-shadow, .15s transform }
    #calGrid .day:hover { box-shadow: 0 0 0 1px rgba(255,255,255,.08), 0 4px 12px -4px rgba(0,0,0,.5); transform: translateY(-2px) }
    @media (max-width: 900px) { .perf-grid { grid-template-columns: repeat(auto-fit, minmax(180px,1fr)) } .summary-grid { grid-template-columns: repeat(auto-fit, minmax(180px,1fr)) } }
  </style>
  <script defer src="js/ward_viewer.js"></script>
  <script defer src="js/lane_duos_viewer.js"></script>
  <script defer src="js/items_bought_viewer.js"></script>
  <script defer src="js/draft_viewer.js"></script>
</head>
<body>
  <div class="wrapper">
    <div class="header">
      <h1 id="leagueTitle" style="margin:0;font-size:22px">League – Dynamic viewer</h1>
      <div class="badge">League scope</div>
      <div style="flex:1"></div>
      <button id="btnClearCache" class="tab" title="Lokale Zwischenspeicher für diese Liga löschen">Cache leeren</button>
    </div>
    <div class="sub" id="headerSub" style="margin:-8px 0 8px 2px"></div>
  <!-- chunkNav removed: processing all league matches now -->

    

    <div class="tabs" id="mainTabs" style="margin-top:12px">
      <button class="tab active" data-tab="highlights">Highlights</button>
      <button class="tab" data-tab="players">Players</button>
      <button class="tab" data-tab="heroes">Heroes</button>
  <button class="tab" data-tab="draft">Draft</button>
  <button class="tab" data-tab="teams">Teams</button>
  <button class="tab" data-tab="placement">Placement</button>
      <button class="tab" data-tab="awards">Awards</button>
      <button class="tab" data-tab="laneduos">Lane Duos</button>
      <button class="tab" data-tab="itemsbought">Items Bought</button>
      <button class="tab" data-tab="wards">Wards</button>
    </div>

    <div id="pane-highlights" class="tabpane active">
      <div id="highlightsCard" class="card" style="margin-top:12px;display:none">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px">
          <h2 style="margin:0;font-size:18px">Highlights</h2>
          <div class="sub" id="rangeLabel"></div>
        </div>
        <div id="highlightsBody"></div>
      </div>
    </div>

    <div id="pane-players" class="tabpane" style="display:none">
      <section class="card">
        <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:8px">
          <h2 style="margin:0;font-size:18px">Players</h2>
          <button class="tab" id="exportPlayersCsv">Export CSV</button>
        </div>
        <table class="table sortable" id="playersTable">
          <thead>
            <tr>
              <th data-type="text">Name</th>
              <th data-type="num">Games</th>
              <th data-type="num">W-L</th>
              <th data-type="num">WR</th>
              <th data-type="num">Hero pool</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </section>
    </div>

    <div id="pane-heroes" class="tabpane" style="display:none">
      <section class="card">
        <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:8px">
          <h2 style="margin:0;font-size:18px">Heroes</h2>
          <button class="tab" id="exportHeroesCsv">Export CSV</button>
        </div>
        <table class="table sortable" id="heroesTable">
          <thead>
            <tr>
              <th data-type="text">Hero</th>
              <th data-type="num">Picks</th>
              <th data-type="num">Bans</th>
              <th data-type="num">Wins</th>
              <th data-type="num">WR</th>
              <th data-type="text">Best player</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </section>
    </div>

    <div id="pane-draft" class="tabpane" style="display:none">
      <section class="card">
        <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:8px">
          <h2 style="margin:0;font-size:18px">Draft</h2>
          <button class="tab" id="exportDraftCsv">Export CSV</button>
        </div>
        <div id="draftMount" class="sub"><span class="spinner"></span> Loading…</div>
      </section>
    </div>

    <div id="pane-teams" class="tabpane" style="display:none">
      <section class="card">
        <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:8px">
          <h2 style="margin:0;font-size:18px">Teams</h2>
          <button class="tab" id="exportTeamsCsv">Export CSV</button>
        </div>
        <table class="table sortable" id="teamsTable">
          <thead>
            <tr>
              <th data-type="text">Team</th>
              <th data-type="num">Games</th>
              <th data-type="num">W-L</th>
              <th data-type="num">WR</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </section>
    </div>

    <div id="pane-placement" class="tabpane" style="display:none">
      <section class="card">
        <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:8px">
          <h2 style="margin:0;font-size:18px">Placement</h2>
          <button class="tab" id="exportPlacementCsv">Export CSV</button>
        </div>
        <table class="table sortable" id="placementTable">
          <thead>
            <tr>
              <th data-type="num">#</th>
              <th data-type="text">Team</th>
              <th data-type="num">Games</th>
              <th data-type="num">W-L</th>
              <th data-type="num">WR</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </section>
    </div>

    <div id="pane-awards" class="tabpane" style="display:none">
      <section class="card">
        <h2 style="margin:0 0 8px;font-size:18px">🏆 Awards</h2>
        <div id="awardsBody" class="sub"><span class="spinner"></span> Computing…</div>
      </section>
    </div>

    <div id="pane-laneduos" class="tabpane" style="display:none">
      <section class="card">
        <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:8px">
          <h2 style="margin:0;font-size:18px">Lane Duos</h2>
          <button class="tab" id="exportLaneDuosCsv">Export CSV</button>
        </div>
        <div id="ldMount" class="sub"><span class="spinner"></span> Loading…</div>
      </section>
    </div>

  <div id="pane-itemsbought" class="tabpane" style="display:none">
      <section class="card">
        <h2 style="margin:0 0 8px;font-size:18px">Items Bought</h2>
        <div id="ibMount" class="sub">Loading…</div>
      </section>
    </div>

    

    <div id="pane-wards" class="tabpane" style="display:none">
      <section class="card" style="margin-top:12px">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px">
          <h2 style="margin:0;font-size:18px">Wards</h2>
          <div class="sub">League ward stats</div>
        </div>
        <div id="dvWardMount"><span class="spinner"></span> Preparing…</div>
      </section>
    </div>
  </div>

  <script>
    const OD_PLAYER_URL = id => `https://www.opendota.com/players/${id}`;
    const OD_MATCH_URL = id => `https://www.opendota.com/matches/${id}`;
    function fmtPct(x) { return (x * 100).toFixed(1) + '%'; }

    async function loadJson(u) {
      try {
        const r = await fetch(u, { cache: 'no-store' });
        if (!r.ok) return null;
        return await r.json();
      } catch (_e) { return null; }
    }
    async function loadJsonWithFallback(rel, raw) {
      const isFile = (typeof location !== 'undefined' && location.protocol === 'file:');
      if (isFile) { const a = await loadJson(raw); if (a) return a; return await loadJson(rel); }
      else { const a = await loadJson(rel); if (a) return a; return await loadJson(raw); }
    }
    async function loadFirst(urls) {
      for (const u of urls) { const j = await loadJson(u); if (j) return j; }
      return null;
    }

    function makeHeroMap(heroesRaw) {
      const map = {};
      if (!heroesRaw) return map;
      const add = (obj) => {
        if (!obj) return;
        const id = String(obj.id || obj.hero_id || obj.npc_id || obj.key || obj.key_id || obj.code || obj.slug || obj);
        if (!/^[0-9]+$/.test(id)) return;
        const name = obj.localized_name || obj.name_localized || obj.displayName || obj.name || `Hero ${id}`;
        let img = obj.img || obj.icon || '';
        if (img && !/^https?:/i.test(img)) {
          // OpenDota/Valve asset paths start with /apps/dota2/...; prefix Valve CDN for absolute access
          img = `https://cdn.cloudflare.steamstatic.com${img}`;
        }
        map[id] = { id: Number(id), name, img };
      };
      if (Array.isArray(heroesRaw)) { heroesRaw.forEach(add); }
      else if (typeof heroesRaw === 'object') { Object.values(heroesRaw).forEach(add); }
      return map;
    }

    function sortTable(table, col, type, asc) {
      const tbody = table.tBodies[0];
      if (!tbody) return;
      const rows = Array.from(tbody.rows);
      function val(td) {
        const ds = td.dataset && td.dataset.sort !== undefined ? td.dataset.sort : null;
        if (ds !== null) {
          const n = parseFloat(String(ds).replace('%', '').replace(',', '.'));
          return isNaN(n) ? String(ds).toLowerCase() : n;
        }
        const t = td.textContent.trim().replace('%', '').replace(',', '.');
        const n = parseFloat(t);
        return isNaN(n) ? t.toLowerCase() : n;
      }
      rows.sort((a, b) => {
        let va = val(a.cells[col]), vb = val(b.cells[col]);
        if (type === 'text') return asc ? String(va).localeCompare(String(vb)) : String(vb).localeCompare(String(va));
        va = parseFloat(va) || 0; vb = parseFloat(vb) || 0;
        return asc ? va - vb : vb - va;
      });
      rows.forEach(r => tbody.appendChild(r));
      table.querySelectorAll('th').forEach(th => th.classList.remove('sorted-asc', 'sorted-desc'));
      const th = table.querySelectorAll('th')[col];
      if (th) th.classList.add(asc ? 'sorted-asc' : 'sorted-desc');
    }
    function enableSorting() {
      document.querySelectorAll('table.sortable').forEach(table => {
        table.querySelectorAll('th').forEach((th, i) => {
          th.addEventListener('click', () => {
            const type = th.dataset.type || 'text';
            const asc = !th.classList.contains('sorted-asc');
            sortTable(table, i, type, asc);
          });
        });
      });
    }

    function aggregate(matches, playerNames, teamNames) {
      const teams = new Map(), players = new Map(), teamPlayers = new Map(), heroStats = new Map(), heroPlayerAgg = new Map();
      for (const m of matches) {
        const radWin = !!m.radiant_win, radTeamId = m.radiant_team_id | 0, dirTeamId = m.dire_team_id | 0;
        const radName = teamNames[String(radTeamId)] || m.radiant_name || 'Radiant';
        const dirName = teamNames[String(dirTeamId)] || m.dire_name || 'Dire';
        function ensureTeam(id, name) { if (!id) return; if (!teams.has(id)) teams.set(id, { team_id: id, name, games: 0, wins: 0, losses: 0 }); }
        ensureTeam(radTeamId, radName); ensureTeam(dirTeamId, dirName);
        if (radTeamId) { const t = teams.get(radTeamId); t.games++; if (radWin) t.wins++; else t.losses++; if (radName && radName !== 'Radiant') t.name = radName; }
        if (dirTeamId) { const t = teams.get(dirTeamId); t.games++; if (radWin) t.losses++; else t.wins++; if (dirName && dirName !== 'Dire') t.name = dirName; }
        if (Array.isArray(m.picks_bans)) for (const pb of m.picks_bans) {
          const hid = pb.hero_id | 0; let hs = heroStats.get(hid);
          if (!hs) { hs = { picks: 0, wins: 0, bans: 0 }; heroStats.set(hid, hs); }
          if (!pb.is_pick) hs.bans++;
        }
        for (const p of m.players || []) {
          const id = Number(p.account_id || 0); if (!(id > 0)) continue;
          if (!players.has(id)) { const nm = playerNames[String(id)] || p.personaname || `Player ${id}`; players.set(id, { account_id: id, name: nm, games: 0, wins: 0, heroes: {}, heroWins: {}, profile: OD_PLAYER_URL(id) }); }
          const ps = players.get(id); ps.games++; const won = p.is_radiant ? radWin : !radWin; if (won) ps.wins++;
          const hid = p.hero_id | 0; if (hid > 0) {
            ps.heroes[String(hid)] = (ps.heroes[String(hid)] || 0) + 1; ps.heroWins[String(hid)] = (ps.heroWins[String(hid)] || 0) + (won ? 1 : 0);
            let hs = heroStats.get(hid); if (!hs) { hs = { picks: 0, wins: 0, bans: 0 }; heroStats.set(hid, hs); }
            hs.picks++; if (won) hs.wins++;
            if (!heroPlayerAgg.has(hid)) heroPlayerAgg.set(hid, new Map());
            if (!heroPlayerAgg.get(hid).has(id)) heroPlayerAgg.get(hid).set(id, { account_id: id, name: ps.name, games: 0, wins: 0, profile: ps.profile });
            const hp = heroPlayerAgg.get(hid).get(id); hp.games++; if (won) hp.wins++;
          }
          const teamId = p.is_radiant ? radTeamId : dirTeamId; if (teamId) {
            if (!teamPlayers.has(teamId)) teamPlayers.set(teamId, new Map());
            if (!teamPlayers.get(teamId).has(id)) teamPlayers.get(teamId).set(id, { account_id: id, name: ps.name, games: 0, wins: 0, profile: ps.profile });
            const tp = teamPlayers.get(teamId).get(id); tp.games++; if (won) tp.wins++;
          }
        }
      }
      return { teams, players, teamPlayers, heroStats, heroPlayerAgg };
    }

    let __focusAid = 0, __userOnlyAid = 0;
    function render({ teams, players, teamPlayers, heroStats, heroPlayerAgg }, heroMap, opts) {
      const teamResolver = opts && typeof opts.teamResolver === 'function' ? opts.teamResolver : null;
      // Build primary team mapping: for each player choose the team with most games in this league
      const primaryTeamByAid = {};
      for (const [tid, pmap] of teamPlayers.entries()) {
        const teamName = (teams.get(tid) && teams.get(tid).name) || `Team ${tid}`;
        for (const [aid, st] of pmap.entries()) {
          const k = String(aid);
          const prev = primaryTeamByAid[k];
          if (!prev || (st.games || 0) > (prev.games || 0)) {
            primaryTeamByAid[k] = { name: teamName, games: st.games };
          }
        }
      }
      let plist = Array.from(players.values());
      if (__userOnlyAid > 0) plist = plist.filter(p => Number(p.account_id) === __userOnlyAid);
      if (__focusAid > 0) { const idx = plist.findIndex(p => Number(p.account_id) === __focusAid); if (idx > 0) { const [it] = plist.splice(idx, 1); plist.unshift(it); } }

      const playerRows = plist.map(p => {
        const wr = p.games ? p.wins / p.games : 0; const poolSize = Object.keys(p.heroes || {}).length;
        const resolvedTeam = teamResolver ? (teamResolver(p.account_id) || '') : '';
        const pt = primaryTeamByAid[String(p.account_id)];
        const teamName = resolvedTeam || (pt && pt.name) || '';
        const teamLabel = teamName ? ` <span class='sub' style='margin-left:6px'>(${teamName})</span>` : '';
        return (
          `<tr>
            <td data-sort='${p.name.toLowerCase()} ${teamName ? teamName.toLowerCase() : ''}'>
              <a href='${p.profile}' target='_blank'>${p.name}</a>${teamLabel}
            </td>
            <td data-sort='${p.games}'>${p.games}</td>
            <td data-sort='${p.wins / (p.games || 1)}'><span class='win'>${p.wins}</span>-<span class='loss'>${p.games - p.wins}</span></td>
            <td data-sort='${wr}'>${fmtPct(wr)}</td>
            <td data-sort='${poolSize}'>${poolSize}</td>
          </tr>`
        );
      }).join('');
      document.querySelector('#playersTable tbody').innerHTML = playerRows;

      const teamRows = Array.from(teams.values()).map(t => {
        const wr = t.games ? t.wins / t.games : 0;
        return (
          `<tr>
            <td data-sort='${t.name.toLowerCase()}'>${t.name}</td>
            <td data-sort='${t.games}'>${t.games}</td>
            <td data-sort='${t.wins / (t.games || 1)}'><span class='win'>${t.wins}</span>-<span class='loss'>${t.losses}</span></td>
            <td data-sort='${wr}'>${fmtPct(wr)}</td>
          </tr>`
        );
      }).join('');
      document.querySelector('#teamsTable tbody').innerHTML = teamRows;

      const heroRows = Array.from(heroStats.keys()).map(hid => {
        const hs = heroStats.get(hid);
        const picks = hs.picks | 0, wins = hs.wins | 0, bans = hs.bans | 0, wr = picks ? wins / picks : 0;
        const meta = heroMap[String(hid)] || { name: `Hero ${hid}`, img: '' };
        let bestLabel = '<span class="badge">no data</span>', bestWr = 0;
        const hpa = heroPlayerAgg.get(hid);
        if (hpa) {
          const arr = Array.from(hpa.values()).filter(x => x.games > 0).map(x => ({ ...x, wr: x.wins / x.games })).sort((a, b) => b.wr - a.wr || b.games - a.games);
          if (arr.length) { const b = arr[0]; bestLabel = `<a href='${b.profile}' target='_blank'>${b.name}</a> - ${fmtPct(b.wr)} (${b.wins}/${b.games})`; bestWr = b.wr; }
        }
        return (
          `<tr>
            <td data-sort='${meta.name.toLowerCase()}'>
              <div style='display:flex;align-items:center;gap:8px'>
                <img src='${meta.img}' loading='lazy' decoding='async' style='width:28px;height:28px;border-radius:6px;border:1px solid rgba(255,255,255,.1)'>
                <span>${meta.name}</span>
              </div>
            </td>
            <td data-sort='${picks}'>${picks}</td>
            <td data-sort='${bans}'>${bans}</td>
            <td data-sort='${wins}'>${wins}</td>
            <td data-sort='${wr}'>${fmtPct(wr)}</td>
            <td data-sort='${bestWr}'>${bestLabel}</td>
          </tr>`
        );
      }).join('');
      document.querySelector('#heroesTable tbody').innerHTML = heroRows;

      if (!window.__lvSortedOnce) {
        sortTable(document.getElementById('playersTable'), 3, 'num', false);
        sortTable(document.getElementById('teamsTable'), 3, 'num', false);
        sortTable(document.getElementById('heroesTable'), 1, 'num', false);
        window.__lvSortedOnce = true;
      }
    }

    // summary cards removed for league view

    async function pMap(items, limit, worker) {
      const ret = new Array(items.length); let i = 0; let active = 0;
      return await new Promise(res => {
        function next() {
          if (i >= items.length && active === 0) { res(ret); return; }
          while (active < limit && i < items.length) {
            const idx = i++; active++;
            Promise.resolve(worker(items[idx], idx)).then(v => { ret[idx] = v; active--; next(); }).catch(() => { ret[idx] = null; active--; next(); });
          }
        }
        next();
      });
    }

    async function fetchMatchDetail(id, relBase, rawBase) {
      const localPreferred = `${relBase}/cache/OpenDota/matches/${id}.json`;
      const localAlt = `data/cache/OpenDota/matches/${id}.json`;
      const remote = `${rawBase}/cache/OpenDota/matches/${id}.json`;
      return await loadFirst([localPreferred, localAlt, remote]);
    }

    function computeHighlightsFromDetails(details, resolver, teamResolver) {
      const rampages = new Map(), rapierBy = new Map(), gemBy = new Map(), duosSafe = new Map(), duosOff = new Map(), roshanTeam = { Radiant: 0, Dire: 0 };
      let bestGPM = null, bestKills = null, bestAssists = null, bestNet = null;
      const durList = [];
      function add(map, k, inc = 1) { map.set(String(k), (map.get(String(k)) || 0) + inc); }

      for (const md of details) {
        if (!md) continue; const mid = Number(md.match_id || 0);
        const players = Array.isArray(md.players) ? md.players : []; const radWin = !!md.radiant_win;
        for (const p of players) {
          const aid = Number(p.account_id || 0); if (aid > 0) {
            const mk = p.multi_kills || {}; const r = Number(mk['5'] || 0); if (r > 0) add(rampages, aid, r);
            const displayName = (resolver && resolver(aid)) || p.personaname || `Player ${aid}`;
            const teamTag = (teamResolver && teamResolver(aid)) || '';
            const display = teamTag ? `${displayName} (${teamTag})` : displayName;
            const setBest = (cur, val) => val > 0 && (!cur || (cur.value || 0) < val)
              ? { account_id: aid, name: display, profile: OD_PLAYER_URL(aid), value: val, match_id: mid } : cur;
            bestGPM = setBest(bestGPM, Number(p.gold_per_min || 0));
            bestKills = setBest(bestKills, Number(p.kills || 0));
            bestAssists = setBest(bestAssists, Number(p.assists || 0));
            bestNet = setBest(bestNet, Number(p.net_worth || 0) || Number(p.total_gold || 0));
            const log = Array.isArray(p.purchase_log) ? p.purchase_log : [];
            for (const ev of log) { const k = String(ev.key || '').toLowerCase(); if (k.includes('rapier')) add(rapierBy, aid, 1); if (k === 'gem' || k.includes('gem_of_true_sight')) add(gemBy, aid, 1); }
          }
        }
        for (const side of ['radiant', 'dire']) {
          const sidePlayers = players.filter(pl => (pl.is_radiant && side === 'radiant') || (!pl.is_radiant && side === 'dire'));
          for (const laneName of ['Safe', 'Off']) {
            const code = laneName === 'Safe' ? 1 : 3; const lanePlayers = sidePlayers.filter(pl => (pl.lane_role | 0) === code);
            if (lanePlayers.length === 2) { const pair = [Number(lanePlayers[0].hero_id), Number(lanePlayers[1].hero_id)].sort((a, b) => a - b); const key = `${pair[0]}-${pair[1]}`; const mp = laneName === 'Safe' ? duosSafe : duosOff; const rec = mp.get(key) || { games: 0, wins: 0 }; rec.games++; const laneWin = (side === 'radiant' && radWin) || (side === 'dire' && !radWin); if (laneWin) rec.wins++; mp.set(key, rec); }
          }
        }
        if (Array.isArray(md.objectives)) for (const ev of md.objectives) { if (/roshan_kill/i.test(String(ev.type || ''))) { const team = (ev.team === 2 || ev.team === 0 || ev.key === 'radiant') ? 'Radiant' : 'Dire'; roshanTeam[team]++; } }
        durList.push({ match_id: mid, duration: Number(md.duration || 0), radiant_win: radWin });
      }
  function topN(map, n) { return Array.from(map.entries()).map(([aid, c]) => { const id = Number(aid); const base = (resolver && resolver(id)) || `Player ${id}`; const tag = (teamResolver && teamResolver(id)) || ''; const name = tag ? `${base} (${tag})` : base; return { account_id: id, name, profile: OD_PLAYER_URL(id), count: c }; }).sort((a, b) => b.count - a.count).slice(0, n); }
      function duosFrom(mp) { return Array.from(mp.entries()).map(([k, v]) => { const [a, b] = k.split('-').map(Number); return { a, b, games: v.games, wins: v.wins, winrate: v.games ? v.wins / v.games : 0 }; }).sort((a, b) => b.winrate - a.winrate || b.games - a.games).slice(0, 5); }
      const topSingle = {}; if (bestGPM) topSingle.gpm = bestGPM; if (bestKills) topSingle.kills = bestKills; if (bestAssists) topSingle.assists = bestAssists; if (bestNet) topSingle.networth = bestNet;
      const durationLongest = durList.slice().sort((a, b) => b.duration - a.duration).slice(0, 3);
      const durationShortest = durList.slice().sort((a, b) => a.duration - b.duration).slice(0, 3);
      return { rampages: topN(rampages, 10), rapierTop: topN(rapierBy, 3), gemTop: topN(gemBy, 3), topSingle, safeDuos: duosFrom(duosSafe), offDuos: duosFrom(duosOff), roshan: roshanTeam, durationLongest, durationShortest };
    }

    function detailsToMatches(details, matchesFallback) {
      // Convert detailed match objects to the lightweight structure expected by aggregate()
      const out = [];
      // Build a quick lookup from matches.json for missing team IDs/names
      const matchById = new Map();
      if (Array.isArray(matchesFallback)) {
        for (const m of matchesFallback) {
          const mid = Number(m.match_id || 0);
          if (!mid) continue;
          matchById.set(mid, {
            radiant_team_id: Number(m.radiant_team_id || 0),
            dire_team_id: Number(m.dire_team_id || 0),
            radiant_name: m.radiant_name || '',
            dire_name: m.dire_name || ''
          });
        }
      }
      for (const d of details || []) {
        if (!d) continue;
        const mid = Number(d.match_id || 0);
        // Primary from details
        let radTeamId = Number(d.radiant_team_id || (d.radiant_team && d.radiant_team.team_id) || 0);
        let dirTeamId = Number(d.dire_team_id || (d.dire_team && d.dire_team.team_id) || 0);
        let radName = (d.radiant_team && d.radiant_team.name) || d.radiant_name || '';
        let dirName = (d.dire_team && d.dire_team.name) || d.dire_name || '';
        // Fallback from matches.json if details missing/0 or generic
        const isGeneric = (s) => { const t = (s||'').toString().trim(); return !t || /^radiant$/i.test(t) || /^dire$/i.test(t); };
        const fb = matchById.get(mid);
        if (fb) {
          if (!radTeamId && Number(fb.radiant_team_id || 0)) radTeamId = Number(fb.radiant_team_id || 0);
          if (!dirTeamId && Number(fb.dire_team_id || 0)) dirTeamId = Number(fb.dire_team_id || 0);
          if (isGeneric(radName) && fb.radiant_name) radName = fb.radiant_name;
          if (isGeneric(dirName) && fb.dire_name) dirName = fb.dire_name;
        }
        if (!radName) radName = 'Radiant';
        if (!dirName) dirName = 'Dire';
        const players = Array.isArray(d.players) ? d.players.map(p => ({
          account_id: Number(p.account_id || 0),
          hero_id: Number(p.hero_id || 0),
          // Robust radiant detection across schemas
          is_radiant: !!(p.isRadiant ?? p.is_radiant ?? ((p.player_slot|0) < 128)),
          personaname: p.personaname || null
        })) : [];
        const picks_bans = Array.isArray(d.picks_bans) ? d.picks_bans.map(pb => ({
          hero_id: Number(pb.hero_id || 0),
          is_pick: !!pb.is_pick,
          team: (pb.team !== undefined ? Number(pb.team) : (pb.is_radiant ? 0 : 1)),
          order: Number(pb.order || pb.pick_order || pb.draft_order || 0)
        })) : [];
        out.push({
          match_id: mid,
          radiant_win: !!d.radiant_win,
          radiant_team_id: radTeamId,
          dire_team_id: dirTeamId,
          radiant_name: radName,
          dire_name: dirName,
          players,
          picks_bans
        });
      }
      return out;
    }

    function renderHighlights(high) {
      const card = document.getElementById('highlightsCard');
      const body = document.getElementById('highlightsBody');
      if (!high) { card.style.display = 'none'; body.innerHTML = ''; return; }
      function simple(arr) { if (!Array.isArray(arr) || !arr.length) return `<li><span class='sub'>no data</span></li>`; return arr.map(it => `<li><span>${it.name}</span><span class='badge'>x${it.count}</span></li>`).join(''); }
      function durList(arr) { if (!Array.isArray(arr) || !arr.length) return `<li><span class='sub'>no games</span></li>`; return arr.map(x => { const sec = Number(x.duration || 0); const mm = Math.floor(sec / 60), ss = sec % 60; return `<li><span><a target='_blank' href='${OD_MATCH_URL(x.match_id)}'>M${x.match_id}</a></span><span class='badge'>${mm}m ${ss}s</span></li>`; }).join(''); }
      function topPerf() {
        const order = ['gpm', 'kills', 'assists', 'networth']; const icons = { gpm: '💰', kills: '⚔️', assists: '🤝', networth: '💎' };
        return `<div class='perf-grid'>` + order.map(k => { const p = high.topSingle[k]; if (!p) return ''; return `<div class='perf-card'><div class='perf-left'><div class='perf-icon'>${icons[k]}</div><div class='perf-meta'><div class='perf-label'>${k}</div><div class='perf-player'><a href='${p.profile}' target='_blank'>${p.name}</a></div></div></div><div class='perf-actions'><div class='perf-value'>${p.value}</div><a class='badge' target='_blank' href='${OD_MATCH_URL(p.match_id)}'>Match</a></div></div>`; }).join('') + `</div>`;
      }
      body.innerHTML = `
        ${topPerf()}
        <div class='grid3' style='display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:12px;margin-top:8px'>
          <div><h3>Rampages</h3><ul class='simple'>${simple(high.rampages)}</ul></div>
          <div><h3>Rapiers</h3><ul class='simple'>${simple(high.rapierTop)}</ul></div>
          <div><h3>Gems</h3><ul class='simple'>${simple(high.gemTop)}</ul></div>
        </div>
        <div style='margin-top:8px'>
          <h3>Roshan Taken</h3>
          <ul class='simple'>
            <li><span>Radiant</span><span class='badge'>x${high.roshan.Radiant}</span></li>
            <li><span>Dire</span><span class='badge'>x${high.roshan.Dire}</span></li>
          </ul>
        </div>
        <div class='grid2' style='display:grid;grid-template-columns:repeat(auto-fit,minmax(260px,1fr));gap:12px;margin-top:8px'>
          <div><h3>3 longest matches</h3><ul class='simple'>${durList(high.durationLongest)}</ul></div>
          <div><h3>3 shortest matches</h3><ul class='simple'>${durList(high.durationShortest)}</ul></div>
        </div>`;
      card.style.display = '';
    }

    function computeAwardsFromDetails(details, resolver) {
      const agg = new Map(); // aid -> aggregated stats
      function ensure(aid){ if (!agg.has(aid)) agg.set(aid, { games:0, wins:0, k:0, a:0, d:0, gpmTotal:0, obs:0, sent:0, obsLog:0, sentLog:0, mvpCount:0, dmg:0, tdmg:0, lh10:0, stuns:0, visionScore:0, kpSum:0, name: (resolver && resolver(aid)) || `Player ${aid}`, profile: OD_PLAYER_URL(aid) }); return agg.get(aid); }
      for (const md of details) {
        if (!md) continue; const radWin = !!md.radiant_win;
        // Per-match MVP proxy: pick the player with highest score = kills*2 + assists + gpm/100 + (win?1:0)
        let best = null;
        for (const p of (md.players || [])) {
          const aid = Number(p.account_id || 0); if (!(aid > 0)) continue; const won = p.is_radiant ? radWin : !radWin;
          const st = ensure(aid); st.games++; if (won) st.wins++;
          const k = Number(p.kills || 0), a = Number(p.assists || 0), d = Number(p.deaths || 0), gpm = Number(p.gold_per_min || 0);
          st.k += k; st.a += a; st.d += d; st.gpmTotal += gpm;
          st.dmg += Number(p.hero_damage || 0);
          st.tdmg += Number(p.tower_damage || 0);
          // Last hits at 10 (when available)
          try { if (p.lh_t && (Array.isArray(p.lh_t) || typeof p.lh_t === 'object')) { const arr = Array.isArray(p.lh_t) ? p.lh_t : Object.values(p.lh_t); if (arr && arr.length > 10) st.lh10 += Number(arr[10] || 0); } } catch(_e) {}
          st.stuns += Number(p.stuns || 0);
          const obsPlaced = Number(p.obs_placed || 0), senPlaced = Number(p.sen_placed || 0);
          st.obs += obsPlaced; st.sent += senPlaced; st.visionScore += obsPlaced + senPlaced;
          const oblog = Array.isArray(p.obs_log) ? p.obs_log.length : 0; const sl = Array.isArray(p.sen_log) ? p.sen_log.length : 0;
          st.obsLog += oblog; st.sentLog += sl; st.visionScore += oblog + sl + Number(p.camps_stacked || 0);
          const score = (k*2) + a + (gpm/100) + (won ? 1 : 0);
          if (!best || score > best.score) best = { aid, score };
        }
        // Kill participation proxy per team
        const radKills = (md.players||[]).filter(x=>x.is_radiant).reduce((s,x)=> s + Number(x.kills||0),0);
        const dirKills = (md.players||[]).filter(x=>!x.is_radiant).reduce((s,x)=> s + Number(x.kills||0),0);
        for (const p of (md.players||[])) {
          const aid = Number(p.account_id||0); if (!(aid>0)) continue;
          const teamKills = p.is_radiant ? radKills : dirKills; const kp = teamKills>0 ? (Number(p.kills||0)+Number(p.assists||0))/teamKills : 0;
          ensure(aid).kpSum += kp;
        }
        if (best && agg.has(best.aid)) agg.get(best.aid).mvpCount++;
      }
      const list = Array.from(agg.entries()).map(([aid, v]) => ({ aid: Number(aid), ...v, kda: (v.k + v.a) / Math.max(1, v.d), avgGpm: v.games ? v.gpmTotal / v.games : 0, avgWards: v.games ? (v.obs + v.sent) / v.games : 0, avgDmg: v.games? v.dmg/v.games:0, avgTDmg: v.games? v.tdmg/v.games:0, avgLH10: v.games? v.lh10/v.games:0, avgStuns: v.games? v.stuns/v.games:0, avgVisionScore: v.games? v.visionScore/v.games:0, avgKP: v.games? v.kpSum/v.games:0 }));
      const minGames = Math.max(3, Math.min(5, Math.floor(list.reduce((m,x)=>Math.max(m,x.games),0) * 0.2) || 3));
      function topBy(fn, filter = x=>x.games>=minGames, n=3){ return list.filter(filter).sort((a,b)=> fn(b)-fn(a) || b.games - a.games).slice(0,n); }
      return {
        mvp: topBy(x=>x.mvpCount, x=>x.mvpCount>0).map(x=>({ name:x.name, profile:x.profile, count:x.mvpCount, games:x.games })),
        bestKDA: topBy(x=>x.kda).map(x=>({ name:x.name, profile:x.profile, kda:x.kda, k:x.k, a:x.a, d:x.d, games:x.games })),
        bestGPM: topBy(x=>x.avgGpm).map(x=>({ name:x.name, profile:x.profile, gpm:x.avgGpm, games:x.games })),
        visionary: topBy(x=>x.avgWards).map(x=>({ name:x.name, profile:x.profile, wards:x.avgWards, games:x.games })),
        mostDamage: topBy(x=>x.avgDmg).map(x=>({ name:x.name, profile:x.profile, dmg:Math.round(x.avgDmg), games:x.games })),
        mostTowerDamage: topBy(x=>x.avgTDmg).map(x=>({ name:x.name, profile:x.profile, tdmg:Math.round(x.avgTDmg), games:x.games })),
        bestCS10: topBy(x=>x.avgLH10).map(x=>({ name:x.name, profile:x.profile, lh10:Math.round(x.avgLH10), games:x.games })),
        mostStuns: topBy(x=>x.avgStuns).map(x=>({ name:x.name, profile:x.profile, stuns:x.avgStuns.toFixed(1), games:x.games })),
        bestVisionScore: topBy(x=>x.avgVisionScore).map(x=>({ name:x.name, profile:x.profile, vs:x.avgVisionScore.toFixed(1), games:x.games })),
        bestKP: topBy(x=>x.avgKP).map(x=>({ name:x.name, profile:x.profile, kp:(x.avgKP*100).toFixed(1)+'%', games:x.games }))
      };
    }
    function renderAwards(awards) {
      const root = document.getElementById('awardsBody'); if (!root) return;
      function simple(items, fmt){ if (!items || !items.length) return '<div class="sub">no data</div>'; return '<ul class="simple">'+items.map(it=>`<li><span><a href='${it.profile}' target='_blank'>${it.name}</a></span><span class='badge'>${fmt(it)}</span></li>`).join('')+'</ul>'; }
      root.innerHTML = `
        <div class='summary-grid'>
          <div class='summary-card'>
            <h3>MVP (match tops)</h3>
            ${simple(awards.mvp, it=>`x${it.count}`)}
          </div>
          <div class='summary-card'>
            <h3>Best KDA</h3>
            ${simple(awards.bestKDA, it=>`${(it.kda).toFixed(2)} (${it.k}/${it.d}/${it.a})`)}
          </div>
          <div class='summary-card'>
            <h3>Best GPM</h3>
            ${simple(awards.bestGPM, it=>`${Math.round(it.gpm)} gpm`)}
          </div>
          <div class='summary-card'>
            <h3>Visionary</h3>
            ${simple(awards.visionary, it=>`${it.wards.toFixed(1)} wards/game`)}
          </div>
          <div class='summary-card'>
            <h3>Most Damage</h3>
            ${simple(awards.mostDamage, it=>`${it.dmg} hero dmg`)}
          </div>
          <div class='summary-card'>
            <h3>Most Tower Damage</h3>
            ${simple(awards.mostTowerDamage, it=>`${it.tdmg} tower dmg`)}
          </div>
          <div class='summary-card'>
            <h3>Best CS @10</h3>
            ${simple(awards.bestCS10, it=>`${it.lh10} LH @10`)}
          </div>
          <div class='summary-card'>
            <h3>Most Stuns</h3>
            ${simple(awards.mostStuns, it=>`${it.stuns} stuns`)}
          </div>
          <div class='summary-card'>
            <h3>Best Vision Score</h3>
            ${simple(awards.bestVisionScore, it=>`${it.vs} score`)}
          </div>
          <div class='summary-card'>
            <h3>Best Kill Participation</h3>
            ${simple(awards.bestKP, it=>`${it.kp}`)}
          </div>
        </div>`;
    }

    

    async function main() {
      (function () {
        const tabsRoot = document.getElementById('mainTabs'); const tabs = Array.from(tabsRoot.querySelectorAll('.tab'));
        function showTab(name) {
          ['highlights','players','heroes','draft','teams','placement','awards','laneduos','itemsbought','wards'].forEach(id => { const pane = document.getElementById('pane-' + id); if (pane) pane.style.display = (id === name) ? '' : 'none'; });
          tabs.forEach(b => b.classList.toggle('active', b.getAttribute('data-tab') === name));
          try { localStorage.setItem('lv_tab', name || 'highlights'); } catch (_e) {}
          // Lazy-mount heavy tabs when opened
          if (name === 'draft' && window.__ensureDraft) window.__ensureDraft();
          if (name === 'laneduos' && window.__ensureLaneDuos) window.__ensureLaneDuos();
          if (name === 'itemsbought' && window.__ensureItems) window.__ensureItems();
          if (name === 'wards' && window.__ensureWards) window.__ensureWards();
          if (name === 'awards' && window.__ensureAwards) window.__ensureAwards();
          if (name === 'placement' && window.__ensurePlacement) window.__ensurePlacement();
        }
        tabs.forEach(b => b.addEventListener('click', () => showTab(b.getAttribute('data-tab'))));
        window.__lvShowTab = showTab;
      })();

      const REPO = 'Zeroks77/Kret_Dota', BRANCH = 'main';
      const relBase = '../data', rawBase = `https://raw.githubusercontent.com/${REPO}/${BRANCH}/data`;
    const sp = new URLSearchParams(location.search); const slug = sp.get('league') || sp.get('l') || 'TI2025';

    // Optional: explicit folder under docs containing matches.json/report.json (e.g., 'league/2025/TI2025')
    const leaguePath = (sp.get('leaguePath') || '').replace(/^\/+/, '').replace(/\/+$/, '');
    const relBases = [
      ...(leaguePath ? [leaguePath] : []),
      '../data',
      'data'
    ];
    const fromBases = (p) => relBases.map(b => `${b}/${p}`);
    // Parallelize all initial JSON loads
    const [matchesRaw, heroesRaw, mapConfRaw, report, proPlayers] = await Promise.all([
      loadFirst([...fromBases(`league/${slug}/matches.json`), `${rawBase}/league/${slug}/matches.json`]),
      loadFirst([...fromBases(`heroes.json`), `${rawBase}/heroes.json`]),
      loadFirst([...fromBases(`maps.json`), `${rawBase}/maps.json`]),
  loadFirst([...fromBases(`league/${slug}/report.json`), `${rawBase}/league/${slug}/report.json`]),
      loadFirst([ ...fromBases(`cache/OpenDota/proPlayers.json`), `${rawBase}/cache/OpenDota/proPlayers.json` ])
    ]);
  const matches = Array.isArray(matchesRaw) ? matchesRaw : (matchesRaw && matchesRaw.matches ? matchesRaw.matches : []);
    const heroes = makeHeroMap(heroesRaw);
    const mapConf = mapConfRaw || {};
      try {
        const name = (report && ((report.meta && (report.meta.name || report.meta.title)) || (report.league && report.league.name))) || slug;
        document.getElementById('leagueTitle').textContent = `${name} – League viewer`;
        const times = matches.map(m => m.start_time).filter(Boolean); const min = Math.min(...times), max = Math.max(...times);
        const fmt = s => { const d = new Date(s * 1000); return d.toISOString().slice(0, 10); };
        const hdr = document.getElementById('headerSub');
        if (hdr) hdr.textContent = `${matches.length} matches · ${isFinite(min) ? fmt(min) : '?'} to ${isFinite(max) ? fmt(max) : '?'} (UTC)`;
        const rl = document.getElementById('rangeLabel'); if (rl) rl.textContent = `${matches.length} matches`;
      } catch (_e) {}

  const playerNames = {}, teamNames = {};
      // Build pro metadata: display name + optional team tag/name from proPlayers
      const proMap = new Map(); // aid -> display name
      const proMeta = new Map(); // aid -> { name, team_tag, team_name }
      if (Array.isArray(proPlayers)) {
        for (const p of proPlayers) {
          const aid = Number(p && p.account_id || 0); if (!(aid > 0)) continue;
          const nm = (p.name && String(p.name).trim()) || (p.personaname && String(p.personaname).trim()) || null;
          if (nm) proMap.set(aid, nm);
          proMeta.set(aid, {
            name: nm || null,
            team_tag: (p.team_tag && String(p.team_tag).trim()) || null,
            team_name: (p.team_name && String(p.team_name).trim()) || null
          });
        }
      }
      // 1) Overlay names from report.playerTeams first (league-scoped canonical names)
      try {
        const pts = report && report.playerTeams; if (Array.isArray(pts)) {
          for (const it of pts) {
            const aid = Number(it && it.account_id || 0); if (!(aid > 0)) continue;
            const nm = (it.name && String(it.name).trim()) || null; if (nm) playerNames[String(aid)] = nm;
            const tid = Number(it.team_id || 0); const tn = (it.team_name && String(it.team_name).trim()) || null;
            if (tid && tn) teamNames[String(tid)] = tn;
          }
        }
      } catch(_e){}

      // 2) Add/complete from matches list (fallbacks)
      for (const m of matches) {
        if (Array.isArray(m.players)) for (const p of m.players) {
          if (p && p.account_id > 0) {
            const aid = Number(p.account_id);
            const pro = proMap.get(aid);
            const nm = pro || (p.personaname || '').trim();
            if (nm && !playerNames[String(aid)]) playerNames[String(aid)] = nm;
          }
        }
        if (m.radiant_team_id && m.radiant_name && !teamNames[String(m.radiant_team_id)]) teamNames[String(m.radiant_team_id)] = m.radiant_name;
        if (m.dire_team_id && m.dire_name && !teamNames[String(m.dire_team_id)]) teamNames[String(m.dire_team_id)] = m.dire_name;
      }

  const agg = aggregate(matches, playerNames, teamNames);
  render(agg, heroes);
      enableSorting();
      // Start fetching details in background with higher concurrency
      const ids = matches.map(m => m.match_id).filter(Boolean);
      const conc = Math.min(8, Math.max(4, (typeof navigator !== 'undefined' && navigator.hardwareConcurrency) ? navigator.hardwareConcurrency : 4));
      // Caching: try hydrate details from localStorage first
      const cacheKey = `lv_details_${slug}`;
      const cacheMetaKey = `lv_details_meta_${slug}`;
      function computeFingerprint(ms){ try{ const ids = (ms||[]).map(m=>m.match_id).filter(Boolean).sort().join(','); return String(ids).slice(-100); }catch(_e){ return 'na'; } }
      const expectedFp = computeFingerprint(matches);
      let cachedDetails = null;
      try {
        const meta = JSON.parse(localStorage.getItem(cacheMetaKey) || 'null');
        if (meta && meta.fp === expectedFp) {
          const raw = localStorage.getItem(cacheKey);
          if (raw) cachedDetails = JSON.parse(raw);
        }
      } catch(_e){}
      const detailsPromise = (async ()=>{
        if (Array.isArray(cachedDetails) && cachedDetails.length){ return cachedDetails; }
        const arr = await pMap(ids, conc, id => fetchMatchDetail(id, relBase, rawBase));
        const cleaned = (arr || []).filter(Boolean);
        try { localStorage.setItem(cacheKey, JSON.stringify(cleaned)); localStorage.setItem(cacheMetaKey, JSON.stringify({ fp: expectedFp, ts: Date.now(), count: cleaned.length })); } catch(_e){}
        return cleaned;
      })();

      // Once details are ready, enhance names/teams and render Highlights immediately
  let __detailsCache = null, __resolver = null, __teamResolver = null, __highCache = null;
      detailsPromise.then(details => {
        __detailsCache = details;
        // Build names from details and overlay into playerNames with pro priority
        const namesFromDetails = {};
        for (const d of details) {
          for (const p of (d.players || [])) {
            const aid = Number(p.account_id || 0); if (!(aid > 0)) continue;
            const nm = (p.personaname && String(p.personaname).trim()) || '';
            if (nm) namesFromDetails[String(aid)] = nm;
            const pro = proMap.get(aid);
            if (pro) playerNames[String(aid)] = pro; else if (nm) playerNames[String(aid)] = nm;
          }
        }
        // Build per-player team from league details using team IDs
        const teamNameById = new Map();
        const teamIdCountByAid = new Map();
        const teamLabelCountByAid = new Map(); // aid -> Map<label, count>
        const isGeneric = (s) => { const t = (s||'').toString().trim(); return !t || /^radiant$/i.test(t) || /^dire$/i.test(t); };
        for (const d of details) {
          const rid = Number(d.radiant_team_id || (d.radiant_team && d.radiant_team.team_id) || 0);
          const did = Number(d.dire_team_id || (d.dire_team && d.dire_team.team_id) || 0);
          const rnameRaw = (d.radiant_team && d.radiant_team.name) || d.radiant_name || teamNames[String(rid)] || 'Radiant';
          const dnameRaw = (d.dire_team && d.dire_team.name) || d.dire_name || teamNames[String(did)] || 'Dire';
          const rname = isGeneric(rnameRaw) ? '' : String(rnameRaw);
          const dname = isGeneric(dnameRaw) ? '' : String(dnameRaw);
          if (rid) teamNameById.set(rid, rname || `Team ${rid}`); if (did) teamNameById.set(did, dname || `Team ${did}`);
          for (const p of (d.players || [])) {
            const aid = Number(p.account_id || 0); if (!(aid > 0)) continue;
            const tid = p.is_radiant ? rid : did; if (!tid) continue;
            if (!teamIdCountByAid.has(aid)) teamIdCountByAid.set(aid, new Map());
            const inner = teamIdCountByAid.get(aid);
            inner.set(tid, (inner.get(tid) || 0) + 1);
            const label = p.is_radiant ? rname : dname;
            if (label) {
              if (!teamLabelCountByAid.has(aid)) teamLabelCountByAid.set(aid, new Map());
              const lmap = teamLabelCountByAid.get(aid);
              lmap.set(label, (lmap.get(label) || 0) + 1);
            }
          }
        }
        // Pre-build mapping from report.playerTeams if provided by backend generation
        const playerTeamMap = new Map();
        try {
          const arr = report && report.playerTeams; if (Array.isArray(arr)) {
            for (const it of arr) {
              const id = Number(it && it.account_id || 0); if (!(id > 0)) continue;
              const nm = (it.team_name && String(it.team_name).trim()) || '';
              if (nm) playerTeamMap.set(id, nm);
            }
          }
        } catch(_e){}

        __teamResolver = (aid) => {
          const id = Number(aid);
          // Backend-provided mapping preferred
          if (playerTeamMap.has(id)) return playerTeamMap.get(id);
          // Prefer most frequent non-generic team label observed in details
          const lmap = teamLabelCountByAid.get(id);
          if (lmap && lmap.size) {
            let bestLabel = '', bestCnt = -1;
            for (const [label, cnt] of lmap.entries()) { if (cnt > bestCnt) { bestCnt = cnt; bestLabel = label; } }
            if (bestLabel) return bestLabel;
          }
          // Fallback: choose most frequent team id, map to name
          const inner = teamIdCountByAid.get(id);
          if (inner && inner.size) {
            let bestId = 0, bestG = -1;
            for (const [tid, g] of inner.entries()) { if (g > bestG) { bestG = g; bestId = tid; } }
            if (bestId) return teamNameById.get(bestId) || `Team ${bestId}`;
          }
          // Do not use global pro metadata as a fallback here to avoid stale/wrong teams for the league timeframe
          return '';
        };
        __resolver = (aid) => (proMap.get(Number(aid)) || namesFromDetails[String(aid)] || playerNames[String(aid)] || null);

  // Overlay non-generic team names from details for accurate team display
    try { for (const [tid, nm] of teamNameById.entries()) { if (tid && nm && !/^radiant|dire$/i.test(String(nm))) teamNames[String(tid)] = nm; } } catch (_e) {}

  // Re-render tables using detailed data (players, picks/bans) and team resolver
  const matchesFromDetails = detailsToMatches(details, matches);
  const agg2 = aggregate(matchesFromDetails.length ? matchesFromDetails : matches, playerNames, teamNames);
        render(agg2, heroes, { teamResolver: __teamResolver });

        // Compute and render Highlights now
        __highCache = computeHighlightsFromDetails(details, __resolver, __teamResolver);
        renderHighlights(__highCache);
      }).catch(e => console.warn('Details processing failed', e));

      // Lazy mount helpers for heavy tabs
  let mountedDraft = false, mountedLaneDuos = false, mountedItems = false, mountedWards = false, mountedAwards = false, mountedPlacement = false;
      window.__ensureDraft = () => {
        if (mountedDraft) return; mountedDraft = true;
        try {
          const pre = report && report.highlights && report.highlights.draft;
          if (window.DraftViewer && pre && (Array.isArray(pre.contest) || Array.isArray(pre.firstPicks) || Array.isArray(pre.openingPairs))) {
            window.DraftViewer.mount(document.getElementById('draftMount'), { data: { contest: pre.contest||[], firstPicks: pre.firstPicks||[], openingPairs: pre.openingPairs||[] }, heroes, persistKey: `lv_draft_${slug}`, nameResolver: (__resolver || ((aid)=> (playerNames[String(aid)] || `Player ${aid}`))) });
            return;
          }
        } catch(e){ console.warn('DraftViewer precomputed mount failed, falling back', e); }
        // Fallback to client-side computation when precompute not available
        detailsPromise.then(details => {
          try { if (window.DraftViewer) { const draftData = window.DraftViewer.compute(details); window.DraftViewer.mount(document.getElementById('draftMount'), { data: draftData, heroes, persistKey: `lv_draft_${slug}`, nameResolver: (__resolver || ((aid)=> (playerNames[String(aid)] || `Player ${aid}`))) }); } }
          catch(e){ console.warn('DraftViewer mount failed', e); }
        });
      };
      window.__ensureLaneDuos = () => {
        if (mountedLaneDuos) return; mountedLaneDuos = true;
        try {
          const mountEl = document.getElementById('ldMount');
          const pre = report && report.highlights && report.highlights.duos;
          if (window.LaneDuosViewer && pre) {
            const safe = Array.isArray(pre.safelane) ? pre.safelane : [];
            const off = Array.isArray(pre.offlane) ? pre.offlane : [];
            window.LaneDuosViewer.mount(mountEl, { data: { safe, off }, heroes, persistKey: `lv_laneduos_${slug}` });
            return;
          }
        } catch(e){ console.warn('LaneDuosViewer precomputed mount failed, falling back', e); }
        // Fallback to client-side computation when precompute not available
        detailsPromise.then(() => {
          try { if (window.LaneDuosViewer && __highCache) { window.LaneDuosViewer.mount(document.getElementById('ldMount'), { data: { safe: __highCache.safeDuos || [], off: __highCache.offDuos || [] }, heroes, persistKey: `lv_laneduos_${slug}` }); } }
          catch(e){ console.warn('LaneDuosViewer mount failed', e); }
        });
      };
      window.__ensureWards = () => {
        if (mountedItems) return; mountedItems = true;
        detailsPromise.then(details => {
          try {
            const container = document.getElementById('dvWardMount'); if (!container) return;
            container.innerHTML = '';
            const mapConf = window.__mapConf || {};
            // Prefer precomputed viewer block from report.json if available
            const preV = report && report.highlights && report.highlights.wards && report.highlights.wards.viewer;
            if (preV && window.WardViewer) {
              const teamsList = Array.isArray(preV.teams) ? preV.teams : [];
              const playersList = Array.isArray(preV.players) ? preV.players : [];
              const spots = Array.isArray(preV.spots) ? preV.spots : [];
              const sentries = Array.isArray(preV.sentries) ? preV.sentries : [];
              window.WardViewer.mount(container, { mapConf, data: { spots, sentries, teams: teamsList, players: playersList }, options: { modeDefault: 'best', showExtras: true, showLongest: false, ignorePersistedPlayer: true, ignorePersistedCluster: true, extras: { wardPlayers: {}, wardLongest: [] } } });
              return;
            }
            // Fallback: Build viewer data from details
            if (__detailsCache && Array.isArray(__detailsCache)) {
              const consumables = new Set(['tango','flask','healing_salve','enchanted_mango','clarity','faerie_fire','smoke_of_deceit','dust','dust_of_appearance','ward_observer','ward_sentry','sentry_wards','observer_ward','sentry_ward','tpscroll','tp_scroll','enchanted_quiver','bottle','refresher_shard','cheese','tome_of_knowledge','blood_grenade']);
              function norm(k){ return String(k || '').toLowerCase(); }
              for (const d of details) {
                const radWin = !!d.radiant_win;
                (d.players || []).forEach(p => {
                  const aid = Number(p.account_id || 0); if (!(aid > 0)) return; const role = roleCache.get(aid) || 'support';
                  const log = Array.isArray(p.purchase_log) ? p.purchase_log : [];
                  for (const ev of log) {
                    const key = norm(ev.key || ev.item || ''); if (!key || /recipe_/.test(key)) continue;
                    const rec = itemAgg.get(key) || { count: 0, winCount: 0, coreCount: 0, supportCount: 0, cost: 0, consumable: false };
                    rec.count++; if (role === 'core') rec.coreCount++; else rec.supportCount++;
                    const won = p.is_radiant ? radWin : !radWin; if (won) rec.winCount++;
                    if (consumables.has(key)) rec.consumable = true;
                    itemAgg.set(key, rec);
                  }
                });
              }
              if (__highCache) {
                (__highCache.rapierTop || []).forEach(r => { const key = 'rapier'; const rec = itemAgg.get(key) || { count: 0, winCount: 0, coreCount: 0, supportCount: 0, cost: 6000, consumable: false, display: 'Divine Rapier' }; rec.count += r.count; itemAgg.set(key, rec); });
                (__highCache.gemTop || []).forEach(r => { const key = 'gem'; const rec = itemAgg.get(key) || { count: 0, winCount: 0, coreCount: 0, supportCount: 0, cost: 900, consumable: true, display: 'Gem of True Sight' }; rec.count += r.count; rec.consumable = true; itemAgg.set(key, rec); });
              }
              const items = Array.from(itemAgg.entries()).map(([k, v]) => { const role = v.coreCount === v.supportCount ? (v.coreCount > 0 ? 'core' : 'support') : (v.coreCount > v.supportCount ? 'core' : 'support'); const namePretty = v.display || k.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase()); const wins = Number(v.winCount || 0); const wr = v.count ? wins / v.count : 0; return { item: k, name: namePretty, count: v.count, wins, wr, gold: v.cost || 0, role, consumable: v.consumable }; }).sort((a, b) => b.count - a.count || b.gold - a.gold || a.name.localeCompare(b.name));
              const meta = {}; for (const it of items) { meta[it.item] = { cost: it.gold, consumable: it.consumable, role: it.role }; }
              window.ItemsBoughtViewer.mount(ib, { data: { items, meta, playerNames } });
            }
          } catch(e){ console.warn('ItemsBoughtViewer mount failed', e); }
        });
      };
      window.__ensureWards = () => {
        if (mountedWards) return; mountedWards = true;
        detailsPromise.then(details => {
          try {
            const container = document.getElementById('dvWardMount');
            if (container && window.WardViewer) {
              const countBy = new Map(), totalBy = new Map(), samplesBy = new Map();
              const senCountBy = new Map(), senBySide = new Map(), senByTeam = new Map(), senSamplesBy = new Map();
              const playersSet = new Map(); // aid -> name
              const teamNameByIdLocal = new Map();
              const placerCount = new Map();
              for (const md of details) {
                const dur = Number(md.duration || 0);
                const rid = Number(md.radiant_team_id || (md.radiant_team && md.radiant_team.team_id) || 0);
                const did = Number(md.dire_team_id || (md.dire_team && md.dire_team.team_id) || 0);
                const rname = (md.radiant_team && md.radiant_team.name) || md.radiant_name || teamNames[String(rid)] || 'Radiant';
                const dname = (md.dire_team && md.dire_team.name) || md.dire_name || teamNames[String(did)] || 'Dire';
                if (rid) teamNameByIdLocal.set(rid, rname);
                if (did) teamNameByIdLocal.set(did, dname);
                for (const p of (md.players || [])) {
                  const aid = Number(p.account_id || 0);
                  const isRad = !!(p.isRadiant ?? p.is_radiant ?? ((p.player_slot|0) < 128));
                  const teamId = isRad ? rid : did;
                  const side = isRad ? 'Radiant' : 'Dire';
                  const obs = Array.isArray(p.obs_log) ? p.obs_log : [];
                  const left = Array.isArray(p.obs_left_log) ? p.obs_left_log : [];
                  const L = left.map(o => ({ x: o.x, y: o.y, time: o.time })).sort((a, b) => a.time - b.time);
                  if (aid > 0 && obs.length) {
                    const nm = (__resolver && __resolver(aid)) || playerNames[String(aid)] || p.personaname || `Player ${aid}`;
                    if (!playersSet.has(aid)) playersSet.set(aid, nm);
                  }
                  for (const o of obs) {
                    const start = Number(o.time || 0); let removal = null;
                    for (const l of L) { if (!l.used && l.x === o.x && l.y === o.y && Number(l.time || 0) >= start) { removal = l; l.used = true; break; } }
                    let life = removal ? (removal.time - start) : Math.min(360, Math.max(0, dur - start)); if (life > 360) life = 360;
                    const k = `${o.x},${o.y}`;
                    countBy.set(k, (countBy.get(k) || 0) + 1);
                    totalBy.set(k, (totalBy.get(k) || 0) + life);
                    const sm = samplesBy.get(k) || [];
                    sm.push({ t: start, life, aid: aid || 0, teamId: teamId || 0, side });
                    samplesBy.set(k, sm);
                    if (aid > 0) placerCount.set(aid, (placerCount.get(aid) || 0) + 1);
                  }
                  // Sentries: placements only (pressure proxy)
                  const sp = Array.isArray(p.sen_log) ? p.sen_log : [];
                  for (const se of sp) {
                    const sx = Number(se.x), sy = Number(se.y), st = Number(se.time || 0);
                    const k = `${sx},${sy}`;
                    senCountBy.set(k, (senCountBy.get(k) || 0) + 1);
                    const sb = senBySide.get(k) || { Radiant: { count: 0 }, Dire: { count: 0 } };
                    sb[side].count++;
                    senBySide.set(k, sb);
                    if (teamId > 0) {
                      const tb = senByTeam.get(k) || {};
                      const to = tb[teamId] || { count: 0 };
                      to.count++;
                      tb[teamId] = to;
                      senByTeam.set(k, tb);
                    }
                    const sm = senSamplesBy.get(k) || [];
                    sm.push({ t: st, side, teamId, aid });
                    senSamplesBy.set(k, sm);
                  }
                }
              }
              const spots = Array.from(countBy.keys()).map(k => { const [x, y] = k.split(',').map(Number); const count = countBy.get(k) || 0; const total = totalBy.get(k) || 0; return { spot: k, x, y, count, total, avgSeconds: count ? Math.round(total / count) : 0, bySide: { Radiant: { count: 0, total: 0 }, Dire: { count: 0, total: 0 } }, byTeam: {}, samples: samplesBy.get(k) || [] }; });
              const sentries = Array.from(senCountBy.keys()).map(k => { const [x, y] = k.split(',').map(Number); return { spot: k, x, y, count: senCountBy.get(k) || 0, bySide: senBySide.get(k) || { Radiant: { count: 0 }, Dire: { count: 0 } }, byTeam: senByTeam.get(k) || {}, samples: senSamplesBy.get(k) || [] }; });
              // Build teams & players lists for selectors
              const teamsList = Array.from(teamNameByIdLocal.entries()).map(([id, name]) => ({ id: Number(id), name: String(name || `Team ${id}`) }))
                .sort((a,b)=> String(a.name||'').localeCompare(String(b.name||'')));
              const playersList = Array.from(playersSet.entries())
                .map(([id, name]) => ({ id: Number(id), name: String(name || `Player ${id}`), count: placerCount.get(id) || 0 }))
                .filter(p => p.count > 0)
                .sort((a,b)=> String(a.name||'').localeCompare(String(b.name||'')));
              window.WardViewer.mount(container, { mapConf, data: { spots, sentries, teams: teamsList, players: playersList }, options: { modeDefault: 'best', showExtras: true, showLongest: false, ignorePersistedPlayer: true, ignorePersistedCluster: true, extras: { wardPlayers: {}, wardLongest: [] } } });
            }
          } catch(err){ console.warn('WardViewer mount failed', err); }
        });
      };
      window.__ensureAwards = () => {
        if (mountedAwards) return; mountedAwards = true;
        detailsPromise.then(() => {
          try { if (__detailsCache && __resolver) renderAwards(computeAwardsFromDetails(__detailsCache, __resolver)); }
          catch(err){ console.warn('Awards render failed', err); }
        });
      };

      // Placement tab mounting from report.json
      window.__ensurePlacement = () => {
        if (mountedPlacement) return; mountedPlacement = true;
        try {
          const tbl = document.getElementById('placementTable'); if (!tbl) return;
          const tbody = tbl.tBodies && tbl.tBodies[0]; if (!tbody) return;
          const arr = (report && (report.placements || (report.highlights && report.highlights.placements))) || [];
          if (Array.isArray(arr) && arr.length) {
            const rows = arr.map(p => {
              const wr = p.games ? (p.wins / p.games) : 0;
              return `<tr>
                <td data-sort='${p.place||0}'>${p.place||''}</td>
                <td data-sort='${(p.name||'').toLowerCase()}'>${p.name||''}</td>
                <td data-sort='${p.games||0}'>${p.games||0}</td>
                <td data-sort='${(p.wins||0)/(p.games||1)}'><span class='win'>${p.wins||0}</span>-<span class='loss'>${(p.losses||0)}</span></td>
                <td data-sort='${wr}'>${fmtPct(wr)}</td>
              </tr>`;
            }).join('');
            tbody.innerHTML = rows;
            sortTable(tbl, 0, 'num', true);
          } else {
            tbody.innerHTML = "<tr><td colspan='5' class='sub'>no placement data</td></tr>";
          }
        } catch(e){ console.warn('Placement render failed', e); }
      };

      // CSV export wiring
      function tableToCSV(tableId) {
        const table = document.getElementById(tableId); if (!table) return '';
        const rows = [];
        const esc = (v) => {
          const s = String(v).replace(/\u00A0/g,' ').trim();
          if (/[",\n]/.test(s)) return '"' + s.replace(/"/g,'""') + '"';
          return s;
        };
        const hdr = Array.from(table.tHead ? table.tHead.rows[0].cells : []).map(th => th.textContent.trim());
        if (hdr.length) rows.push(hdr.map(esc).join(','));
        Array.from(table.tBodies[0].rows).forEach(tr => {
          const cols = Array.from(tr.cells).map(td => td.textContent.replace(/\s+/g,' ').trim());
          rows.push(cols.map(esc).join(','));
        });
        return rows.join('\n');
      }
      function downloadCSV(filename, csv) {
        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href = url; a.download = filename; document.body.appendChild(a); a.click();
        setTimeout(() => { document.body.removeChild(a); URL.revokeObjectURL(url); }, 0);
      }
      try {
        const suffix = `_${slug}`;
        const ep = document.getElementById('exportPlayersCsv'); if (ep) ep.addEventListener('click', () => { const csv = tableToCSV('playersTable'); if (csv) downloadCSV(`players${suffix}.csv`, csv); });
        const eh = document.getElementById('exportHeroesCsv'); if (eh) eh.addEventListener('click', () => { const csv = tableToCSV('heroesTable'); if (csv) downloadCSV(`heroes${suffix}.csv`, csv); });
  const et = document.getElementById('exportTeamsCsv'); if (et) et.addEventListener('click', () => { const csv = tableToCSV('teamsTable'); if (csv) downloadCSV(`teams${suffix}.csv`, csv); });
  const epc = document.getElementById('exportPlacementCsv'); if (epc) epc.addEventListener('click', () => { const csv = tableToCSV('placementTable'); if (csv) downloadCSV(`placement${suffix}.csv`, csv); });
        const edv = document.getElementById('exportDraftCsv'); if (edv) edv.addEventListener('click', () => {
          const mount = document.getElementById('draftMount'); const csv = mount && mount.__getDraftCSV ? mount.__getDraftCSV() : '';
          if (csv) downloadCSV(`draft${suffix}.csv`, csv);
        });
        const eld = document.getElementById('exportLaneDuosCsv'); if (eld) eld.addEventListener('click', () => {
          const mount = document.getElementById('ldMount'); const csv = mount && mount.__getLaneDuosCSV ? mount.__getLaneDuosCSV() : '';
          if (csv) downloadCSV(`lane_duos${suffix}.csv`, csv);
        });
      } catch (_e) {}

      const times = matches.map(m => m.start_time).filter(Boolean); const max = Math.max(...times);
      

      try { const last = localStorage.getItem('lv_tab'); if (last && window.__lvShowTab) { window.__lvShowTab(last); } } catch (_e) {}

      // Wire cache clear button
      try {
        const clearBtn = document.getElementById('btnClearCache');
        if (clearBtn) {
          clearBtn.addEventListener('click', () => {
            const keys = [
              `lv_details_${slug}`,
              `lv_details_meta_${slug}`,
              `lv_draft_${slug}`,
              `lv_laneduos_${slug}`
            ];
            try {
              keys.forEach(k => localStorage.removeItem(k));
              // Optional: keep last tab selection; just reload data
              location.reload();
            } catch (e) {
              console.warn('Cache clear failed', e);
            }
          });
        }
      } catch(_e) {}
    }

  enableSorting();
  main();
  </script>
</body>
</html>
